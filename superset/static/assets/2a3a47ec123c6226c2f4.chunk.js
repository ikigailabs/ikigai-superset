"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[740,1237],{50740:(e,t,o)=>{o.r(t),o.d(t,{default:()=>A});var n=o(2404),a=o.n(n),i=o(96540),r=o(35742),s=o(83505),l=o(70957),c=o(84193),u=o.n(c);function g(e,t,o=!0,n={}){if(!e.datasource)return;const a=new(u())("/"),i=function(e="base"){let t="/explore/";return["json","csv","query","results","samples"].includes(e)&&(t="/superset/explore_json/"),t}(t),r=a.search(!0);Object.keys(n).forEach((e=>{r[e]=n[e]})),r.form_data=function(e){const t=new Set;return JSON.stringify(e,((e,o)=>{if("object"==typeof o&&null!==o){if(t.has(o))try{return JSON.parse(JSON.stringify(o))}catch(e){return}t.add(o)}return o}))}(e),"standalone"===t&&(r.standalone="true");const s=a.directory(i).search(r).toString();return!o&&s.length>8e3?g({datasource:e.datasource,viz_type:e.viz_type},t,!1,{URL_IS_TOO_LONG_TO_SHARE:null}):s}var d=o(43979),p=o(28209),h=o(93897),m=o(62663),v=o(41937),f=o(17861),x=o(23465),_=o(82629),y=o(20901),S=o(71237);const P={deck_grid:d.getLayer,deck_screengrid:p.getLayer,deck_path:h.getLayer,deck_hex:m.getLayer,deck_scatter:v.getLayer,deck_geojson:f.getLayer,deck_arc:x.getLayer,deck_polygon:_.getLayer,deck_heatmap:y.getLayer,deck_contour:S.getLayer};var C=o(17437);const b=e=>{const t=(0,i.useRef)(),[o,n]=(0,i.useState)(),[c,u]=(0,i.useState)({}),d=(0,i.useCallback)((e=>{const{current:o}=t;o&&o.setTooltip(e)}),[]),p=(0,i.useCallback)(((t,o,a)=>{n(a),u({}),o.data.slices.forEach((o=>{const n=[...o.form_data.filters||[],...t.filters||[],...t.extra_filters||[]],a={...o,form_data:{...o.form_data,filters:n}},i=g(a.form_data,"json");i&&r.A.get({endpoint:i}).then((({json:t})=>{const o=P[a.form_data.viz_type](a.form_data,t,e.onAddFilter,d,e.datasource,[],e.onSelect);u((e=>({...e,[a.slice_id]:o})))})).catch((()=>{}))}))}),[e.datasource,e.onAddFilter,e.onSelect,d]),h=(0,s.Z)(e.formData.deck_slices);(0,i.useEffect)((()=>{const{formData:t,payload:o}=e;!a()(h,t.deck_slices)&&p(t,o)}),[p,h,e]);const{payload:m,formData:v,setControlValue:f,height:x,width:_}=e,y=Object.values(c);return(0,C.Y)(l.S,{ref:t,mapboxApiAccessToken:m.data.mapboxApiKey,viewport:o||e.viewport,layers:y,mapStyle:v.mapbox_style,setControlValue:f,onViewportChange:n,height:x,width:_})},A=(0,i.memo)(b)},23465:(e,t,o)=>{o.r(t),o.d(t,{default:()=>_,getLayer:()=>x});var n=o(64467),a=o(4679),i=o(34685),r=o(88514),s=o(31320),l=o(33023),c=o(82170);const u=[0,0,0,255],g={getSourcePosition:{type:"accessor",value:e=>e.sourcePosition},getTargetPosition:{type:"accessor",value:e=>e.targetPosition},getSourceColor:{type:"accessor",value:u},getTargetColor:{type:"accessor",value:u},getWidth:{type:"accessor",value:1},getHeight:{type:"accessor",value:1},getTilt:{type:"accessor",value:0},greatCircle:!1,widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}};class d extends a.A{constructor(...e){super(...e),(0,n.A)(this,"state",void 0)}getBounds(){var e;return null===(e=this.getAttributeManager())||void 0===e?void 0:e.getBounds(["instanceSourcePositions","instanceTargetPositions"])}getShaders(){return super.getShaders({vs:"#define SHADER_NAME arc-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\nattribute float instanceHeights;\nattribute float instanceTilts;\n\nuniform bool greatCircle;\nuniform bool useShortestPath;\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform int widthUnits;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nfloat paraboloid(float distance, float sourceZ, float targetZ, float ratio) {\n\n  float deltaZ = targetZ - sourceZ;\n  float dh = distance * instanceHeights;\n  if (dh == 0.0) {\n    return sourceZ + deltaZ * ratio;\n  }\n  float unitZ = deltaZ / dh;\n  float p2 = unitZ * unitZ + 1.0;\n  float dir = step(deltaZ, 0.0);\n  float z0 = mix(sourceZ, targetZ, dir);\n  float r = mix(ratio, 1.0 - ratio, dir);\n  return sqrt(r * (p2 - r)) * dh + z0;\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {\n  float distance = length(source.xy - target.xy);\n  float z = paraboloid(distance, source.z, target.z, segmentRatio);\n\n  float tiltAngle = radians(instanceTilts);\n  vec2 tiltDirection = normalize(target.xy - source.xy);\n  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\n\n  return vec3(\n    mix(source.xy, target.xy, segmentRatio) + tilt,\n    z * cos(tiltAngle)\n  );\n}\nfloat getAngularDist (vec2 source, vec2 target) {\n  vec2 sourceRadians = radians(source);\n  vec2 targetRadians = radians(target);\n  vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);\n  vec2 shd_sq = sin_half_delta * sin_half_delta;\n\n  float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;\n  return 2.0 * asin(sqrt(a));\n}\n\nvec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {\n  vec2 lngLat;\n  if(abs(angularDist - PI) < 0.001) {\n    lngLat = (1.0 - t) * source.xy + t * target.xy;\n  } else {\n    float a = sin((1.0 - t) * angularDist);\n    float b = sin(t * angularDist);\n    vec3 p = source3D.yxz * a + target3D.yxz * b;\n    lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));\n  }\n\n  float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);\n\n  return vec3(lngLat, z);\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));\n  float nextSegmentRatio = getSegmentRatio(min(numSegments - 1.0, segmentIndex + 1.0));\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  isValid = 1.0;\n\n  uv = vec2(segmentRatio, positions.y);\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n\n  vec4 curr;\n  vec4 next;\n  vec3 source;\n  vec3 target;\n\n  if ((greatCircle || project_uProjectionMode == PROJECTION_MODE_GLOBE) && project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n    source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));\n    target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));\n    float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);\n\n    vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);\n    vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);\n    vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);\n\n    if (abs(currPos.x - prevPos.x) > 180.0) {\n      indexDir = -1.0;\n      isValid = 0.0;\n    } else if (abs(currPos.x - nextPos.x) > 180.0) {\n      indexDir = 1.0;\n      isValid = 0.0;\n    }\n    nextPos = indexDir < 0.0 ? prevPos : nextPos;\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n\n    if (isValid == 0.0) {\n      nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;\n      float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);\n      currPos = mix(currPos, nextPos, t);\n      segmentRatio = mix(segmentRatio, nextSegmentRatio, t);\n    }\n\n    vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);\n    vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);\n  \n    curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);\n    next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\n  \n  } else {\n    vec3 source_world = instanceSourcePositions;\n    vec3 target_world = instanceTargetPositions;\n    if (useShortestPath) {\n      source_world.x = mod(source_world.x + 180., 360.0) - 180.;\n      target_world.x = mod(target_world.x + 180., 360.0) - 180.;\n\n      float deltaLng = target_world.x - source_world.x;\n      if (deltaLng > 180.) target_world.x -= 360.;\n      if (deltaLng < -180.) source_world.x -= 360.;\n    }\n    source = project_position(source_world, instanceSourcePositions64Low);\n    target = project_position(target_world, instanceTargetPositions64Low);\n    float antiMeridianX = 0.0;\n\n    if (useShortestPath) {\n      if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n        antiMeridianX = -(project_uCoordinateOrigin.x + 180.) / 360. * TILE_SIZE;\n      }\n      float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);\n\n      if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {\n        isValid = 0.0;\n        indexDir = sign(segmentRatio - thresholdRatio);\n        segmentRatio = thresholdRatio;\n      }\n    }\n\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n    vec3 currPos = interpolateFlat(source, target, segmentRatio);\n    vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);\n\n    if (useShortestPath) {\n      if (nextPos.x < antiMeridianX) {\n        currPos.x += TILE_SIZE;\n        nextPos.x += TILE_SIZE;\n      }\n    }\n\n    curr = project_common_position_to_clipspace(vec4(currPos, 1.0));\n    next = project_common_position_to_clipspace(vec4(nextPos, 1.0));\n    geometry.position = vec4(currPos, 1.0);\n  }\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels\n  );\n  vec3 offset = vec3(\n    getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  DECKGL_FILTER_GL_POSITION(curr, geometry);\n  gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);\n  vColor = vec4(color.rgb, color.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME arc-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nvoid main(void) {\n  if (isValid == 0.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  geometry.uv = uv;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[i.A,r.A]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceSourceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getSourceColor",defaultValue:u},instanceTargetColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getTargetColor",defaultValue:u},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1},instanceHeights:{size:1,transition:!0,accessor:"getHeight",defaultValue:1},instanceTilts:{size:1,transition:!0,accessor:"getTilt",defaultValue:0}})}updateState(e){if(super.updateState(e),e.changeFlags.extensionsChanged){var t;const{gl:e}=this.context;null===(t=this.state.model)||void 0===t||t.delete(),this.state.model=this._getModel(e),this.getAttributeManager().invalidateAll()}}draw({uniforms:e}){const{widthUnits:t,widthScale:o,widthMinPixels:n,widthMaxPixels:a,greatCircle:i,wrapLongitude:r}=this.props;this.state.model.setUniforms(e).setUniforms({greatCircle:i,widthUnits:s.p5[t],widthScale:o,widthMinPixels:n,widthMaxPixels:a,useShortestPath:r}).draw()}_getModel(e){let t=[];for(let e=0;e<50;e++)t=t.concat([e,1,0,e,-1,0]);const o=new l.A(e,{...this.getShaders(),id:this.props.id,geometry:new c.A({drawMode:5,attributes:{positions:new Float32Array(t)}}),isInstanced:!0});return o.setUniforms({numSegments:50}),o}}(0,n.A)(d,"layerName","ArcLayer"),(0,n.A)(d,"defaultProps",g),o(96540);var p=o(95579),h=o(41857),m=o(47823),v=o(32548),f=o(17437);function x(e,t,o,n){const a=t.data.features,i=e.color_picker,r=e.target_color_picker;return new d({data:a,getSourceColor:e=>e.sourceColor||e.color||[i.r,i.g,i.b,255*i.a],getTargetColor:e=>e.targetColor||e.color||[r.r,r.g,r.b,255*r.a],id:`path-layer-${e.slice_id}`,strokeWidth:e.stroke_width?e.stroke_width:3,...(0,h.T)(e,n,(s=e,e=>{var t,o,n,a,i,r,l,c,u;return(0,f.Y)("div",{className:"deckgl-tooltip"},(0,f.Y)(v.A,{label:(0,p.t)("Start (Longitude, Latitude): "),value:`${null==(t=e.object)||null==(o=t.sourcePosition)?void 0:o[0]}, ${null==(n=e.object)||null==(a=n.sourcePosition)?void 0:a[1]}`}),(0,f.Y)(v.A,{label:(0,p.t)("End (Longitude, Latitude): "),value:`${null==(i=e.object)||null==(r=i.targetPosition)?void 0:r[0]}, ${null==(l=e.object)||null==(c=l.targetPosition)?void 0:c[1]}`}),s.dimension&&(0,f.Y)(v.A,{label:`${null==s?void 0:s.dimension}: `,value:`${null==(u=e.object)?void 0:u.cat_color}`}))}))});var s}const _=(0,m.c)(x,(function(e){const t=[];return e.forEach((e=>{t.push(e.sourcePosition),t.push(e.targetPosition)})),t}))},71237:(e,t,o)=>{o.r(t),o.d(t,{default:()=>d,getLayer:()=>g});var n=o(33296),a=(o(96540),o(95579)),i=o(41857),r=o(25564),s=o(47823),l=o(32548),c=o(17437);function u(e){var t,o;return(0,c.Y)("div",{className:"deckgl-tooltip"},(0,c.Y)(l.A,{label:(0,a.t)("Centroid (Longitude and Latitude): "),value:`(${null==e?void 0:e.coordinate[0]}, ${null==e?void 0:e.coordinate[1]})`}),(0,c.Y)(l.A,{label:(0,a.t)("Threshold: "),value:`${null==e||null==(t=e.object)||null==(o=t.contour)?void 0:o.threshold}`}))}const g=function(e,t,o,a){const s=e,{aggregation:l="SUM",js_data_mutator:c,contours:g,cellSize:d="200"}=s;let p=t.data.features;const h=null==g?void 0:g.map((e=>{const{lowerThreshold:t,upperThreshold:o,color:n,strokeWidth:a}=e;return o?{threshold:[t,o],color:[n.r,n.g,n.b]}:{threshold:t,color:[n.r,n.g,n.b],strokeWidth:a}}));return c&&(p=(0,r.A)(s.js_data_mutator)(p)),new n.A({id:`contourLayer-${s.slice_id}`,data:p,contours:h,cellSize:Number(d||"200"),aggregation:l.toUpperCase(),getPosition:e=>e.position,getWeight:e=>e.weight||0,...(0,i.T)(s,a,u)})},d=(0,s.y)(g,(function(e){return e.map((e=>e.position))}))},17861:(e,t,o)=>{o.r(t),o.d(t,{default:()=>C,getLayer:()=>S});var n=o(96540),a=o(36465),i=o(25879),r=o.n(i),s=o(70957),l=o(49443),c=o(25564),u=o(41857),g=o(32548),d=o(95490),p=o(17437);const h={fillColor:"fillColor",color:"fillColor",fill:"fillColor","fill-color":"fillColor",strokeColor:"strokeColor","stroke-color":"strokeColor","stroke-width":"strokeWidth"},m=(e,t)=>{const o={};return Object.keys(e).forEach((t=>{t in h?o[h[t]]=e[t]:o[t]=e[t]})),"string"==typeof e.fillColor&&(o.fillColor=(0,l.hexToRGB)(e.fillColor)),"string"==typeof e.strokeColor&&(o.strokeColor=(0,l.hexToRGB)(e.strokeColor)),{...o,...t}};let v;const f=(e,t,o)=>{if(null!=e&&e.features&&e.features.forEach((n=>{f(n,t,e.extraProps||o)})),null!=e&&e.geometry){const n={...e,properties:m(e.properties,t)};n.extraProps||(n.extraProps=o),v.push(n)}};function x(e){var t;return(null==(t=e.object)?void 0:t.extraProps)&&(0,p.Y)("div",{className:"deckgl-tooltip"},Object.keys(e.object.extraProps).map(((t,o)=>{var n;return(0,p.Y)(g.A,{key:`prop-${o}`,label:`${t}: `,value:`${null==(n=e.object.extraProps)?void 0:n[t]}`})})))}const _=e=>{var t;return null==e||null==(t=e.properties)?void 0:t.fillColor},y=e=>{var t;return null==e||null==(t=e.properties)?void 0:t.strokeColor};function S(e,t,o,n){const i=e,r=i.fill_color_picker,s=i.stroke_color_picker,l=[r.r,r.g,r.b,255*r.a],g=[s.r,s.g,s.b,255*s.a],d={};let p;return l[3]>0&&(d.fillColor=l),g[3]>0&&(d.strokeColor=g),v=[],f(t.data,d),i.js_data_mutator&&(p=(0,c.A)(i.js_data_mutator),v=p(v)),new a.A({id:`geojson-layer-${i.slice_id}`,data:v,extruded:i.extruded,filled:i.filled,stroked:i.stroked,getFillColor:_,getLineColor:y,getLineWidth:i.line_width||1,pointRadiusScale:i.point_radius_scale,lineWidthUnits:i.line_width_unit,...(0,u.T)(i,n,x)})}const P=e=>{var t;const o=(0,n.useRef)(),a=(0,n.useCallback)((e=>{const{current:t}=o;t&&t.setTooltip(e)}),[]),{formData:i,payload:l,setControlValue:c,onAddFilter:u,height:g,width:h}=e,m=(0,n.useMemo)((()=>{if(i.autozoom){var t,o;const n=(null==l||null==(t=l.data)||null==(o=t.features)||null==o.reduce?void 0:o.reduce(((e,t)=>{const o=r()(t);return o?[...e,[o[0],o[1]],[o[2],o[3]]]:e}),[]))||[];if(n.length)return(0,d.A)(e.viewport,{width:h,height:g,points:n})}return e.viewport}),[i.autozoom,g,null==l||null==(t=l.data)?void 0:t.features,e.viewport,h]),v=S(i,l,0,a);return(0,p.Y)(s.S,{ref:o,mapboxApiAccessToken:l.data.mapboxApiKey,viewport:m,layers:[v],mapStyle:i.mapbox_style,setControlValue:c,height:g,width:h})},C=(0,n.memo)(P)},43979:(e,t,o)=>{o.r(t),o.d(t,{default:()=>h,getLayer:()=>p});var n=o(7388),a=(o(96540),o(95579)),i=o(94963),r=o(41857),s=o(25564),l=o(49443),c=o(47823),u=o(32548),g=o(17437);function d(e){return(0,g.Y)("div",{className:"deckgl-tooltip"},(0,g.Y)(u.A,{label:(0,a.t)("Longitude and Latitude")+": ",value:`${e.coordinate[0]}, ${e.coordinate[1]}`}),(0,g.Y)(u.A,{label:(0,a.t)("Height")+": ",value:`${e.object.elevationValue}`}))}function p(e,t,o,a){const c=e,u=i.getScale(c.color_scheme).range().map((e=>(0,l.hexToRGB)(e)));let g=t.data.features;c.js_data_mutator&&(g=(0,s.A)(c.js_data_mutator)(g));const p=(0,r.g)(c.js_agg_function,(e=>e.weight));return new n.A({id:`grid-layer-${c.slice_id}`,data:g,cellSize:c.grid_size,extruded:c.extruded,colorRange:u,outline:!1,getElevationValue:p,getColorValue:p,...(0,r.T)(c,a,d)})}const h=(0,c.y)(p,(function(e){return e.map((e=>e.position))}))},20901:(e,t,o)=>{o.r(t),o.d(t,{default:()=>h,getLayer:()=>p});var n=o(74993),a=(o(96540),o(95579)),i=o(69161),r=o(41857),s=o(25564),l=o(49443),c=o(47823),u=o(32548),g=o(17437);function d(e){return(0,g.Y)("div",{className:"deckgl-tooltip"},(0,g.Y)(u.A,{label:(0,a.t)("Centroid (Longitude and Latitude): "),value:`(${null==e?void 0:e.coordinate[0]}, ${null==e?void 0:e.coordinate[1]})`}))}const p=(e,t,o,a)=>{var c,u,g,p;const h=e,{intensity:m=1,radius_pixels:v=30,aggregation:f="SUM",js_data_mutator:x,linear_color_scheme:_}=h;let y=t.data.features;x&&(y=(0,s.A)(h.js_data_mutator)(y));const S=null==(c=(0,i.A)())||null==(u=c.get(_))?void 0:u.createLinearScale([0,6]),P=null==S||null==(g=S.range())||null==(p=g.map((e=>(0,l.hexToRGB)(e))))?void 0:p.reverse();return new n.A({id:`heatmp-layer-${h.slice_id}`,data:y,intensity:m,radiusPixels:v,colorRange:P,aggregation:f.toUpperCase(),getPosition:e=>e.position,getWeight:e=>e.weight?e.weight:1,...(0,r.T)(h,a,d)})},h=(0,c.y)(p,(function(e){return e.map((e=>e.position))}))},62663:(e,t,o)=>{o.r(t),o.d(t,{default:()=>R,getLayer:()=>w});var n=o(64467),a=o(93261),i=o(12559),r=o(39435),s=Math.PI/3,l=[0,s,2*s,3*s,4*s,5*s];function c(e){return e[0]}function u(e){return e[1]}var g=o(98537),d=o(88539),p=o(87454);function h(){}const m={colorDomain:null,colorRange:r.Q,getColorValue:{type:"accessor",value:null},getColorWeight:{type:"accessor",value:1},colorAggregation:"SUM",lowerPercentile:{type:"number",value:0,min:0,max:100},upperPercentile:{type:"number",value:100,min:0,max:100},colorScaleType:"quantize",onSetColorDomain:h,elevationDomain:null,elevationRange:[0,1e3],getElevationValue:{type:"accessor",value:null},getElevationWeight:{type:"accessor",value:1},elevationAggregation:"SUM",elevationLowerPercentile:{type:"number",value:0,min:0,max:100},elevationUpperPercentile:{type:"number",value:100,min:0,max:100},elevationScale:{type:"number",min:0,value:1},elevationScaleType:"linear",onSetElevationDomain:h,radius:{type:"number",value:1e3,min:1},coverage:{type:"number",min:0,max:1,value:1},extruded:!1,hexagonAggregator:function(e,t){const{data:o,radius:n}=e,{viewport:i,attributes:r}=t,d=o.length?function(e,t){const{attributes:o}=t,n=o.positions.value,{size:a}=o.positions.getAccessor();let i,r=1/0,s=1/0,l=-1/0,c=-1/0;for(i=0;i<a*e.length;i+=a){const e=n[i],t=n[i+1];Number.isFinite(e)&&Number.isFinite(t)&&(r=Math.min(e,r),l=Math.max(e,l),s=Math.min(t,s),c=Math.max(t,c))}return[r,s,l,c].every(Number.isFinite)?[(r+l)/2,(s+c)/2]:null}(o,t):null,p=function(e,t,o){const{unitsPerMeter:n}=t.getDistanceScales(o);return e*n[0]}(n,i,d),h=[],{iterable:m,objectInfo:v}=(0,g.X)(o),f=r.positions.value,{size:x}=r.positions.getAccessor();for(const e of m){v.index++;const t=v.index*x,o=[f[t],f[t+1]];Number.isFinite(o[0])&&Number.isFinite(o[1])?h.push({screenCoord:i.projectFlat(o),source:e,index:v.index}):a.A.warn("HexagonLayer: invalid position")()}const _=function(){var e,t,o,n=0,a=0,i=1,r=1,g=c,d=u;function p(e){var n,a={},i=[],r=e.length;for(n=0;n<r;++n)if(!isNaN(l=+g.call(null,s=e[n],n,e))&&!isNaN(c=+d.call(null,s,n,e))){var s,l,c,u=Math.round(c/=o),p=Math.round(l=l/t-(1&u)/2),h=c-u;if(3*Math.abs(h)>1){var m=l-p,v=p+(l<p?-1:1)/2,f=u+(c<u?-1:1),x=l-v,_=c-f;m*m+h*h>x*x+_*_&&(p=v+(1&u?1:-1)/2,u=f)}var y=p+"-"+u,S=a[y];S?S.push(s):(i.push(S=a[y]=[s]),S.x=(p+(1&u)/2)*t,S.y=u*o)}return i}function h(e){var t=0,o=0;return l.map((function(n){var a=Math.sin(n)*e,i=-Math.cos(n)*e,r=a-t,s=i-o;return t=a,o=i,[r,s]}))}return p.hexagon=function(t){return"m"+h(null==t?e:+t).join("l")+"z"},p.centers=function(){for(var s=[],l=Math.round(a/o),c=Math.round(n/t),u=l*o;u<r+e;u+=o,++l)for(var g=c*t+(1&l)*t/2;g<i+t/2;g+=t)s.push([g,u]);return s},p.mesh=function(){var t=h(e).slice(0,4).join("l");return p.centers().map((function(e){return"M"+e+"m"+t})).join("")},p.x=function(e){return arguments.length?(g=e,p):g},p.y=function(e){return arguments.length?(d=e,p):d},p.radius=function(n){return arguments.length?(t=2*(e=+n)*Math.sin(s),o=1.5*e,p):e},p.size=function(e){return arguments.length?(n=a=0,i=+e[0],r=+e[1],p):[i-n,r-a]},p.extent=function(e){return arguments.length?(n=+e[0][0],a=+e[0][1],i=+e[1][0],r=+e[1][1],p):[[n,a],[i,r]]},p.radius(1)}().radius(p).x((e=>e.screenCoord[0])).y((e=>e.screenCoord[1]));return{hexagons:_(h).map(((e,t)=>({position:i.unprojectFlat([e.x,e.y]),points:e,index:t}))),radiusCommon:p}},getPosition:{type:"accessor",value:e=>e.position},material:!0,_filterData:{type:"function",value:null,optional:!0}};class v extends p.A{constructor(...e){super(...e),(0,n.A)(this,"state",void 0)}initializeState(){const e=new d.A({getAggregator:e=>e.hexagonAggregator,getCellSize:e=>e.radius});this.state={cpuAggregator:e,aggregatorState:e.state,vertices:null},this.getAttributeManager().add({positions:{size:3,type:5130,accessor:"getPosition"}})}updateState(e){if(super.updateState(e),e.changeFlags.propsOrDataChanged){const t=this.state.cpuAggregator.updateState(e,{viewport:this.context.viewport,attributes:this.getAttributes()});if(this.state.aggregatorState.layerData!==t.layerData){const{hexagonVertices:e}=t.layerData||{};this.setState({vertices:e&&this.convertLatLngToMeterOffset(e)})}this.setState({aggregatorState:t})}}convertLatLngToMeterOffset(e){const{viewport:t}=this.context;if(Array.isArray(e)&&6===e.length){const o=e[0],n=e[3],a=[(o[0]+n[0])/2,(o[1]+n[1])/2],i=t.projectFlat(a),{metersPerUnit:r}=t.getDistanceScales(a);return e.map((e=>{const o=t.projectFlat(e);return[(o[0]-i[0])*r[0],(o[1]-i[1])*r[1]]}))}return a.A.error("HexagonLayer: hexagonVertices needs to be an array of 6 points")(),null}getPickingInfo({info:e}){return this.state.cpuAggregator.getPickingInfo({info:e})}_onGetSublayerColor(e){return this.state.cpuAggregator.getAccessor("fillColor")(e)}_onGetSublayerElevation(e){return this.state.cpuAggregator.getAccessor("elevation")(e)}_getSublayerUpdateTriggers(){return this.state.cpuAggregator.getUpdateTriggers(this.props)}renderLayers(){const{elevationScale:e,extruded:t,coverage:o,material:n,transitions:a}=this.props,{aggregatorState:r,vertices:s}=this.state,l=this.getSubLayerClass("hexagon-cell",i.A),c=this._getSublayerUpdateTriggers();return new l({...s?{vertices:s,radius:1}:{radius:r.layerData.radiusCommon||1,radiusUnits:"common",angle:90},diskResolution:6,elevationScale:e,extruded:t,coverage:o,material:n,getFillColor:this._onGetSublayerColor.bind(this),getElevation:this._onGetSublayerElevation.bind(this),transitions:a&&{getFillColor:a.getColorValue||a.getColorWeight,getElevation:a.getElevationValue||a.getElevationWeight}},this.getSubLayerProps({id:"hexagon-cell",updateTriggers:c}),{data:r.layerData.data})}}(0,n.A)(v,"layerName","HexagonLayer"),(0,n.A)(v,"defaultProps",m),o(96540);var f=o(95579),x=o(94963),_=o(41857),y=o(25564),S=o(49443),P=o(47823),C=o(32548),b=o(17437);function A(e){return(0,b.Y)("div",{className:"deckgl-tooltip"},(0,b.Y)(C.A,{label:(0,f.t)("Centroid (Longitude and Latitude): "),value:`(${e.coordinate[0]}, ${e.coordinate[1]})`}),(0,b.Y)(C.A,{label:(0,f.t)("Height")+": ",value:`${e.object.elevationValue}`}))}function w(e,t,o,n){const a=e,i=x.getScale(a.color_scheme).range().map((e=>(0,S.hexToRGB)(e)));let r=t.data.features;a.js_data_mutator&&(r=(0,y.A)(a.js_data_mutator)(r));const s=(0,_.g)(a.js_agg_function,(e=>null==e?void 0:e.weight));return new v({id:`hex-layer-${a.slice_id}`,data:r,radius:a.grid_size,extruded:a.extruded,colorRange:i,outline:!1,getElevationValue:s,getColorValue:s,...(0,_.T)(a,n,A)})}const R=(0,P.y)(w,(function(e){return e.map((e=>e.position))}))},93897:(e,t,o)=>{o.r(t),o.d(t,{default:()=>g,getLayer:()=>u}),o(96540);var n=o(36976),a=o(41857),i=o(25564),r=o(47823),s=o(32548),l=o(17437);function c(e){var t;return(null==(t=e.object)?void 0:t.extraProps)&&(0,l.Y)("div",{className:"deckgl-tooltip"},Object.keys(e.object.extraProps).map(((t,o)=>(0,l.Y)(s.A,{key:`prop-${o}`,label:`${t}: `,value:`${e.object.extraProps[t]}`}))))}function u(e,t,o,r){const s=e,l=s.color_picker,u=[l.r,l.g,l.b,255*l.a];let g=t.data.features.map((e=>({...e,path:e.path,width:s.line_width,color:u})));return s.js_data_mutator&&(g=(0,i.A)(s.js_data_mutator)(g)),new n.A({id:`path-layer-${s.slice_id}`,getColor:e=>e.color,getPath:e=>e.path,getWidth:e=>e.width,data:g,rounded:!0,widthScale:1,widthUnits:s.line_width_unit,...(0,a.T)(s,r,c)})}const g=(0,r.y)(u,(function(e){let t=[];return e.forEach((e=>{t=t.concat(e.path)})),t}))},41937:(e,t,o)=>{o.r(t),o.d(t,{default:()=>p,getLayer:()=>d});var n=o(55666),a=(o(96540),o(36770)),i=o(95579),r=o(41857),s=o(47823),l=o(32548);const c=1609.34;var u=o(17437);function g(e,t){return o=>{var n,r,s,c,g,d,p,h,m;const v=(null==t?void 0:t[e.point_radius_fixed.value])||(0,a.A)(null==(n=e.point_radius_fixed)?void 0:n.value);return(0,u.Y)("div",{className:"deckgl-tooltip"},(0,u.Y)(l.A,{label:(0,i.t)("Longitude and Latitude")+": ",value:`${null==(r=o.object)||null==(s=r.position)?void 0:s[0]}, ${null==(c=o.object)||null==(g=c.position)?void 0:g[1]}`}),(null==(d=o.object)?void 0:d.cat_color)&&(0,u.Y)(l.A,{label:(0,i.t)("Category")+": ",value:`${null==(p=o.object)?void 0:p.cat_color}`}),(null==(h=o.object)?void 0:h.metric)&&(0,u.Y)(l.A,{label:`${v}: `,value:`${null==(m=o.object)?void 0:m.metric}`}))}}function d(e,t,o,a,i){const s=e,l=t.data.features.map((e=>{let t=(o=s.point_unit,n=e.radius,("square_m"===o?Math.sqrt(n/Math.PI):"radius_m"===o?n:"radius_km"===o?1e3*n:"radius_miles"===o?n*c:"square_km"===o?1e3*Math.sqrt(n/Math.PI):"square_miles"===o?Math.sqrt(n/Math.PI)*c:null)||10);var o,n;if(s.multiplier&&(t*=s.multiplier),e.color)return{...e,radius:t};const a=s.color_picker||{r:0,g:0,b:0,a:1},i=[a.r,a.g,a.b,255*a.a];return{...e,radius:t,color:i}}));return new n.A({id:`scatter-layer-${s.slice_id}`,data:l,fp64:!0,getFillColor:e=>e.color,getRadius:e=>e.radius,radiusMinPixels:Number(s.min_radius)||void 0,radiusMaxPixels:Number(s.max_radius)||void 0,stroked:!1,...(0,r.T)(s,a,g(s,null==i?void 0:i.verboseMap))})}const p=(0,s.c)(d,(function(e){return e.map((e=>e.position))}))},28209:(e,t,o)=>{o.r(t),o.d(t,{default:()=>U,getLayer:()=>N});var n=o(63950),a=o.n(n),i=o(96540),r=o(64467),s=o(93261),l=o(527),c=o(67661),u=o(77325),g=o(38404),d=o(33023),p=o(82170),h=o(4679),m=o(88514),v=o(39435);const f=[0,0,0,0],x=[0,255,0,255],_=["minColor","maxColor","colorRange","colorDomain"],y={cellSizePixels:{value:100,min:1},cellMarginPixels:{value:2,min:0,max:5},colorDomain:null,colorRange:v.Q};class S extends h.A{constructor(...e){super(...e),(0,r.A)(this,"state",void 0)}static isSupported(e){return(0,u.QN)(e,[g.G.TEXTURE_FLOAT])}getShaders(){return{vs:"#define SHADER_NAME screen-grid-layer-vertex-shader\n#define RANGE_COUNT 6\n\nattribute vec3 positions;\nattribute vec3 instancePositions;\nattribute vec4 instanceCounts;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform vec3 cellScale;\nuniform vec4 minColor;\nuniform vec4 maxColor;\nuniform vec4 colorRange[RANGE_COUNT];\nuniform vec2 colorDomain;\nuniform bool shouldUseMinMax;\nuniform sampler2D maxTexture;\n\nvarying vec4 vColor;\nvarying float vSampleCount;\n\nvec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {\n  vec4 outColor = vec4(0., 0., 0., 0.);\n  if (value >= domain.x && value <= domain.y) {\n    float domainRange = domain.y - domain.x;\n    if (domainRange <= 0.) {\n      outColor = colorRange[0];\n    } else {\n      float rangeCount = float(RANGE_COUNT);\n      float rangeStep = domainRange / rangeCount;\n      float idx = floor((value - domain.x) / rangeStep);\n      idx = clamp(idx, 0., rangeCount - 1.);\n      int intIdx = int(idx);\n      outColor = colorRange[intIdx];\n    }\n  }\n  outColor = outColor / 255.;\n  return outColor;\n}\n\nvoid main(void) {\n  vSampleCount = instanceCounts.a;\n\n  float weight = instanceCounts.r;\n  float maxWeight = texture2D(maxTexture, vec2(0.5)).r;\n\n  float step = weight / maxWeight;\n  vec4 minMaxColor = mix(minColor, maxColor, step) / 255.;\n\n  vec2 domain = colorDomain;\n  float domainMaxValid = float(colorDomain.y != 0.);\n  domain.y = mix(maxWeight, colorDomain.y, domainMaxValid);\n  vec4 rangeColor = quantizeScale(domain, colorRange, weight);\n\n  float rangeMinMax = float(shouldUseMinMax);\n  vec4 color = mix(rangeColor, minMaxColor, rangeMinMax);\n  vColor = vec4(color.rgb, color.a * opacity);\n  picking_setPickingColor(instancePickingColors);\n\n  gl_Position = vec4(instancePositions + positions * cellScale, 1.);\n}\n",fs:"#define SHADER_NAME screen-grid-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying float vSampleCount;\n\nvoid main(void) {\n  if (vSampleCount <= 0.0) {\n    discard;\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[m.A]}}initializeState(){const{gl:e}=this.context;this.getAttributeManager().addInstanced({instancePositions:{size:3,update:this.calculateInstancePositions},instanceCounts:{size:4,noAlloc:!0}}),this.setState({model:this._getModel(e)})}shouldUpdateState({changeFlags:e}){return e.somethingChanged}updateState(e){super.updateState(e);const{oldProps:t,props:o,changeFlags:n}=e,a=this.getAttributeManager();o.numInstances!==t.numInstances?a.invalidateAll():t.cellSizePixels!==o.cellSizePixels&&a.invalidate("instancePositions"),this._updateUniforms(t,o,n)}draw({uniforms:e}){const{parameters:t,maxTexture:o}=this.props,n=this.props.minColor||f,a=this.props.maxColor||x,i=this.props.colorDomain||[1,0],{model:r}=this.state;r.setUniforms(e).setUniforms({minColor:n,maxColor:a,maxTexture:o,colorDomain:i}).draw({parameters:{depthTest:!1,depthMask:!1,...t}})}calculateInstancePositions(e,{numInstances:t}){const{width:o,height:n}=this.context.viewport,{cellSizePixels:a}=this.props,i=Math.ceil(o/a),{value:r,size:s}=e;for(let e=0;e<t;e++){const t=e%i,l=Math.floor(e/i);r[e*s+0]=t*a/o*2-1,r[e*s+1]=1-l*a/n*2,r[e*s+2]=0}}_getModel(e){return new d.A(e,{...this.getShaders(),id:this.props.id,geometry:new p.A({drawMode:6,attributes:{positions:new Float32Array([0,0,0,1,0,0,1,1,0,0,1,0])}}),isInstanced:!0})}_shouldUseMinMax(){const{minColor:e,maxColor:t,colorDomain:o,colorRange:n}=this.props;return e||t?(s.A.deprecated("ScreenGridLayer props: minColor and maxColor","colorRange, colorDomain")(),!0):!o&&!n}_updateUniforms(e,t,o){const{model:n}=this.state;if(_.some((o=>e[o]!==t[o]))&&n.setUniforms({shouldUseMinMax:this._shouldUseMinMax()}),e.colorRange!==t.colorRange&&n.setUniforms({colorRange:(0,v.Y)(t.colorRange)}),e.cellMarginPixels!==t.cellMarginPixels||e.cellSizePixels!==t.cellSizePixels||o.viewportChanged){const{width:e,height:t}=this.context.viewport,{cellSizePixels:o,cellMarginPixels:a}=this.props,i=o>a?a:0,r=new Float32Array([(o-i)/e*2,-(o-i)/t*2,1]);n.setUniforms({cellScale:r})}}}(0,r.A)(S,"layerName","ScreenGridCellLayer"),(0,r.A)(S,"defaultProps",y);var P=o(56238),C=o(67667);const b={...S.defaultProps,getPosition:{type:"accessor",value:e=>e.position},getWeight:{type:"accessor",value:1},gpuAggregation:!0,aggregation:"SUM"},A="positions",w={data:{props:["cellSizePixels"]},weights:{props:["aggregation"],accessors:["getWeight"]}};class R extends P.A{constructor(...e){super(...e),(0,r.A)(this,"state",void 0)}initializeState(){const{gl:e}=this.context;if(!S.isSupported(e))return this.setState({supported:!1}),void s.A.error("ScreenGridLayer: ".concat(this.id," is not supported on this browser"))();super.initializeAggregationLayer({dimensions:w,getCellSize:e=>e.cellSizePixels});const t={count:{size:1,operation:c.Rn.SUM,needMax:!0,maxTexture:(0,C.mV)(e,{id:"".concat(this.id,"-max-texture")})}};this.setState({supported:!0,projectPoints:!0,weights:t,subLayerData:{attributes:{}},maxTexture:t.count.maxTexture,positionAttributeName:"positions",posOffset:[0,0],translation:[1,-1]}),this.getAttributeManager().add({[A]:{size:3,accessor:"getPosition",type:5130,fp64:this.use64bitPositions()},count:{size:3,accessor:"getWeight"}})}shouldUpdateState({changeFlags:e}){return this.state.supported&&e.somethingChanged}updateState(e){super.updateState(e)}renderLayers(){if(!this.state.supported)return[];const{maxTexture:e,numRow:t,numCol:o,weights:n}=this.state,{updateTriggers:a}=this.props,{aggregationBuffer:i}=n.count;return new(this.getSubLayerClass("cells",S))(this.props,this.getSubLayerProps({id:"cell-layer",updateTriggers:a}),{data:{attributes:{instanceCounts:i}},maxTexture:e,numInstances:t*o})}finalizeState(e){super.finalizeState(e);const{aggregationBuffer:t,maxBuffer:o,maxTexture:n}=this.state;null==t||t.delete(),null==o||o.delete(),null==n||n.delete()}getPickingInfo({info:e}){const{index:t}=e;if(t>=0){const{gpuGridAggregator:o,gpuAggregation:n,weights:a}=this.state,i=n?o.getData("count"):a.count;e.object=l.A.getAggregationData({pixelIndex:t,...i})}return e}updateResults({aggregationData:e,maxData:t}){const{count:o}=this.state.weights;o.aggregationData=e,o.aggregationBuffer.setData({data:e}),o.maxData=t,o.maxTexture.setImageData({data:t})}updateAggregationState(e){const t=e.props.cellSizePixels,o=e.oldProps.cellSizePixels!==t,{viewportChanged:n}=e.changeFlags;let a=e.props.gpuAggregation;this.state.gpuAggregation!==e.props.gpuAggregation&&a&&!l.A.isSupported(this.context.gl)&&(s.A.warn("GPU Grid Aggregation not supported, falling back to CPU")(),a=!1);const i=a!==this.state.gpuAggregation;this.setState({gpuAggregation:a});const r=this.isAttributeChanged(A),{dimensions:c}=this.state,{data:u,weights:g}=c,d=r||i||n||this.isAggregationDirty(e,{compareAll:a,dimension:u}),p=this.isAggregationDirty(e,{dimension:g});this.setState({aggregationDataDirty:d,aggregationWeightsDirty:p});const{viewport:h}=this.context;if(n||o){const{width:e,height:o}=h,n=Math.ceil(e/t),a=Math.ceil(o/t);this.allocateResources(a,n),this.setState({scaling:[e/2,-o/2,1],gridOffset:{xOffset:t,yOffset:t},width:e,height:o,numCol:n,numRow:a})}p&&this._updateAccessors(e),(d||p)&&this._resetResults()}_updateAccessors(e){const{getWeight:t,aggregation:o,data:n}=e.props,{count:a}=this.state.weights;a&&(a.getWeight=t,a.operation=c.Rn[o]),this.setState({getValue:(0,c.Mm)(o,t,{data:n})})}_resetResults(){const{count:e}=this.state.weights;e&&(e.aggregationData=null)}}(0,r.A)(R,"layerName","ScreenGridLayer"),(0,r.A)(R,"defaultProps",b);var L=o(95579),T=o(25564),M=o(41857),D=o(32548),k=o(95490),j=o(70957),z=o(17437);function E(e){var t,o,n;return(0,z.Y)("div",{className:"deckgl-tooltip"},(0,z.Y)(D.A,{label:(0,L.t)("Longitude and Latitude")+": ",value:`${null==e||null==(t=e.coordinate)?void 0:t[0]}, ${null==e||null==(o=e.coordinate)?void 0:o[1]}`}),(0,z.Y)(D.A,{label:(0,L.t)("Weight")+": ",value:`${null==(n=e.object)?void 0:n.cellWeight}`}))}function N(e,t,o,n){const a=e,i=a.color_picker;let r=t.data.features.map((e=>({...e,color:[i.r,i.g,i.b,255*i.a]})));return a.js_data_mutator&&(r=(0,T.A)(a.js_data_mutator)(r)),new R({id:`screengrid-layer-${a.slice_id}`,data:r,cellSizePixels:a.grid_size,minColor:[i.r,i.g,i.b,0],maxColor:[i.r,i.g,i.b,255*i.a],outline:!1,getWeight:e=>e.weight||0,...(0,M.T)(a,n,E)})}const I=e=>{const t=(0,i.useRef)(),o=(0,i.useCallback)((()=>{const t=e.payload.data.features||[],{width:o,height:n,formData:a}=e;return a.autozoom?(0,k.A)(e.viewport,{width:o,height:n,points:(i=t,i.map((e=>e.position)))}):e.viewport;var i}),[e]),[n,r]=(0,i.useState)(e.payload.form_data),[s,l]=(0,i.useState)(o());(0,i.useEffect)((()=>{e.payload.form_data!==n&&(l(o()),r(e.payload.form_data))}),[o,e.payload.form_data,n]);const c=(0,i.useCallback)((e=>{const{current:o}=t;o&&o.setTooltip(e)}),[]),u=(0,i.useCallback)((()=>[N(e.formData,e.payload,a(),c)]),[e.formData,e.payload,c]),{formData:g,payload:d,setControlValue:p}=e;return(0,z.Y)("div",null,(0,z.Y)(j.S,{ref:t,viewport:s,layers:u(),setControlValue:p,mapStyle:g.mapbox_style,mapboxApiAccessToken:d.data.mapboxApiKey,width:e.width,height:e.height}))},U=(0,i.memo)(I)}}]);
//# sourceMappingURL=2a3a47ec123c6226c2f4.chunk.js.map