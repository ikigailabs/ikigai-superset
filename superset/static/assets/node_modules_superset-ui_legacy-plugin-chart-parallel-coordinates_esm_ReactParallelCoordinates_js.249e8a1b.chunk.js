"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunksuperset"] = globalThis["webpackChunksuperset"] || []).push([["node_modules_superset-ui_legacy-plugin-chart-parallel-coordinates_esm_ReactParallelCoordinates_js"],{

/***/ "./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ParallelCoordinates.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ParallelCoordinates.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"./node_modules/d3/d3.js\");\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @superset-ui/core */ \"./node_modules/@superset-ui/core/esm/color/SequentialSchemeRegistrySingleton.js\");\n/* harmony import */ var _vendor_parcoords_d3_parcoords__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vendor/parcoords/d3.parcoords */ \"./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.js\");\n/* harmony import */ var _vendor_parcoords_divgrid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./vendor/parcoords/divgrid */ \"./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/divgrid.js\");\n/* harmony import */ var _vendor_parcoords_d3_parcoords_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vendor/parcoords/d3.parcoords.css */ \"./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css\");\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/* eslint-disable react/sort-prop-types */\n\n\n\n\n\n\nconst propTypes = {\n  // Standard tabular data [{ fieldName1: value1, fieldName2: value2 }]\n  data: prop_types__WEBPACK_IMPORTED_MODULE_1___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_1___default().object)),\n  width: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number),\n  height: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number),\n  colorMetric: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n  includeSeries: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().bool),\n  linearColorScheme: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n  metrics: prop_types__WEBPACK_IMPORTED_MODULE_1___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_1___default().string)),\n  series: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n  showDatatable: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().bool)\n};\n\nfunction ParallelCoordinates(element, props) {\n  const {\n    data,\n    width,\n    height,\n    colorMetric,\n    includeSeries,\n    linearColorScheme,\n    metrics,\n    series,\n    showDatatable\n  } = props;\n  const cols = includeSeries ? [series].concat(metrics) : metrics;\n  const ttypes = {};\n  ttypes[series] = 'string';\n  metrics.forEach(v => {\n    ttypes[v] = 'number';\n  });\n  const colorScale = colorMetric ? (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_3__[\"default\"])().get(linearColorScheme).createLinearScale(d3__WEBPACK_IMPORTED_MODULE_0___default().extent(data, d => d[colorMetric])) : () => 'grey';\n\n  const color = d => colorScale(d[colorMetric]);\n\n  const container = d3__WEBPACK_IMPORTED_MODULE_0___default().select(element).classed('superset-legacy-chart-parallel-coordinates', true);\n  container.selectAll('*').remove();\n  const effHeight = showDatatable ? height / 2 : height;\n  const div = container.append('div').style('height', `${effHeight}px`).classed('parcoords', true);\n  const chart = (0,_vendor_parcoords_d3_parcoords__WEBPACK_IMPORTED_MODULE_4__[\"default\"])()(div.node()).width(width).color(color).alpha(0.5).composite('darken').height(effHeight).data(data).dimensions(cols).types(ttypes).render().createAxes().shadows().reorderable().brushMode('1D-axes');\n\n  if (showDatatable) {\n    // create data table, row hover highlighting\n    const grid = (0,_vendor_parcoords_divgrid__WEBPACK_IMPORTED_MODULE_5__[\"default\"])();\n    container.append('div').style('height', `${effHeight}px`).datum(data).call(grid).classed('parcoords grid', true).selectAll('.row').on({\n      mouseover(d) {\n        chart.highlight([d]);\n      },\n\n      mouseout: chart.unhighlight\n    }); // update data table on brush event\n\n    chart.on('brush', d => {\n      d3__WEBPACK_IMPORTED_MODULE_0___default().select('.grid').datum(d).call(grid).selectAll('.row').on({\n        mouseover(dd) {\n          chart.highlight([dd]);\n        },\n\n        mouseout: chart.unhighlight\n      });\n    });\n  }\n}\n\nParallelCoordinates.displayName = 'ParallelCoordinates';\nParallelCoordinates.propTypes = propTypes;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ParallelCoordinates);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL1BhcmFsbGVsQ29vcmRpbmF0ZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL25vZGVfbW9kdWxlcy9Ac3VwZXJzZXQtdWkvbGVnYWN5LXBsdWdpbi1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcy9lc20vUGFyYWxsZWxDb29yZGluYXRlcy5qcz9kMDRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgcmVhY3Qvc29ydC1wcm9wLXR5cGVzICovXG5pbXBvcnQgZDMgZnJvbSAnZDMnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGdldFNlcXVlbnRpYWxTY2hlbWVSZWdpc3RyeSB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcbmltcG9ydCBwYXJjb29yZHMgZnJvbSAnLi92ZW5kb3IvcGFyY29vcmRzL2QzLnBhcmNvb3Jkcyc7XG5pbXBvcnQgZGl2Z3JpZCBmcm9tICcuL3ZlbmRvci9wYXJjb29yZHMvZGl2Z3JpZCc7XG5pbXBvcnQgJy4vdmVuZG9yL3BhcmNvb3Jkcy9kMy5wYXJjb29yZHMuY3NzJztcbmNvbnN0IHByb3BUeXBlcyA9IHtcbiAgLy8gU3RhbmRhcmQgdGFidWxhciBkYXRhIFt7IGZpZWxkTmFtZTE6IHZhbHVlMSwgZmllbGROYW1lMjogdmFsdWUyIH1dXG4gIGRhdGE6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vYmplY3QpLFxuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICBjb2xvck1ldHJpYzogUHJvcFR5cGVzLnN0cmluZyxcbiAgaW5jbHVkZVNlcmllczogUHJvcFR5cGVzLmJvb2wsXG4gIGxpbmVhckNvbG9yU2NoZW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBtZXRyaWNzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKSxcbiAgc2VyaWVzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzaG93RGF0YXRhYmxlOiBQcm9wVHlwZXMuYm9vbFxufTtcblxuZnVuY3Rpb24gUGFyYWxsZWxDb29yZGluYXRlcyhlbGVtZW50LCBwcm9wcykge1xuICBjb25zdCB7XG4gICAgZGF0YSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgY29sb3JNZXRyaWMsXG4gICAgaW5jbHVkZVNlcmllcyxcbiAgICBsaW5lYXJDb2xvclNjaGVtZSxcbiAgICBtZXRyaWNzLFxuICAgIHNlcmllcyxcbiAgICBzaG93RGF0YXRhYmxlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgY29scyA9IGluY2x1ZGVTZXJpZXMgPyBbc2VyaWVzXS5jb25jYXQobWV0cmljcykgOiBtZXRyaWNzO1xuICBjb25zdCB0dHlwZXMgPSB7fTtcbiAgdHR5cGVzW3Nlcmllc10gPSAnc3RyaW5nJztcbiAgbWV0cmljcy5mb3JFYWNoKHYgPT4ge1xuICAgIHR0eXBlc1t2XSA9ICdudW1iZXInO1xuICB9KTtcbiAgY29uc3QgY29sb3JTY2FsZSA9IGNvbG9yTWV0cmljID8gZ2V0U2VxdWVudGlhbFNjaGVtZVJlZ2lzdHJ5KCkuZ2V0KGxpbmVhckNvbG9yU2NoZW1lKS5jcmVhdGVMaW5lYXJTY2FsZShkMy5leHRlbnQoZGF0YSwgZCA9PiBkW2NvbG9yTWV0cmljXSkpIDogKCkgPT4gJ2dyZXknO1xuXG4gIGNvbnN0IGNvbG9yID0gZCA9PiBjb2xvclNjYWxlKGRbY29sb3JNZXRyaWNdKTtcblxuICBjb25zdCBjb250YWluZXIgPSBkMy5zZWxlY3QoZWxlbWVudCkuY2xhc3NlZCgnc3VwZXJzZXQtbGVnYWN5LWNoYXJ0LXBhcmFsbGVsLWNvb3JkaW5hdGVzJywgdHJ1ZSk7XG4gIGNvbnRhaW5lci5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKTtcbiAgY29uc3QgZWZmSGVpZ2h0ID0gc2hvd0RhdGF0YWJsZSA/IGhlaWdodCAvIDIgOiBoZWlnaHQ7XG4gIGNvbnN0IGRpdiA9IGNvbnRhaW5lci5hcHBlbmQoJ2RpdicpLnN0eWxlKCdoZWlnaHQnLCBgJHtlZmZIZWlnaHR9cHhgKS5jbGFzc2VkKCdwYXJjb29yZHMnLCB0cnVlKTtcbiAgY29uc3QgY2hhcnQgPSBwYXJjb29yZHMoKShkaXYubm9kZSgpKS53aWR0aCh3aWR0aCkuY29sb3IoY29sb3IpLmFscGhhKDAuNSkuY29tcG9zaXRlKCdkYXJrZW4nKS5oZWlnaHQoZWZmSGVpZ2h0KS5kYXRhKGRhdGEpLmRpbWVuc2lvbnMoY29scykudHlwZXModHR5cGVzKS5yZW5kZXIoKS5jcmVhdGVBeGVzKCkuc2hhZG93cygpLnJlb3JkZXJhYmxlKCkuYnJ1c2hNb2RlKCcxRC1heGVzJyk7XG5cbiAgaWYgKHNob3dEYXRhdGFibGUpIHtcbiAgICAvLyBjcmVhdGUgZGF0YSB0YWJsZSwgcm93IGhvdmVyIGhpZ2hsaWdodGluZ1xuICAgIGNvbnN0IGdyaWQgPSBkaXZncmlkKCk7XG4gICAgY29udGFpbmVyLmFwcGVuZCgnZGl2Jykuc3R5bGUoJ2hlaWdodCcsIGAke2VmZkhlaWdodH1weGApLmRhdHVtKGRhdGEpLmNhbGwoZ3JpZCkuY2xhc3NlZCgncGFyY29vcmRzIGdyaWQnLCB0cnVlKS5zZWxlY3RBbGwoJy5yb3cnKS5vbih7XG4gICAgICBtb3VzZW92ZXIoZCkge1xuICAgICAgICBjaGFydC5oaWdobGlnaHQoW2RdKTtcbiAgICAgIH0sXG5cbiAgICAgIG1vdXNlb3V0OiBjaGFydC51bmhpZ2hsaWdodFxuICAgIH0pOyAvLyB1cGRhdGUgZGF0YSB0YWJsZSBvbiBicnVzaCBldmVudFxuXG4gICAgY2hhcnQub24oJ2JydXNoJywgZCA9PiB7XG4gICAgICBkMy5zZWxlY3QoJy5ncmlkJykuZGF0dW0oZCkuY2FsbChncmlkKS5zZWxlY3RBbGwoJy5yb3cnKS5vbih7XG4gICAgICAgIG1vdXNlb3ZlcihkZCkge1xuICAgICAgICAgIGNoYXJ0LmhpZ2hsaWdodChbZGRdKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb3VzZW91dDogY2hhcnQudW5oaWdobGlnaHRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cblBhcmFsbGVsQ29vcmRpbmF0ZXMuZGlzcGxheU5hbWUgPSAnUGFyYWxsZWxDb29yZGluYXRlcyc7XG5QYXJhbGxlbENvb3JkaW5hdGVzLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbmV4cG9ydCBkZWZhdWx0IFBhcmFsbGVsQ29vcmRpbmF0ZXM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ParallelCoordinates.js\n");

/***/ }),

/***/ "./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ReactParallelCoordinates.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ReactParallelCoordinates.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @superset-ui/core */ \"./node_modules/@superset-ui/core/esm/chart/components/reactify.js\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @superset-ui/core */ \"./node_modules/@superset-ui/core/esm/style/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ParallelCoordinates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ParallelCoordinates */ \"./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ParallelCoordinates.js\");\n/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @emotion/react */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\");\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\n\nconst ReactComponent = (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_ParallelCoordinates__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n\nconst ParallelCoordianes = ({\n  className,\n  ...otherProps\n}) => (0,_emotion_react__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"div\", {\n  className: className\n}, (0,_emotion_react__WEBPACK_IMPORTED_MODULE_4__.jsx)(ReactComponent, otherProps));\n\nParallelCoordianes.propTypes = {\n  className: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string.isRequired)\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_5__.styled)(ParallelCoordianes)`\n  .superset-legacy-chart-parallel-coordinates {\n    div.grid {\n      overflow: auto;\n      div.row {\n        &:hover {\n          background-color: #ccc;\n        }\n      }\n    }\n  }\n`);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL1JlYWN0UGFyYWxsZWxDb29yZGluYXRlcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL25vZGVfbW9kdWxlcy9Ac3VwZXJzZXQtdWkvbGVnYWN5LXBsdWdpbi1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcy9lc20vUmVhY3RQYXJhbGxlbENvb3JkaW5hdGVzLmpzPzZkNWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHN0eWxlZCwgcmVhY3RpZnkgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL1BhcmFsbGVsQ29vcmRpbmF0ZXMnO1xuaW1wb3J0IHsganN4IGFzIF9fX0Vtb3Rpb25KU1ggfSBmcm9tIFwiQGVtb3Rpb24vcmVhY3RcIjtcbmNvbnN0IFJlYWN0Q29tcG9uZW50ID0gcmVhY3RpZnkoQ29tcG9uZW50KTtcblxuY29uc3QgUGFyYWxsZWxDb29yZGlhbmVzID0gKHtcbiAgY2xhc3NOYW1lLFxuICAuLi5vdGhlclByb3BzXG59KSA9PiBfX19FbW90aW9uSlNYKFwiZGl2XCIsIHtcbiAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbn0sIF9fX0Vtb3Rpb25KU1goUmVhY3RDb21wb25lbnQsIG90aGVyUHJvcHMpKTtcblxuUGFyYWxsZWxDb29yZGlhbmVzLnByb3BUeXBlcyA9IHtcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWRcbn07XG5leHBvcnQgZGVmYXVsdCBzdHlsZWQoUGFyYWxsZWxDb29yZGlhbmVzKWBcbiAgLnN1cGVyc2V0LWxlZ2FjeS1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcyB7XG4gICAgZGl2LmdyaWQge1xuICAgICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgICBkaXYucm93IHtcbiAgICAgICAgJjpob3ZlciB7XG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2NjYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuYDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ReactParallelCoordinates.js\n");

/***/ }),

/***/ "./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* [LICENSE TBD] */\n\n/* eslint-disable */\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(config) {\n  var __ = {\n    data: [],\n    highlighted: [],\n    dimensions: [],\n    dimensionTitles: {},\n    dimensionTitleRotation: 0,\n    types: {},\n    brushed: false,\n    brushedColor: null,\n    alphaOnBrushed: 0.0,\n    mode: 'default',\n    rate: 20,\n    width: 600,\n    height: 300,\n    margin: {\n      top: 24,\n      right: 0,\n      bottom: 12,\n      left: 0\n    },\n    nullValueSeparator: 'undefined',\n    // set to \"top\" or \"bottom\"\n    nullValueSeparatorPadding: {\n      top: 8,\n      right: 0,\n      bottom: 8,\n      left: 0\n    },\n    color: '#069',\n    composite: 'source-over',\n    alpha: 0.7,\n    bundlingStrength: 0.5,\n    bundleDimension: null,\n    smoothness: 0.0,\n    showControlPoints: false,\n    hideAxis: []\n  };\n  extend(__, config);\n\n  var pc = function (selection) {\n    selection = pc.selection = d3.select(selection);\n    __.width = selection[0][0].clientWidth;\n    __.height = selection[0][0].clientHeight; // canvas data layers\n\n    ['marks', 'foreground', 'brushed', 'highlight'].forEach(function (layer) {\n      canvas[layer] = selection.append('canvas').attr('class', layer)[0][0];\n      ctx[layer] = canvas[layer].getContext('2d');\n    }); // svg tick and brush layers\n\n    pc.svg = selection.append('svg').attr('width', __.width).attr('height', __.height).append('svg:g').attr('transform', 'translate(' + __.margin.left + ',' + __.margin.top + ')');\n    return pc;\n  };\n\n  var events = d3.dispatch.apply(this, ['render', 'resize', 'highlight', 'brush', 'brushend', 'axesreorder'].concat(d3.keys(__))),\n      w = function () {\n    return __.width - __.margin.right - __.margin.left;\n  },\n      h = function () {\n    return __.height - __.margin.top - __.margin.bottom;\n  },\n      flags = {\n    brushable: false,\n    reorderable: false,\n    axes: false,\n    interactive: false,\n    debug: false\n  },\n      xscale = d3.scale.ordinal(),\n      yscale = {},\n      dragging = {},\n      line = d3.svg.line(),\n      axis = d3.svg.axis().orient('left').ticks(5),\n      g,\n      // groups for axes, brushes\n  ctx = {},\n      canvas = {},\n      clusterCentroids = []; // side effects for setters\n\n\n  var side_effects = d3.dispatch.apply(this, d3.keys(__)).on('composite', function (d) {\n    ctx.foreground.globalCompositeOperation = d.value;\n    ctx.brushed.globalCompositeOperation = d.value;\n  }).on('alpha', function (d) {\n    ctx.foreground.globalAlpha = d.value;\n    ctx.brushed.globalAlpha = d.value;\n  }).on('brushedColor', function (d) {\n    ctx.brushed.strokeStyle = d.value;\n  }).on('width', function (d) {\n    pc.resize();\n  }).on('height', function (d) {\n    pc.resize();\n  }).on('margin', function (d) {\n    pc.resize();\n  }).on('rate', function (d) {\n    brushedQueue.rate(d.value);\n    foregroundQueue.rate(d.value);\n  }).on('dimensions', function (d) {\n    xscale.domain(__.dimensions);\n\n    if (flags.interactive) {\n      pc.render().updateAxes();\n    }\n  }).on('bundleDimension', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    if (typeof d.value === 'number') {\n      if (d.value < __.dimensions.length) {\n        __.bundleDimension = __.dimensions[d.value];\n      } else if (d.value < __.hideAxis.length) {\n        __.bundleDimension = __.hideAxis[d.value];\n      }\n    } else {\n      __.bundleDimension = d.value;\n    }\n\n    __.clusterCentroids = compute_cluster_centroids(__.bundleDimension);\n  }).on('hideAxis', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    pc.dimensions(without(__.dimensions, d.value));\n  }); // expose the state of the chart\n\n  pc.state = __;\n  pc.flags = flags; // create getter/setters\n\n  getset(pc, __, events); // expose events\n\n  d3.rebind(pc, events, 'on'); // getter/setter with event firing\n\n  function getset(obj, state, events) {\n    d3.keys(state).forEach(function (key) {\n      obj[key] = function (x) {\n        if (!arguments.length) {\n          return state[key];\n        }\n\n        var old = state[key];\n        state[key] = x;\n        side_effects[key].call(pc, {\n          value: x,\n          previous: old\n        });\n        events[key].call(pc, {\n          value: x,\n          previous: old\n        });\n        return obj;\n      };\n    });\n  }\n\n  function extend(target, source) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  function without(arr, item) {\n    return arr.filter(function (elem) {\n      return item.indexOf(elem) === -1;\n    });\n  }\n  /** adjusts an axis' default range [h()+1, 1] if a NullValueSeparator is set */\n\n\n  function getRange() {\n    if (__.nullValueSeparator == 'bottom') {\n      return [h() + 1 - __.nullValueSeparatorPadding.bottom - __.nullValueSeparatorPadding.top, 1];\n    } else if (__.nullValueSeparator == 'top') {\n      return [h() + 1, 1 + __.nullValueSeparatorPadding.bottom + __.nullValueSeparatorPadding.top];\n    }\n\n    return [h() + 1, 1];\n  }\n\n  pc.autoscale = function () {\n    // yscale\n    var defaultScales = {\n      date: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return d[k] ? d[k].getTime() : null;\n        }); // special case if single value\n\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.time.scale().domain(extent).range(getRange());\n      },\n      number: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return +d[k];\n        }); // special case if single value\n\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.scale.linear().domain(extent).range(getRange());\n      },\n      string: function (k) {\n        var counts = {},\n            domain = []; // Let's get the count for each value so that we can sort the domain based\n        // on the number of items for each value.\n\n        __.data.map(function (p) {\n          if (p[k] === undefined && __.nullValueSeparator !== 'undefined') {\n            return; // null values will be drawn beyond the horizontal null value separator!\n          }\n\n          if (counts[p[k]] === undefined) {\n            counts[p[k]] = 1;\n          } else {\n            counts[p[k]] = counts[p[k]] + 1;\n          }\n        });\n\n        domain = Object.getOwnPropertyNames(counts).sort(function (a, b) {\n          return counts[a] - counts[b];\n        });\n        return d3.scale.ordinal().domain(domain).rangePoints(getRange());\n      }\n    };\n\n    __.dimensions.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    __.hideAxis.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    }); // xscale\n\n\n    xscale.rangePoints([0, w()], 1); // canvas sizes\n\n    pc.selection.selectAll('canvas').style('margin-top', __.margin.top + 'px').style('margin-left', __.margin.left + 'px').attr('width', w() + 2).attr('height', h() + 2); // default styles, needs to be set when canvas width changes\n\n    ctx.foreground.strokeStyle = __.color;\n    ctx.foreground.lineWidth = 1.4;\n    ctx.foreground.globalCompositeOperation = __.composite;\n    ctx.foreground.globalAlpha = __.alpha;\n    ctx.brushed.strokeStyle = __.brushedColor;\n    ctx.brushed.lineWidth = 1.4;\n    ctx.brushed.globalCompositeOperation = __.composite;\n    ctx.brushed.globalAlpha = __.alpha;\n    ctx.highlight.lineWidth = 3;\n    return this;\n  };\n\n  pc.scale = function (d, domain) {\n    yscale[d].domain(domain);\n    return this;\n  };\n\n  pc.flip = function (d) {\n    //yscale[d].domain().reverse();         // does not work\n    yscale[d].domain(yscale[d].domain().reverse()); // works\n\n    return this;\n  };\n\n  pc.commonScale = function (global, type) {\n    var t = type || 'number';\n\n    if (typeof global === 'undefined') {\n      global = true;\n    } // scales of the same type\n\n\n    var scales = __.dimensions.concat(__.hideAxis).filter(function (p) {\n      return __.types[p] == t;\n    });\n\n    if (global) {\n      var extent = d3.extent(scales.map(function (p, i) {\n        return yscale[p].domain();\n      }).reduce(function (a, b) {\n        return a.concat(b);\n      }));\n      scales.forEach(function (d) {\n        yscale[d].domain(extent);\n      });\n    } else {\n      scales.forEach(function (k) {\n        yscale[k].domain(d3.extent(__.data, function (d) {\n          return +d[k];\n        }));\n      });\n    } // update centroids\n\n\n    if (__.bundleDimension !== null) {\n      pc.bundleDimension(__.bundleDimension);\n    }\n\n    return this;\n  };\n\n  pc.detectDimensions = function () {\n    pc.types(pc.detectDimensionTypes(__.data));\n    pc.dimensions(d3.keys(pc.types()));\n    return this;\n  }; // a better \"typeof\" from this post: http://stackoverflow.com/questions/7390426/better-way-to-get-type-of-a-javascript-variable\n\n\n  pc.toType = function (v) {\n    return {}.toString.call(v).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n  }; // try to coerce to number before returning type\n\n\n  pc.toTypeCoerceNumbers = function (v) {\n    if (parseFloat(v) == v && v != null) {\n      return 'number';\n    }\n\n    return pc.toType(v);\n  }; // attempt to determine types of each dimension based on first row of data\n\n\n  pc.detectDimensionTypes = function (data) {\n    var types = {};\n    d3.keys(data[0]).forEach(function (col) {\n      types[col] = pc.toTypeCoerceNumbers(data[0][col]);\n    });\n    return types;\n  };\n\n  pc.render = function () {\n    // try to autodetect dimensions and create scales\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.render[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  pc.renderBrushed = function () {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.renderBrushed[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  function isBrushed() {\n    if (__.brushed && __.brushed.length !== __.data.length) return true;\n    var object = brush.currentMode().brushState();\n\n    for (var key in object) {\n      if (object.hasOwnProperty(key)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  pc.render.default = function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n    pc.renderBrushed.default();\n\n    __.data.forEach(path_foreground);\n  };\n\n  var foregroundQueue = d3.renderQueue(path_foreground).rate(50).clear(function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n  });\n\n  pc.render.queue = function () {\n    pc.renderBrushed.queue();\n    foregroundQueue(__.data);\n  };\n\n  pc.renderBrushed.default = function () {\n    pc.clear('brushed');\n\n    if (isBrushed()) {\n      __.brushed.forEach(path_brushed);\n    }\n  };\n\n  var brushedQueue = d3.renderQueue(path_brushed).rate(50).clear(function () {\n    pc.clear('brushed');\n  });\n\n  pc.renderBrushed.queue = function () {\n    if (isBrushed()) {\n      brushedQueue(__.brushed);\n    } else {\n      brushedQueue([]); // This is needed to clear the currently brushed items\n    }\n  };\n\n  function compute_cluster_centroids(d) {\n    var clusterCentroids = d3.map();\n    var clusterCounts = d3.map(); // determine clusterCounts\n\n    __.data.forEach(function (row) {\n      var scaled = yscale[d](row[d]);\n\n      if (!clusterCounts.has(scaled)) {\n        clusterCounts.set(scaled, 0);\n      }\n\n      var count = clusterCounts.get(scaled);\n      clusterCounts.set(scaled, count + 1);\n    });\n\n    __.data.forEach(function (row) {\n      __.dimensions.map(function (p, i) {\n        var scaled = yscale[d](row[d]);\n\n        if (!clusterCentroids.has(scaled)) {\n          var map = d3.map();\n          clusterCentroids.set(scaled, map);\n        }\n\n        if (!clusterCentroids.get(scaled).has(p)) {\n          clusterCentroids.get(scaled).set(p, 0);\n        }\n\n        var value = clusterCentroids.get(scaled).get(p);\n        value += yscale[p](row[p]) / clusterCounts.get(scaled);\n        clusterCentroids.get(scaled).set(p, value);\n      });\n    });\n\n    return clusterCentroids;\n  }\n\n  function compute_centroids(row) {\n    var centroids = [];\n    var p = __.dimensions;\n    var cols = p.length;\n    var a = 0.5; // center between axes\n\n    for (var i = 0; i < cols; ++i) {\n      // centroids on 'real' axes\n      var x = position(p[i]);\n      var y = yscale[p[i]](row[p[i]]);\n      centroids.push($V([x, y])); // centroids on 'virtual' axes\n\n      if (i < cols - 1) {\n        var cx = x + a * (position(p[i + 1]) - x);\n        var cy = y + a * (yscale[p[i + 1]](row[p[i + 1]]) - y);\n\n        if (__.bundleDimension !== null) {\n          var leftCentroid = __.clusterCentroids.get(yscale[__.bundleDimension](row[__.bundleDimension])).get(p[i]);\n\n          var rightCentroid = __.clusterCentroids.get(yscale[__.bundleDimension](row[__.bundleDimension])).get(p[i + 1]);\n\n          var centroid = 0.5 * (leftCentroid + rightCentroid);\n          cy = centroid + (1 - __.bundlingStrength) * (cy - centroid);\n        }\n\n        centroids.push($V([cx, cy]));\n      }\n    }\n\n    return centroids;\n  }\n\n  function compute_control_points(centroids) {\n    var cols = centroids.length;\n    var a = __.smoothness;\n    var cps = [];\n    cps.push(centroids[0]);\n    cps.push($V([centroids[0].e(1) + a * 2 * (centroids[1].e(1) - centroids[0].e(1)), centroids[0].e(2)]));\n\n    for (var col = 1; col < cols - 1; ++col) {\n      var mid = centroids[col];\n      var left = centroids[col - 1];\n      var right = centroids[col + 1];\n      var diff = left.subtract(right);\n      cps.push(mid.add(diff.x(a)));\n      cps.push(mid);\n      cps.push(mid.subtract(diff.x(a)));\n    }\n\n    cps.push($V([centroids[cols - 1].e(1) + a * 2 * (centroids[cols - 2].e(1) - centroids[cols - 1].e(1)), centroids[cols - 1].e(2)]));\n    cps.push(centroids[cols - 1]);\n    return cps;\n  }\n\n  pc.shadows = function () {\n    flags.shadows = true;\n    pc.alphaOnBrushed(0.1);\n    pc.render();\n    return this;\n  }; // draw dots with radius r on the axis line where data intersects\n\n\n  pc.axisDots = function (r) {\n    var r = r || 0.1;\n    var ctx = pc.ctx.marks;\n    var startAngle = 0;\n    var endAngle = 2 * Math.PI;\n    ctx.globalAlpha = d3.min([1 / Math.pow(__.data.length, 1 / 2), 1]);\n\n    __.data.forEach(function (d) {\n      __.dimensions.map(function (p, i) {\n        ctx.beginPath();\n        ctx.arc(position(p), yscale[p](d[p]), r, startAngle, endAngle);\n        ctx.stroke();\n        ctx.fill();\n      });\n    });\n\n    return this;\n  }; // draw single cubic bezier curve\n\n\n  function single_curve(d, ctx) {\n    var centroids = compute_centroids(d);\n    var cps = compute_control_points(centroids);\n    ctx.moveTo(cps[0].e(1), cps[0].e(2));\n\n    for (var i = 1; i < cps.length; i += 3) {\n      if (__.showControlPoints) {\n        for (var j = 0; j < 3; j += 1) {\n          ctx.fillRect(cps[i + j].e(1), cps[i + j].e(2), 2, 2);\n        }\n      }\n\n      ctx.bezierCurveTo(cps[i].e(1), cps[i].e(2), cps[i + 1].e(1), cps[i + 1].e(2), cps[i + 2].e(1), cps[i + 2].e(2));\n    }\n  } // draw single polyline\n\n\n  function color_path(d, ctx) {\n    ctx.beginPath();\n\n    if (__.bundleDimension !== null && __.bundlingStrength > 0 || __.smoothness > 0) {\n      single_curve(d, ctx);\n    } else {\n      single_path(d, ctx);\n    }\n\n    ctx.stroke();\n  } // draw many polylines of the same color\n\n\n  function paths(data, ctx) {\n    ctx.clearRect(-1, -1, w() + 2, h() + 2);\n    ctx.beginPath();\n    data.forEach(function (d) {\n      if (__.bundleDimension !== null && __.bundlingStrength > 0 || __.smoothness > 0) {\n        single_curve(d, ctx);\n      } else {\n        single_path(d, ctx);\n      }\n    });\n    ctx.stroke();\n  } // returns the y-position just beyond the separating null value line\n\n\n  function getNullPosition() {\n    if (__.nullValueSeparator == 'bottom') {\n      return h() + 1;\n    } else if (__.nullValueSeparator == 'top') {\n      return 1;\n    } else {\n      console.log(\"A value is NULL, but nullValueSeparator is not set; set it to 'bottom' or 'top'.\");\n    }\n\n    return h() + 1;\n  }\n\n  function single_path(d, ctx) {\n    __.dimensions.map(function (p, i) {\n      if (i == 0) {\n        ctx.moveTo(position(p), typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p]));\n      } else {\n        ctx.lineTo(position(p), typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p]));\n      }\n    });\n  }\n\n  function path_brushed(d, i) {\n    if (__.brushedColor !== null) {\n      ctx.brushed.strokeStyle = d3.functor(__.brushedColor)(d, i);\n    } else {\n      ctx.brushed.strokeStyle = d3.functor(__.color)(d, i);\n    }\n\n    return color_path(d, ctx.brushed);\n  }\n\n  function path_foreground(d, i) {\n    ctx.foreground.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.foreground);\n  }\n\n  function path_highlight(d, i) {\n    ctx.highlight.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.highlight);\n  }\n\n  pc.clear = function (layer) {\n    ctx[layer].clearRect(0, 0, w() + 2, h() + 2); // This will make sure that the foreground items are transparent\n    // without the need for changing the opacity style of the foreground canvas\n    // as this would stop the css styling from working\n\n    if (layer === 'brushed' && isBrushed()) {\n      ctx.brushed.fillStyle = pc.selection.style('background-color');\n      ctx.brushed.globalAlpha = 1 - __.alphaOnBrushed;\n      ctx.brushed.fillRect(0, 0, w() + 2, h() + 2);\n      ctx.brushed.globalAlpha = __.alpha;\n    }\n\n    return this;\n  };\n\n  d3.rebind(pc, axis, 'ticks', 'orient', 'tickValues', 'tickSubdivide', 'tickSize', 'tickPadding', 'tickFormat');\n\n  function flipAxisAndUpdatePCP(dimension) {\n    var g = pc.svg.selectAll('.dimension');\n    pc.flip(dimension);\n    d3.select(this.parentElement).transition().duration(1100).call(axis.scale(yscale[dimension]));\n    pc.render();\n  }\n\n  function rotateLabels() {\n    var delta = d3.event.deltaY;\n    delta = delta < 0 ? -5 : delta;\n    delta = delta > 0 ? 5 : delta;\n    __.dimensionTitleRotation += delta;\n    pc.svg.selectAll('text.label').attr('transform', 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')');\n    d3.event.preventDefault();\n  }\n\n  function dimensionLabels(d) {\n    return d in __.dimensionTitles ? __.dimensionTitles[d] : d; // dimension display names\n  }\n\n  pc.createAxes = function () {\n    if (g) pc.removeAxes(); // Add a group element for each dimension.\n\n    g = pc.svg.selectAll('.dimension').data(__.dimensions, function (d) {\n      return d;\n    }).enter().append('svg:g').attr('class', 'dimension').attr('transform', function (d) {\n      return 'translate(' + xscale(d) + ')';\n    }); // Add an axis and title.\n\n    g.append('svg:g').attr('class', 'axis').attr('transform', 'translate(0,0)').each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).append('svg:text').attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label'\n    }).text(dimensionLabels).on('dblclick', flipAxisAndUpdatePCP).on('wheel', rotateLabels);\n\n    if (__.nullValueSeparator == 'top') {\n      pc.svg.append('line').attr('x1', 0).attr('y1', 1 + __.nullValueSeparatorPadding.top).attr('x2', w()).attr('y2', 1 + __.nullValueSeparatorPadding.top).attr('stroke-width', 1).attr('stroke', '#777').attr('fill', 'none').attr('shape-rendering', 'crispEdges');\n    } else if (__.nullValueSeparator == 'bottom') {\n      pc.svg.append('line').attr('x1', 0).attr('y1', h() + 1 - __.nullValueSeparatorPadding.bottom).attr('x2', w()).attr('y2', h() + 1 - __.nullValueSeparatorPadding.bottom).attr('stroke-width', 1).attr('stroke', '#777').attr('fill', 'none').attr('shape-rendering', 'crispEdges');\n    }\n\n    flags.axes = true;\n    return this;\n  };\n\n  pc.removeAxes = function () {\n    g.remove();\n    return this;\n  };\n\n  pc.updateAxes = function () {\n    var g_data = pc.svg.selectAll('.dimension').data(__.dimensions); // Enter\n\n    g_data.enter().append('svg:g').attr('class', 'dimension').attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).style('opacity', 0).append('svg:g').attr('class', 'axis').attr('transform', 'translate(0,0)').each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).append('svg:text').attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label'\n    }).text(dimensionLabels).on('dblclick', flipAxisAndUpdatePCP).on('wheel', rotateLabels); // Update\n\n    g_data.attr('opacity', 0);\n    g_data.select('.axis').transition().duration(1100).each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n    g_data.select('.label').transition().duration(1100).text(dimensionLabels).attr('transform', 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')'); // Exit\n\n    g_data.exit().remove();\n    g = pc.svg.selectAll('.dimension');\n    g.transition().duration(1100).attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).style('opacity', 1);\n    pc.svg.selectAll('.axis').transition().duration(1100).each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n\n    if (pc.brushMode() !== 'None') {\n      var mode = pc.brushMode();\n      pc.brushMode('None');\n      pc.brushMode(mode);\n    }\n\n    return this;\n  }; // Jason Davies, http://bl.ocks.org/1341281\n\n\n  pc.reorderable = function () {\n    if (!g) pc.createAxes();\n    g.style('cursor', 'move').call(d3.behavior.drag().on('dragstart', function (d) {\n      dragging[d] = this.__origin__ = xscale(d);\n    }).on('drag', function (d) {\n      dragging[d] = Math.min(w(), Math.max(0, this.__origin__ += d3.event.dx));\n\n      __.dimensions.sort(function (a, b) {\n        return position(a) - position(b);\n      });\n\n      xscale.domain(__.dimensions);\n      pc.render();\n      g.attr('transform', function (d) {\n        return 'translate(' + position(d) + ')';\n      });\n    }).on('dragend', function (d) {\n      // Let's see if the order has changed and send out an event if so.\n      var i = 0,\n          j = __.dimensions.indexOf(d),\n          elem = this,\n          parent = this.parentElement;\n\n      while ((elem = elem.previousElementSibling) != null) ++i;\n\n      if (i !== j) {\n        events.axesreorder.call(pc, __.dimensions); // We now also want to reorder the actual dom elements that represent\n        // the axes. That is, the g.dimension elements. If we don't do this,\n        // we get a weird and confusing transition when updateAxes is called.\n        // This is due to the fact that, initially the nth g.dimension element\n        // represents the nth axis. However, after a manual reordering,\n        // without reordering the dom elements, the nth dom elements no longer\n        // necessarily represents the nth axis.\n        //\n        // i is the original index of the dom element\n        // j is the new index of the dom element\n\n        if (i > j) {\n          // Element moved left\n          parent.insertBefore(this, parent.children[j - 1]);\n        } else {\n          // Element moved right\n          if (j + 1 < parent.children.length) {\n            parent.insertBefore(this, parent.children[j + 1]);\n          } else {\n            parent.appendChild(this);\n          }\n        }\n      }\n\n      delete this.__origin__;\n      delete dragging[d];\n      d3.select(this).transition().attr('transform', 'translate(' + xscale(d) + ')');\n      pc.render();\n    }));\n    flags.reorderable = true;\n    return this;\n  }; // Reorder dimensions, such that the highest value (visually) is on the left and\n  // the lowest on the right. Visual values are determined by the data values in\n  // the given row.\n\n\n  pc.reorder = function (rowdata) {\n    var dims = __.dimensions.slice(0);\n\n    __.dimensions.sort(function (a, b) {\n      var pixelDifference = yscale[a](rowdata[a]) - yscale[b](rowdata[b]); // Array.sort is not necessarily stable, this means that if pixelDifference is zero\n      // the ordering of dimensions might change unexpectedly. This is solved by sorting on\n      // variable name in that case.\n\n      if (pixelDifference === 0) {\n        return a.localeCompare(b);\n      } // else\n\n\n      return pixelDifference;\n    }); // NOTE: this is relatively cheap given that:\n    // number of dimensions < number of data items\n    // Thus we check equality of order to prevent rerendering when this is the case.\n\n\n    var reordered = false;\n    dims.some(function (val, index) {\n      reordered = val !== __.dimensions[index];\n      return reordered;\n    });\n\n    if (reordered) {\n      xscale.domain(__.dimensions);\n\n      var highlighted = __.highlighted.slice(0);\n\n      pc.unhighlight();\n      g.transition().duration(1500).attr('transform', function (d) {\n        return 'translate(' + xscale(d) + ')';\n      });\n      pc.render(); // pc.highlight() does not check whether highlighted is length zero, so we do that here.\n\n      if (highlighted.length !== 0) {\n        pc.highlight(highlighted);\n      }\n    }\n  }; // pairs of adjacent dimensions\n\n\n  pc.adjacent_pairs = function (arr) {\n    var ret = [];\n\n    for (var i = 0; i < arr.length - 1; i += 1) {\n      ret.push([arr[i], arr[i + 1]]);\n    }\n\n    return ret;\n  };\n\n  var brush = {\n    modes: {\n      None: {\n        install: function (pc) {},\n        // Nothing to be done.\n        uninstall: function (pc) {},\n        // Nothing to be done.\n        selected: function () {\n          return [];\n        },\n        // Nothing to return\n        brushState: function () {\n          return {};\n        }\n      }\n    },\n    mode: 'None',\n    predicate: 'AND',\n    currentMode: function () {\n      return this.modes[this.mode];\n    }\n  }; // This function can be used for 'live' updates of brushes. That is, during the\n  // specification of a brush, this method can be called to update the view.\n  //\n  // @param newSelection - The new set of data items that is currently contained\n  //                       by the brushes\n\n  function brushUpdated(newSelection) {\n    __.brushed = newSelection;\n    events.brush.call(pc, __.brushed);\n    pc.renderBrushed();\n  }\n\n  function brushPredicate(predicate) {\n    if (!arguments.length) {\n      return brush.predicate;\n    }\n\n    predicate = String(predicate).toUpperCase();\n\n    if (predicate !== 'AND' && predicate !== 'OR') {\n      throw 'Invalid predicate ' + predicate;\n    }\n\n    brush.predicate = predicate;\n    __.brushed = brush.currentMode().selected();\n    pc.renderBrushed();\n    return pc;\n  }\n\n  pc.brushModes = function () {\n    return Object.getOwnPropertyNames(brush.modes);\n  };\n\n  pc.brushMode = function (mode) {\n    if (arguments.length === 0) {\n      return brush.mode;\n    }\n\n    if (pc.brushModes().indexOf(mode) === -1) {\n      throw 'pc.brushmode: Unsupported brush mode: ' + mode;\n    } // Make sure that we don't trigger unnecessary events by checking if the mode\n    // actually changes.\n\n\n    if (mode !== brush.mode) {\n      // When changing brush modes, the first thing we need to do is clearing any\n      // brushes from the current mode, if any.\n      if (brush.mode !== 'None') {\n        pc.brushReset();\n      } // Next, we need to 'uninstall' the current brushMode.\n\n\n      brush.modes[brush.mode].uninstall(pc); // Finally, we can install the requested one.\n\n      brush.mode = mode;\n      brush.modes[brush.mode].install();\n\n      if (mode === 'None') {\n        delete pc.brushPredicate;\n      } else {\n        pc.brushPredicate = brushPredicate;\n      }\n    }\n\n    return pc;\n  }; // brush mode: 1D-Axes\n\n\n  (function () {\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    } // data within extents\n\n\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n          extents = actives.map(function (p) {\n        return brushes[p].extent();\n      }); // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n\n\n      if (actives.length === 0) return __.data; // test if within range\n\n      var within = {\n        date: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return extents[dimension][0] <= yscale[p](d[p]) && yscale[p](d[p]) <= extents[dimension][1];\n          } else {\n            return extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1];\n          }\n        },\n        number: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return extents[dimension][0] <= yscale[p](d[p]) && yscale[p](d[p]) <= extents[dimension][1];\n          } else {\n            return extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1];\n          }\n        },\n        string: function (d, p, dimension) {\n          return extents[dimension][0] <= yscale[p](d[p]) && yscale[p](d[p]) <= extents[dimension][1];\n        }\n      };\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function brushExtents(extents) {\n      if (typeof extents === 'undefined') {\n        var extents = {};\n\n        __.dimensions.forEach(function (d) {\n          var brush = brushes[d];\n\n          if (brush !== undefined && !brush.empty()) {\n            var extent = brush.extent();\n            extent.sort(d3.ascending);\n            extents[d] = extent;\n          }\n        });\n\n        return extents;\n      } else {\n        //first get all the brush selections\n        var brushSelections = {};\n        g.selectAll('.brush').each(function (d) {\n          brushSelections[d] = d3.select(this);\n        }); // loop over each dimension and update appropriately (if it was passed in through extents)\n\n        __.dimensions.forEach(function (d) {\n          if (extents[d] === undefined) {\n            return;\n          }\n\n          var brush = brushes[d];\n\n          if (brush !== undefined) {\n            //update the extent\n            brush.extent(extents[d]); //redraw the brush\n\n            brush(brushSelections[d]); //fire some events\n\n            brush.event(brushSelections[d]);\n          }\n        }); //redraw the chart\n\n\n        pc.renderBrushed();\n      }\n    }\n\n    function brushFor(axis) {\n      var brush = d3.svg.brush();\n      brush.y(yscale[axis]).on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).on('brush', function () {\n        brushUpdated(selected());\n      }).on('brushend', function () {\n        events.brushend.call(pc, __.brushed);\n      });\n      brushes[axis] = brush;\n      return brush;\n    }\n\n    function brushReset(dimension) {\n      __.brushed = false;\n\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes(); // Add and store a brush for each axis.\n\n      g.append('svg:g').attr('class', 'brush').each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).selectAll('rect').style('visibility', null).attr('x', -15).attr('width', 30);\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents\n    };\n  })(); // brush mode: 2D-strums\n  // bl.ocks.org/syntagmatic/5441022\n\n\n  (function () {\n    var strums = {},\n        strumRect;\n\n    function drawStrum(strum, activePoint) {\n      var svg = pc.selection.select('svg').select('g#strums'),\n          id = strum.dims.i,\n          points = [strum.p1, strum.p2],\n          line = svg.selectAll('line#strum-' + id).data([strum]),\n          circles = svg.selectAll('circle#strum-' + id).data(points),\n          drag = d3.behavior.drag();\n      line.enter().append('line').attr('id', 'strum-' + id).attr('class', 'strum');\n      line.attr('x1', function (d) {\n        return d.p1[0];\n      }).attr('y1', function (d) {\n        return d.p1[1];\n      }).attr('x2', function (d) {\n        return d.p2[0];\n      }).attr('y2', function (d) {\n        return d.p2[1];\n      }).attr('stroke', 'black').attr('stroke-width', 2);\n      drag.on('drag', function (d, i) {\n        var ev = d3.event;\n        i = i + 1;\n        strum['p' + i][0] = Math.min(Math.max(strum.minX + 1, ev.x), strum.maxX);\n        strum['p' + i][1] = Math.min(Math.max(strum.minY, ev.y), strum.maxY);\n        drawStrum(strum, i - 1);\n      }).on('dragend', onDragEnd());\n      circles.enter().append('circle').attr('id', 'strum-' + id).attr('class', 'strum');\n      circles.attr('cx', function (d) {\n        return d[0];\n      }).attr('cy', function (d) {\n        return d[1];\n      }).attr('r', 5).style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = {\n        i: -1,\n        left: undefined,\n        right: undefined\n      };\n\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the sturm was started.\n      // This will determine the freedom of movement, because a strum can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n            dims,\n            strum;\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n        dims = dimensionsForPoint(p), strum = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h()\n        };\n        strums[dims.i] = strum;\n        strums.active = dims.i; // Make sure that the point is within the bounds\n\n        strum.p1[0] = Math.min(Math.max(strum.minX, p[0]), strum.maxX);\n        strum.p2 = strum.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n            strum = strums[strums.active]; // Make sure that the point is within the bounds\n\n        strum.p2[0] = Math.min(Math.max(strum.minX + 1, ev.x - __.margin.left), strum.maxX);\n        strum.p2[1] = Math.min(Math.max(strum.minY, ev.y - __.margin.top), strum.maxY);\n        drawStrum(strum, 1);\n      };\n    }\n\n    function containmentTest(strum, width) {\n      var p1 = [strum.p1[0] - strum.minX, strum.p1[1] - strum.minX],\n          p2 = [strum.p2[0] - strum.minX, strum.p2[1] - strum.minX],\n          m1 = 1 - width / p1[0],\n          b1 = p1[1] * (1 - m1),\n          m2 = 1 - width / p2[0],\n          b2 = p2[1] * (1 - m2); // test if point falls between lines\n\n      return function (p) {\n        var x = p[0],\n            y = p[1],\n            y1 = m1 * x + b1,\n            y2 = m2 * x + b2;\n\n        if (y > Math.min(y1, y2) && y < Math.max(y1, y2)) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(strums),\n          brushed = __.data; // Get the ids of the currently active strums.\n\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var strum = strums[id],\n            test = containmentTest(strum, strums.width(id)),\n            d1 = strum.dims.left,\n            d2 = strum.dims.right,\n            y1 = yscale[d1],\n            y2 = yscale[d2],\n            point = [y1(d[d1]) - strum.minX, y2(d[d2]) - strum.minX];\n        return test(point);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function removeStrum() {\n      var strum = strums[strums.active],\n          svg = pc.selection.select('svg').select('g#strums');\n      delete strums[strums.active];\n      strums.active = undefined;\n      svg.selectAll('line#strum-' + strum.dims.i).remove();\n      svg.selectAll('circle#strum-' + strum.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n            strum = strums[strums.active]; // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n\n        if (strum && strum.p1[0] === strum.p2[0] && strum.p1[1] === strum.p2[1]) {\n          removeStrum(strums);\n        }\n\n        brushed = selected(strums);\n        strums.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(strums) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n        ids.forEach(function (d) {\n          strums.active = d;\n          removeStrum(strums);\n        });\n        onDragEnd(strums)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag(); // Map of current strums. Strums are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n\n      strums.active = undefined; // Returns the width of the PC segment where currently a strum is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n\n      strums.width = function (id) {\n        var strum = strums[id];\n\n        if (strum === undefined) {\n          return undefined;\n        }\n\n        return strum.maxX - strum.minX;\n      };\n\n      pc.on('axesreorder.strums', function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        }); // Checks if the first dimension is directly left of the second dimension.\n\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ? i + i < length && __.dimensions[i + 1] === second : false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some strums, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = strums[d].dims;\n            strums.active = d; // If the two dimensions of the current strum are not next to each other\n            // any more, than we'll need to remove the strum. Otherwise we keep it.\n\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(strums);\n            }\n          });\n          onDragEnd(strums)();\n        }\n      }); // Add a new svg group in which we draw the strums.\n\n      pc.selection.select('svg').append('g').attr('id', 'strums').attr('transform', 'translate(' + __.margin.left + ',' + __.margin.top + ')'); // Install the required brushReset function\n\n      pc.brushReset = brushReset(strums);\n      drag.on('dragstart', onDragStart(strums)).on('drag', onDrag(strums)).on('dragend', onDragEnd(strums)); // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n\n      strumRect = pc.selection.select('svg').insert('rect', 'g#strums').attr('id', 'strum-events').attr('x', __.margin.left).attr('y', __.margin.top).attr('width', w()).attr('height', h() + 2).style('opacity', 0).call(drag);\n    }\n\n    brush.modes['2D-strums'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#strums').remove();\n        pc.selection.select('svg').select('rect#strum-events').remove();\n        pc.on('axesreorder.strums', undefined);\n        delete pc.brushReset;\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return strums;\n      }\n    };\n  })(); // brush mode: 1D-Axes with multiple extents\n  // requires d3.svg.multibrush\n\n\n  (function () {\n    if (typeof d3.svg.multibrush !== 'function') {\n      return;\n    }\n\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    } // data within extents\n\n\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n          extents = actives.map(function (p) {\n        return brushes[p].extent();\n      }); // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n\n\n      if (actives.length === 0) return __.data; // test if within range\n\n      var within = {\n        date: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        number: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        string: function (d, p, dimension, b) {\n          return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n        }\n      };\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function brushExtents() {\n      var extents = {};\n\n      __.dimensions.forEach(function (d) {\n        var brush = brushes[d];\n\n        if (brush !== undefined && !brush.empty()) {\n          var extent = brush.extent();\n          extents[d] = extent;\n        }\n      });\n\n      return extents;\n    }\n\n    function brushFor(axis) {\n      var brush = d3.svg.multibrush();\n      brush.y(yscale[axis]).on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).on('brush', function () {\n        brushUpdated(selected());\n      }).on('brushend', function () {\n        // d3.svg.multibrush clears extents just before calling 'brushend'\n        // so we have to update here again.\n        // This fixes issue #103 for now, but should be changed in d3.svg.multibrush\n        // to avoid unnecessary computation.\n        brushUpdated(selected());\n        events.brushend.call(pc, __.brushed);\n      }).extentAdaption(function (selection) {\n        selection.style('visibility', null).attr('x', -15).attr('width', 30);\n      }).resizeAdaption(function (selection) {\n        selection.selectAll('rect').attr('x', -15).attr('width', 30);\n      });\n      brushes[axis] = brush;\n      return brush;\n    }\n\n    function brushReset(dimension) {\n      __.brushed = false;\n\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes(); // Add and store a brush for each axis.\n\n      g.append('svg:g').attr('class', 'brush').each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).selectAll('rect').style('visibility', null).attr('x', -15).attr('width', 30);\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes-multi'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents\n    };\n  })(); // brush mode: angular\n  // code based on 2D.strums.js\n\n\n  (function () {\n    var arcs = {},\n        strumRect;\n\n    function drawStrum(arc, activePoint) {\n      var svg = pc.selection.select('svg').select('g#arcs'),\n          id = arc.dims.i,\n          points = [arc.p2, arc.p3],\n          line = svg.selectAll('line#arc-' + id).data([{\n        p1: arc.p1,\n        p2: arc.p2\n      }, {\n        p1: arc.p1,\n        p2: arc.p3\n      }]),\n          circles = svg.selectAll('circle#arc-' + id).data(points),\n          drag = d3.behavior.drag(),\n          path = svg.selectAll('path#arc-' + id).data([arc]);\n      path.enter().append('path').attr('id', 'arc-' + id).attr('class', 'arc').style('fill', 'orange').style('opacity', 0.5);\n      path.attr('d', arc.arc).attr('transform', 'translate(' + arc.p1[0] + ',' + arc.p1[1] + ')');\n      line.enter().append('line').attr('id', 'arc-' + id).attr('class', 'arc');\n      line.attr('x1', function (d) {\n        return d.p1[0];\n      }).attr('y1', function (d) {\n        return d.p1[1];\n      }).attr('x2', function (d) {\n        return d.p2[0];\n      }).attr('y2', function (d) {\n        return d.p2[1];\n      }).attr('stroke', 'black').attr('stroke-width', 2);\n      drag.on('drag', function (d, i) {\n        var ev = d3.event,\n            angle = 0;\n        i = i + 2;\n        arc['p' + i][0] = Math.min(Math.max(arc.minX + 1, ev.x), arc.maxX);\n        arc['p' + i][1] = Math.min(Math.max(arc.minY, ev.y), arc.maxY);\n        angle = i === 3 ? arcs.startAngle(id) : arcs.endAngle(id);\n\n        if (arc.startAngle < Math.PI && arc.endAngle < Math.PI && angle < Math.PI || arc.startAngle >= Math.PI && arc.endAngle >= Math.PI && angle >= Math.PI) {\n          if (i === 2) {\n            arc.endAngle = angle;\n            arc.arc.endAngle(angle);\n          } else if (i === 3) {\n            arc.startAngle = angle;\n            arc.arc.startAngle(angle);\n          }\n        }\n\n        drawStrum(arc, i - 2);\n      }).on('dragend', onDragEnd());\n      circles.enter().append('circle').attr('id', 'arc-' + id).attr('class', 'arc');\n      circles.attr('cx', function (d) {\n        return d[0];\n      }).attr('cy', function (d) {\n        return d[1];\n      }).attr('r', 5).style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = {\n        i: -1,\n        left: undefined,\n        right: undefined\n      };\n\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the arc was started.\n      // This will determine the freedom of movement, because a arc can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n            dims,\n            arc;\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n        dims = dimensionsForPoint(p), arc = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h(),\n          startAngle: undefined,\n          endAngle: undefined,\n          arc: d3.svg.arc().innerRadius(0)\n        };\n        arcs[dims.i] = arc;\n        arcs.active = dims.i; // Make sure that the point is within the bounds\n\n        arc.p1[0] = Math.min(Math.max(arc.minX, p[0]), arc.maxX);\n        arc.p2 = arc.p1.slice();\n        arc.p3 = arc.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n            arc = arcs[arcs.active]; // Make sure that the point is within the bounds\n\n        arc.p2[0] = Math.min(Math.max(arc.minX + 1, ev.x - __.margin.left), arc.maxX);\n        arc.p2[1] = Math.min(Math.max(arc.minY, ev.y - __.margin.top), arc.maxY);\n        arc.p3 = arc.p2.slice();\n        drawStrum(arc, 1);\n      };\n    } // some helper functions\n\n\n    function hypothenuse(a, b) {\n      return Math.sqrt(a * a + b * b);\n    }\n\n    var rad = function () {\n      var c = Math.PI / 180;\n      return function (angle) {\n        return angle * c;\n      };\n    }();\n\n    var deg = function () {\n      var c = 180 / Math.PI;\n      return function (angle) {\n        return angle * c;\n      };\n    }(); // [0, 2*PI] -> [-PI/2, PI/2]\n\n\n    var signedAngle = function (angle) {\n      var ret = angle;\n\n      if (angle > Math.PI) {\n        ret = angle - 1.5 * Math.PI;\n        ret = angle - 1.5 * Math.PI;\n      } else {\n        ret = angle - 0.5 * Math.PI;\n        ret = angle - 0.5 * Math.PI;\n      }\n\n      return -ret;\n    };\n    /**\n     * angles are stored in radians from in [0, 2*PI], where 0 in 12 o'clock.\n     * However, one can only select lines from 0 to PI, so we compute the\n     * 'signed' angle, where 0 is the horizontal line (3 o'clock), and +/- PI/2\n     * are 12 and 6 o'clock respectively.\n     */\n\n\n    function containmentTest(arc) {\n      var startAngle = signedAngle(arc.startAngle);\n      var endAngle = signedAngle(arc.endAngle);\n\n      if (startAngle > endAngle) {\n        var tmp = startAngle;\n        startAngle = endAngle;\n        endAngle = tmp;\n      } // test if segment angle is contained in angle interval\n\n\n      return function (a) {\n        if (a >= startAngle && a <= endAngle) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(arcs),\n          brushed = __.data; // Get the ids of the currently active arcs.\n\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var arc = arcs[id],\n            test = containmentTest(arc),\n            d1 = arc.dims.left,\n            d2 = arc.dims.right,\n            y1 = yscale[d1],\n            y2 = yscale[d2],\n            a = arcs.width(id),\n            b = y1(d[d1]) - y2(d[d2]),\n            c = hypothenuse(a, b),\n            angle = Math.asin(b / c); // rad in [-PI/2, PI/2]\n\n        return test(angle);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function removeStrum() {\n      var arc = arcs[arcs.active],\n          svg = pc.selection.select('svg').select('g#arcs');\n      delete arcs[arcs.active];\n      arcs.active = undefined;\n      svg.selectAll('line#arc-' + arc.dims.i).remove();\n      svg.selectAll('circle#arc-' + arc.dims.i).remove();\n      svg.selectAll('path#arc-' + arc.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n            arc = arcs[arcs.active]; // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n\n        if (arc && arc.p1[0] === arc.p2[0] && arc.p1[1] === arc.p2[1]) {\n          removeStrum(arcs);\n        }\n\n        if (arc) {\n          var angle = arcs.startAngle(arcs.active);\n          arc.startAngle = angle;\n          arc.endAngle = angle;\n          arc.arc.outerRadius(arcs.length(arcs.active)).startAngle(angle).endAngle(angle);\n        }\n\n        brushed = selected(arcs);\n        arcs.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(arcs) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n        ids.forEach(function (d) {\n          arcs.active = d;\n          removeStrum(arcs);\n        });\n        onDragEnd(arcs)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag(); // Map of current arcs. arcs are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n\n      arcs.active = undefined; // Returns the width of the PC segment where currently a arc is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n\n      arcs.width = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        return arc.maxX - arc.minX;\n      }; // returns angles in [-PI/2, PI/2]\n\n\n      angle = function (p1, p2) {\n        var a = p1[0] - p2[0],\n            b = p1[1] - p2[1],\n            c = hypothenuse(a, b);\n        return Math.asin(b / c);\n      }; // returns angles in [0, 2 * PI]\n\n\n      arcs.endAngle = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var sAngle = angle(arc.p1, arc.p2),\n            uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p2[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.startAngle = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var sAngle = angle(arc.p1, arc.p3),\n            uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p3[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.length = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var a = arc.p1[0] - arc.p2[0],\n            b = arc.p1[1] - arc.p2[1],\n            c = hypothenuse(a, b);\n        return c;\n      };\n\n      pc.on('axesreorder.arcs', function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        }); // Checks if the first dimension is directly left of the second dimension.\n\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ? i + i < length && __.dimensions[i + 1] === second : false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some arcs, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = arcs[d].dims;\n            arcs.active = d; // If the two dimensions of the current arc are not next to each other\n            // any more, than we'll need to remove the arc. Otherwise we keep it.\n\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(arcs);\n            }\n          });\n          onDragEnd(arcs)();\n        }\n      }); // Add a new svg group in which we draw the arcs.\n\n      pc.selection.select('svg').append('g').attr('id', 'arcs').attr('transform', 'translate(' + __.margin.left + ',' + __.margin.top + ')'); // Install the required brushReset function\n\n      pc.brushReset = brushReset(arcs);\n      drag.on('dragstart', onDragStart(arcs)).on('drag', onDrag(arcs)).on('dragend', onDragEnd(arcs)); // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n\n      strumRect = pc.selection.select('svg').insert('rect', 'g#arcs').attr('id', 'arc-events').attr('x', __.margin.left).attr('y', __.margin.top).attr('width', w()).attr('height', h() + 2).style('opacity', 0).call(drag);\n    }\n\n    brush.modes['angular'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#arcs').remove();\n        pc.selection.select('svg').select('rect#arc-events').remove();\n        pc.on('axesreorder.arcs', undefined);\n        delete pc.brushReset;\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return arcs;\n      }\n    };\n  })();\n\n  pc.interactive = function () {\n    flags.interactive = true;\n    return this;\n  }; // expose a few objects\n\n\n  pc.xscale = xscale;\n  pc.yscale = yscale;\n  pc.ctx = ctx;\n  pc.canvas = canvas;\n\n  pc.g = function () {\n    return g;\n  }; // rescale for height, width and margins\n  // TODO currently assumes chart is brushable, and destroys old brushes\n\n\n  pc.resize = function () {\n    // selection size\n    pc.selection.select('svg').attr('width', __.width).attr('height', __.height);\n    pc.svg.attr('transform', 'translate(' + __.margin.left + ',' + __.margin.top + ')'); // FIXME: the current brush state should pass through\n\n    if (flags.brushable) pc.brushReset(); // scales\n\n    pc.autoscale(); // axes, destroys old brushes.\n\n    if (g) pc.createAxes();\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n    events.resize.call(this, {\n      width: __.width,\n      height: __.height,\n      margin: __.margin\n    });\n    return this;\n  }; // highlight an array of data\n\n\n  pc.highlight = function (data) {\n    if (arguments.length === 0) {\n      return __.highlighted;\n    }\n\n    __.highlighted = data;\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', true);\n    data.forEach(path_highlight);\n    events.highlight.call(this, data);\n    return this;\n  }; // clear highlighting\n\n\n  pc.unhighlight = function () {\n    __.highlighted = [];\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', false);\n    return this;\n  }; // calculate 2d intersection of line a->b with line c->d\n  // points are objects with x and y properties\n\n\n  pc.intersection = function (a, b, c, d) {\n    return {\n      x: ((a.x * b.y - a.y * b.x) * (c.x - d.x) - (a.x - b.x) * (c.x * d.y - c.y * d.x)) / ((a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)),\n      y: ((a.x * b.y - a.y * b.x) * (c.y - d.y) - (a.y - b.y) * (c.x * d.y - c.y * d.x)) / ((a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x))\n    };\n  };\n\n  function position(d) {\n    var v = dragging[d];\n    return v == null ? xscale(d) : v;\n  }\n\n  pc.version = '0.7.0'; // this descriptive text should live with other introspective methods\n\n  pc.toString = function () {\n    return 'Parallel Coordinates: ' + __.dimensions.length + ' dimensions (' + d3.keys(__.data[0]).length + ' total) , ' + __.data.length + ' rows';\n  };\n\n  return pc;\n}\n\nd3.renderQueue = function (func) {\n  var _queue = [],\n      // data to be rendered\n  _rate = 10,\n      // number of calls per frame\n  _clear = function () {},\n      // clearing function\n  _i = 0; // current iteration\n\n\n  var rq = function (data) {\n    if (data) rq.data(data);\n    rq.invalidate();\n\n    _clear();\n\n    rq.render();\n  };\n\n  rq.render = function () {\n    _i = 0;\n    var valid = true;\n\n    rq.invalidate = function () {\n      valid = false;\n    };\n\n    function doFrame() {\n      if (!valid) return true;\n      if (_i > _queue.length) return true; // Typical d3 behavior is to pass a data item *and* its index. As the\n      // render queue splits the original data set, we'll have to be slightly\n      // more carefull about passing the correct index with the data item.\n\n      var end = Math.min(_i + _rate, _queue.length);\n\n      for (var i = _i; i < end; i += 1) {\n        func(_queue[i], i);\n      }\n\n      _i += _rate;\n    }\n\n    d3.timer(doFrame);\n  };\n\n  rq.data = function (data) {\n    rq.invalidate();\n    _queue = data.slice(0);\n    return rq;\n  };\n\n  rq.rate = function (value) {\n    if (!arguments.length) return _rate;\n    _rate = value;\n    return rq;\n  };\n\n  rq.remaining = function () {\n    return _queue.length - _i;\n  }; // clear the canvas\n\n\n  rq.clear = function (func) {\n    if (!arguments.length) {\n      _clear();\n\n      return rq;\n    }\n\n    _clear = func;\n    return rq;\n  };\n\n  rq.invalidate = function () {};\n\n  return rq;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3VwZXJzZXQvLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmpzPzE3MmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogW0xJQ0VOU0UgVEJEXSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgX18gPSB7XG4gICAgZGF0YTogW10sXG4gICAgaGlnaGxpZ2h0ZWQ6IFtdLFxuICAgIGRpbWVuc2lvbnM6IFtdLFxuICAgIGRpbWVuc2lvblRpdGxlczoge30sXG4gICAgZGltZW5zaW9uVGl0bGVSb3RhdGlvbjogMCxcbiAgICB0eXBlczoge30sXG4gICAgYnJ1c2hlZDogZmFsc2UsXG4gICAgYnJ1c2hlZENvbG9yOiBudWxsLFxuICAgIGFscGhhT25CcnVzaGVkOiAwLjAsXG4gICAgbW9kZTogJ2RlZmF1bHQnLFxuICAgIHJhdGU6IDIwLFxuICAgIHdpZHRoOiA2MDAsXG4gICAgaGVpZ2h0OiAzMDAsXG4gICAgbWFyZ2luOiB7XG4gICAgICB0b3A6IDI0LFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDEyLFxuICAgICAgbGVmdDogMFxuICAgIH0sXG4gICAgbnVsbFZhbHVlU2VwYXJhdG9yOiAndW5kZWZpbmVkJyxcbiAgICAvLyBzZXQgdG8gXCJ0b3BcIiBvciBcImJvdHRvbVwiXG4gICAgbnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZzoge1xuICAgICAgdG9wOiA4LFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDgsXG4gICAgICBsZWZ0OiAwXG4gICAgfSxcbiAgICBjb2xvcjogJyMwNjknLFxuICAgIGNvbXBvc2l0ZTogJ3NvdXJjZS1vdmVyJyxcbiAgICBhbHBoYTogMC43LFxuICAgIGJ1bmRsaW5nU3RyZW5ndGg6IDAuNSxcbiAgICBidW5kbGVEaW1lbnNpb246IG51bGwsXG4gICAgc21vb3RobmVzczogMC4wLFxuICAgIHNob3dDb250cm9sUG9pbnRzOiBmYWxzZSxcbiAgICBoaWRlQXhpczogW11cbiAgfTtcbiAgZXh0ZW5kKF9fLCBjb25maWcpO1xuXG4gIHZhciBwYyA9IGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb24gPSBwYy5zZWxlY3Rpb24gPSBkMy5zZWxlY3Qoc2VsZWN0aW9uKTtcbiAgICBfXy53aWR0aCA9IHNlbGVjdGlvblswXVswXS5jbGllbnRXaWR0aDtcbiAgICBfXy5oZWlnaHQgPSBzZWxlY3Rpb25bMF1bMF0uY2xpZW50SGVpZ2h0OyAvLyBjYW52YXMgZGF0YSBsYXllcnNcblxuICAgIFsnbWFya3MnLCAnZm9yZWdyb3VuZCcsICdicnVzaGVkJywgJ2hpZ2hsaWdodCddLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICBjYW52YXNbbGF5ZXJdID0gc2VsZWN0aW9uLmFwcGVuZCgnY2FudmFzJykuYXR0cignY2xhc3MnLCBsYXllcilbMF1bMF07XG4gICAgICBjdHhbbGF5ZXJdID0gY2FudmFzW2xheWVyXS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH0pOyAvLyBzdmcgdGljayBhbmQgYnJ1c2ggbGF5ZXJzXG5cbiAgICBwYy5zdmcgPSBzZWxlY3Rpb24uYXBwZW5kKCdzdmcnKS5hdHRyKCd3aWR0aCcsIF9fLndpZHRoKS5hdHRyKCdoZWlnaHQnLCBfXy5oZWlnaHQpLmFwcGVuZCgnc3ZnOmcnKS5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBfXy5tYXJnaW4ubGVmdCArICcsJyArIF9fLm1hcmdpbi50b3AgKyAnKScpO1xuICAgIHJldHVybiBwYztcbiAgfTtcblxuICB2YXIgZXZlbnRzID0gZDMuZGlzcGF0Y2guYXBwbHkodGhpcywgWydyZW5kZXInLCAncmVzaXplJywgJ2hpZ2hsaWdodCcsICdicnVzaCcsICdicnVzaGVuZCcsICdheGVzcmVvcmRlciddLmNvbmNhdChkMy5rZXlzKF9fKSkpLFxuICAgICAgdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX18ud2lkdGggLSBfXy5tYXJnaW4ucmlnaHQgLSBfXy5tYXJnaW4ubGVmdDtcbiAgfSxcbiAgICAgIGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9fLmhlaWdodCAtIF9fLm1hcmdpbi50b3AgLSBfXy5tYXJnaW4uYm90dG9tO1xuICB9LFxuICAgICAgZmxhZ3MgPSB7XG4gICAgYnJ1c2hhYmxlOiBmYWxzZSxcbiAgICByZW9yZGVyYWJsZTogZmFsc2UsXG4gICAgYXhlczogZmFsc2UsXG4gICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgIGRlYnVnOiBmYWxzZVxuICB9LFxuICAgICAgeHNjYWxlID0gZDMuc2NhbGUub3JkaW5hbCgpLFxuICAgICAgeXNjYWxlID0ge30sXG4gICAgICBkcmFnZ2luZyA9IHt9LFxuICAgICAgbGluZSA9IGQzLnN2Zy5saW5lKCksXG4gICAgICBheGlzID0gZDMuc3ZnLmF4aXMoKS5vcmllbnQoJ2xlZnQnKS50aWNrcyg1KSxcbiAgICAgIGcsXG4gICAgICAvLyBncm91cHMgZm9yIGF4ZXMsIGJydXNoZXNcbiAgY3R4ID0ge30sXG4gICAgICBjYW52YXMgPSB7fSxcbiAgICAgIGNsdXN0ZXJDZW50cm9pZHMgPSBbXTsgLy8gc2lkZSBlZmZlY3RzIGZvciBzZXR0ZXJzXG5cblxuICB2YXIgc2lkZV9lZmZlY3RzID0gZDMuZGlzcGF0Y2guYXBwbHkodGhpcywgZDMua2V5cyhfXykpLm9uKCdjb21wb3NpdGUnLCBmdW5jdGlvbiAoZCkge1xuICAgIGN0eC5mb3JlZ3JvdW5kLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGQudmFsdWU7XG4gICAgY3R4LmJydXNoZWQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZC52YWx1ZTtcbiAgfSkub24oJ2FscGhhJywgZnVuY3Rpb24gKGQpIHtcbiAgICBjdHguZm9yZWdyb3VuZC5nbG9iYWxBbHBoYSA9IGQudmFsdWU7XG4gICAgY3R4LmJydXNoZWQuZ2xvYmFsQWxwaGEgPSBkLnZhbHVlO1xuICB9KS5vbignYnJ1c2hlZENvbG9yJywgZnVuY3Rpb24gKGQpIHtcbiAgICBjdHguYnJ1c2hlZC5zdHJva2VTdHlsZSA9IGQudmFsdWU7XG4gIH0pLm9uKCd3aWR0aCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgcGMucmVzaXplKCk7XG4gIH0pLm9uKCdoZWlnaHQnLCBmdW5jdGlvbiAoZCkge1xuICAgIHBjLnJlc2l6ZSgpO1xuICB9KS5vbignbWFyZ2luJywgZnVuY3Rpb24gKGQpIHtcbiAgICBwYy5yZXNpemUoKTtcbiAgfSkub24oJ3JhdGUnLCBmdW5jdGlvbiAoZCkge1xuICAgIGJydXNoZWRRdWV1ZS5yYXRlKGQudmFsdWUpO1xuICAgIGZvcmVncm91bmRRdWV1ZS5yYXRlKGQudmFsdWUpO1xuICB9KS5vbignZGltZW5zaW9ucycsIGZ1bmN0aW9uIChkKSB7XG4gICAgeHNjYWxlLmRvbWFpbihfXy5kaW1lbnNpb25zKTtcblxuICAgIGlmIChmbGFncy5pbnRlcmFjdGl2ZSkge1xuICAgICAgcGMucmVuZGVyKCkudXBkYXRlQXhlcygpO1xuICAgIH1cbiAgfSkub24oJ2J1bmRsZURpbWVuc2lvbicsIGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKCFfXy5kaW1lbnNpb25zLmxlbmd0aCkgcGMuZGV0ZWN0RGltZW5zaW9ucygpO1xuICAgIGlmICghKF9fLmRpbWVuc2lvbnNbMF0gaW4geXNjYWxlKSkgcGMuYXV0b3NjYWxlKCk7XG5cbiAgICBpZiAodHlwZW9mIGQudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoZC52YWx1ZSA8IF9fLmRpbWVuc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgIF9fLmJ1bmRsZURpbWVuc2lvbiA9IF9fLmRpbWVuc2lvbnNbZC52YWx1ZV07XG4gICAgICB9IGVsc2UgaWYgKGQudmFsdWUgPCBfXy5oaWRlQXhpcy5sZW5ndGgpIHtcbiAgICAgICAgX18uYnVuZGxlRGltZW5zaW9uID0gX18uaGlkZUF4aXNbZC52YWx1ZV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIF9fLmJ1bmRsZURpbWVuc2lvbiA9IGQudmFsdWU7XG4gICAgfVxuXG4gICAgX18uY2x1c3RlckNlbnRyb2lkcyA9IGNvbXB1dGVfY2x1c3Rlcl9jZW50cm9pZHMoX18uYnVuZGxlRGltZW5zaW9uKTtcbiAgfSkub24oJ2hpZGVBeGlzJywgZnVuY3Rpb24gKGQpIHtcbiAgICBpZiAoIV9fLmRpbWVuc2lvbnMubGVuZ3RoKSBwYy5kZXRlY3REaW1lbnNpb25zKCk7XG4gICAgcGMuZGltZW5zaW9ucyh3aXRob3V0KF9fLmRpbWVuc2lvbnMsIGQudmFsdWUpKTtcbiAgfSk7IC8vIGV4cG9zZSB0aGUgc3RhdGUgb2YgdGhlIGNoYXJ0XG5cbiAgcGMuc3RhdGUgPSBfXztcbiAgcGMuZmxhZ3MgPSBmbGFnczsgLy8gY3JlYXRlIGdldHRlci9zZXR0ZXJzXG5cbiAgZ2V0c2V0KHBjLCBfXywgZXZlbnRzKTsgLy8gZXhwb3NlIGV2ZW50c1xuXG4gIGQzLnJlYmluZChwYywgZXZlbnRzLCAnb24nKTsgLy8gZ2V0dGVyL3NldHRlciB3aXRoIGV2ZW50IGZpcmluZ1xuXG4gIGZ1bmN0aW9uIGdldHNldChvYmosIHN0YXRlLCBldmVudHMpIHtcbiAgICBkMy5rZXlzKHN0YXRlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIG9ialtrZXldID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2xkID0gc3RhdGVba2V5XTtcbiAgICAgICAgc3RhdGVba2V5XSA9IHg7XG4gICAgICAgIHNpZGVfZWZmZWN0c1trZXldLmNhbGwocGMsIHtcbiAgICAgICAgICB2YWx1ZTogeCxcbiAgICAgICAgICBwcmV2aW91czogb2xkXG4gICAgICAgIH0pO1xuICAgICAgICBldmVudHNba2V5XS5jYWxsKHBjLCB7XG4gICAgICAgICAgdmFsdWU6IHgsXG4gICAgICAgICAgcHJldmlvdXM6IG9sZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiB3aXRob3V0KGFyciwgaXRlbSkge1xuICAgIHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5pbmRleE9mKGVsZW0pID09PSAtMTtcbiAgICB9KTtcbiAgfVxuICAvKiogYWRqdXN0cyBhbiBheGlzJyBkZWZhdWx0IHJhbmdlIFtoKCkrMSwgMV0gaWYgYSBOdWxsVmFsdWVTZXBhcmF0b3IgaXMgc2V0ICovXG5cblxuICBmdW5jdGlvbiBnZXRSYW5nZSgpIHtcbiAgICBpZiAoX18ubnVsbFZhbHVlU2VwYXJhdG9yID09ICdib3R0b20nKSB7XG4gICAgICByZXR1cm4gW2goKSArIDEgLSBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLmJvdHRvbSAtIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcudG9wLCAxXTtcbiAgICB9IGVsc2UgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAndG9wJykge1xuICAgICAgcmV0dXJuIFtoKCkgKyAxLCAxICsgX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy5ib3R0b20gKyBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLnRvcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtoKCkgKyAxLCAxXTtcbiAgfVxuXG4gIHBjLmF1dG9zY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyB5c2NhbGVcbiAgICB2YXIgZGVmYXVsdFNjYWxlcyA9IHtcbiAgICAgIGRhdGU6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHZhciBleHRlbnQgPSBkMy5leHRlbnQoX18uZGF0YSwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZFtrXSA/IGRba10uZ2V0VGltZSgpIDogbnVsbDtcbiAgICAgICAgfSk7IC8vIHNwZWNpYWwgY2FzZSBpZiBzaW5nbGUgdmFsdWVcblxuICAgICAgICBpZiAoZXh0ZW50WzBdID09PSBleHRlbnRbMV0pIHtcbiAgICAgICAgICByZXR1cm4gZDMuc2NhbGUub3JkaW5hbCgpLmRvbWFpbihbZXh0ZW50WzBdXSkucmFuZ2VQb2ludHMoZ2V0UmFuZ2UoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZDMudGltZS5zY2FsZSgpLmRvbWFpbihleHRlbnQpLnJhbmdlKGdldFJhbmdlKCkpO1xuICAgICAgfSxcbiAgICAgIG51bWJlcjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgdmFyIGV4dGVudCA9IGQzLmV4dGVudChfXy5kYXRhLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiArZFtrXTtcbiAgICAgICAgfSk7IC8vIHNwZWNpYWwgY2FzZSBpZiBzaW5nbGUgdmFsdWVcblxuICAgICAgICBpZiAoZXh0ZW50WzBdID09PSBleHRlbnRbMV0pIHtcbiAgICAgICAgICByZXR1cm4gZDMuc2NhbGUub3JkaW5hbCgpLmRvbWFpbihbZXh0ZW50WzBdXSkucmFuZ2VQb2ludHMoZ2V0UmFuZ2UoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZDMuc2NhbGUubGluZWFyKCkuZG9tYWluKGV4dGVudCkucmFuZ2UoZ2V0UmFuZ2UoKSk7XG4gICAgICB9LFxuICAgICAgc3RyaW5nOiBmdW5jdGlvbiAoaykge1xuICAgICAgICB2YXIgY291bnRzID0ge30sXG4gICAgICAgICAgICBkb21haW4gPSBbXTsgLy8gTGV0J3MgZ2V0IHRoZSBjb3VudCBmb3IgZWFjaCB2YWx1ZSBzbyB0aGF0IHdlIGNhbiBzb3J0IHRoZSBkb21haW4gYmFzZWRcbiAgICAgICAgLy8gb24gdGhlIG51bWJlciBvZiBpdGVtcyBmb3IgZWFjaCB2YWx1ZS5cblxuICAgICAgICBfXy5kYXRhLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIGlmIChwW2tdID09PSB1bmRlZmluZWQgJiYgX18ubnVsbFZhbHVlU2VwYXJhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBudWxsIHZhbHVlcyB3aWxsIGJlIGRyYXduIGJleW9uZCB0aGUgaG9yaXpvbnRhbCBudWxsIHZhbHVlIHNlcGFyYXRvciFcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY291bnRzW3Bba11dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvdW50c1twW2tdXSA9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvdW50c1twW2tdXSA9IGNvdW50c1twW2tdXSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBkb21haW4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjb3VudHMpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gY291bnRzW2FdIC0gY291bnRzW2JdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5kb21haW4oZG9tYWluKS5yYW5nZVBvaW50cyhnZXRSYW5nZSgpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX18uZGltZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICB5c2NhbGVba10gPSBkZWZhdWx0U2NhbGVzW19fLnR5cGVzW2tdXShrKTtcbiAgICB9KTtcblxuICAgIF9fLmhpZGVBeGlzLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIHlzY2FsZVtrXSA9IGRlZmF1bHRTY2FsZXNbX18udHlwZXNba11dKGspO1xuICAgIH0pOyAvLyB4c2NhbGVcblxuXG4gICAgeHNjYWxlLnJhbmdlUG9pbnRzKFswLCB3KCldLCAxKTsgLy8gY2FudmFzIHNpemVzXG5cbiAgICBwYy5zZWxlY3Rpb24uc2VsZWN0QWxsKCdjYW52YXMnKS5zdHlsZSgnbWFyZ2luLXRvcCcsIF9fLm1hcmdpbi50b3AgKyAncHgnKS5zdHlsZSgnbWFyZ2luLWxlZnQnLCBfXy5tYXJnaW4ubGVmdCArICdweCcpLmF0dHIoJ3dpZHRoJywgdygpICsgMikuYXR0cignaGVpZ2h0JywgaCgpICsgMik7IC8vIGRlZmF1bHQgc3R5bGVzLCBuZWVkcyB0byBiZSBzZXQgd2hlbiBjYW52YXMgd2lkdGggY2hhbmdlc1xuXG4gICAgY3R4LmZvcmVncm91bmQuc3Ryb2tlU3R5bGUgPSBfXy5jb2xvcjtcbiAgICBjdHguZm9yZWdyb3VuZC5saW5lV2lkdGggPSAxLjQ7XG4gICAgY3R4LmZvcmVncm91bmQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gX18uY29tcG9zaXRlO1xuICAgIGN0eC5mb3JlZ3JvdW5kLmdsb2JhbEFscGhhID0gX18uYWxwaGE7XG4gICAgY3R4LmJydXNoZWQuc3Ryb2tlU3R5bGUgPSBfXy5icnVzaGVkQ29sb3I7XG4gICAgY3R4LmJydXNoZWQubGluZVdpZHRoID0gMS40O1xuICAgIGN0eC5icnVzaGVkLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IF9fLmNvbXBvc2l0ZTtcbiAgICBjdHguYnJ1c2hlZC5nbG9iYWxBbHBoYSA9IF9fLmFscGhhO1xuICAgIGN0eC5oaWdobGlnaHQubGluZVdpZHRoID0gMztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBwYy5zY2FsZSA9IGZ1bmN0aW9uIChkLCBkb21haW4pIHtcbiAgICB5c2NhbGVbZF0uZG9tYWluKGRvbWFpbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcGMuZmxpcCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgLy95c2NhbGVbZF0uZG9tYWluKCkucmV2ZXJzZSgpOyAgICAgICAgIC8vIGRvZXMgbm90IHdvcmtcbiAgICB5c2NhbGVbZF0uZG9tYWluKHlzY2FsZVtkXS5kb21haW4oKS5yZXZlcnNlKCkpOyAvLyB3b3Jrc1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcGMuY29tbW9uU2NhbGUgPSBmdW5jdGlvbiAoZ2xvYmFsLCB0eXBlKSB7XG4gICAgdmFyIHQgPSB0eXBlIHx8ICdudW1iZXInO1xuXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwgPSB0cnVlO1xuICAgIH0gLy8gc2NhbGVzIG9mIHRoZSBzYW1lIHR5cGVcblxuXG4gICAgdmFyIHNjYWxlcyA9IF9fLmRpbWVuc2lvbnMuY29uY2F0KF9fLmhpZGVBeGlzKS5maWx0ZXIoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBfXy50eXBlc1twXSA9PSB0O1xuICAgIH0pO1xuXG4gICAgaWYgKGdsb2JhbCkge1xuICAgICAgdmFyIGV4dGVudCA9IGQzLmV4dGVudChzY2FsZXMubWFwKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICAgIHJldHVybiB5c2NhbGVbcF0uZG9tYWluKCk7XG4gICAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgfSkpO1xuICAgICAgc2NhbGVzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgeXNjYWxlW2RdLmRvbWFpbihleHRlbnQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHlzY2FsZVtrXS5kb21haW4oZDMuZXh0ZW50KF9fLmRhdGEsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuICtkW2tdO1xuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9IC8vIHVwZGF0ZSBjZW50cm9pZHNcblxuXG4gICAgaWYgKF9fLmJ1bmRsZURpbWVuc2lvbiAhPT0gbnVsbCkge1xuICAgICAgcGMuYnVuZGxlRGltZW5zaW9uKF9fLmJ1bmRsZURpbWVuc2lvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcGMuZGV0ZWN0RGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwYy50eXBlcyhwYy5kZXRlY3REaW1lbnNpb25UeXBlcyhfXy5kYXRhKSk7XG4gICAgcGMuZGltZW5zaW9ucyhkMy5rZXlzKHBjLnR5cGVzKCkpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTsgLy8gYSBiZXR0ZXIgXCJ0eXBlb2ZcIiBmcm9tIHRoaXMgcG9zdDogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MzkwNDI2L2JldHRlci13YXktdG8tZ2V0LXR5cGUtb2YtYS1qYXZhc2NyaXB0LXZhcmlhYmxlXG5cblxuICBwYy50b1R5cGUgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB7fS50b1N0cmluZy5jYWxsKHYpLm1hdGNoKC9cXHMoW2EtekEtWl0rKS8pWzFdLnRvTG93ZXJDYXNlKCk7XG4gIH07IC8vIHRyeSB0byBjb2VyY2UgdG8gbnVtYmVyIGJlZm9yZSByZXR1cm5pbmcgdHlwZVxuXG5cbiAgcGMudG9UeXBlQ29lcmNlTnVtYmVycyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHBhcnNlRmxvYXQodikgPT0gdiAmJiB2ICE9IG51bGwpIHtcbiAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICB9XG5cbiAgICByZXR1cm4gcGMudG9UeXBlKHYpO1xuICB9OyAvLyBhdHRlbXB0IHRvIGRldGVybWluZSB0eXBlcyBvZiBlYWNoIGRpbWVuc2lvbiBiYXNlZCBvbiBmaXJzdCByb3cgb2YgZGF0YVxuXG5cbiAgcGMuZGV0ZWN0RGltZW5zaW9uVHlwZXMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciB0eXBlcyA9IHt9O1xuICAgIGQzLmtleXMoZGF0YVswXSkuZm9yRWFjaChmdW5jdGlvbiAoY29sKSB7XG4gICAgICB0eXBlc1tjb2xdID0gcGMudG9UeXBlQ29lcmNlTnVtYmVycyhkYXRhWzBdW2NvbF0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0eXBlcztcbiAgfTtcblxuICBwYy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gdHJ5IHRvIGF1dG9kZXRlY3QgZGltZW5zaW9ucyBhbmQgY3JlYXRlIHNjYWxlc1xuICAgIGlmICghX18uZGltZW5zaW9ucy5sZW5ndGgpIHBjLmRldGVjdERpbWVuc2lvbnMoKTtcbiAgICBpZiAoIShfXy5kaW1lbnNpb25zWzBdIGluIHlzY2FsZSkpIHBjLmF1dG9zY2FsZSgpO1xuXG4gICAgcGMucmVuZGVyW19fLm1vZGVdKCk7XG5cbiAgICBldmVudHMucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcGMucmVuZGVyQnJ1c2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIV9fLmRpbWVuc2lvbnMubGVuZ3RoKSBwYy5kZXRlY3REaW1lbnNpb25zKCk7XG4gICAgaWYgKCEoX18uZGltZW5zaW9uc1swXSBpbiB5c2NhbGUpKSBwYy5hdXRvc2NhbGUoKTtcblxuICAgIHBjLnJlbmRlckJydXNoZWRbX18ubW9kZV0oKTtcblxuICAgIGV2ZW50cy5yZW5kZXIuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBmdW5jdGlvbiBpc0JydXNoZWQoKSB7XG4gICAgaWYgKF9fLmJydXNoZWQgJiYgX18uYnJ1c2hlZC5sZW5ndGggIT09IF9fLmRhdGEubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgb2JqZWN0ID0gYnJ1c2guY3VycmVudE1vZGUoKS5icnVzaFN0YXRlKCk7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcGMucmVuZGVyLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGMuY2xlYXIoJ2ZvcmVncm91bmQnKTtcbiAgICBwYy5jbGVhcignaGlnaGxpZ2h0Jyk7XG4gICAgcGMucmVuZGVyQnJ1c2hlZC5kZWZhdWx0KCk7XG5cbiAgICBfXy5kYXRhLmZvckVhY2gocGF0aF9mb3JlZ3JvdW5kKTtcbiAgfTtcblxuICB2YXIgZm9yZWdyb3VuZFF1ZXVlID0gZDMucmVuZGVyUXVldWUocGF0aF9mb3JlZ3JvdW5kKS5yYXRlKDUwKS5jbGVhcihmdW5jdGlvbiAoKSB7XG4gICAgcGMuY2xlYXIoJ2ZvcmVncm91bmQnKTtcbiAgICBwYy5jbGVhcignaGlnaGxpZ2h0Jyk7XG4gIH0pO1xuXG4gIHBjLnJlbmRlci5xdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBwYy5yZW5kZXJCcnVzaGVkLnF1ZXVlKCk7XG4gICAgZm9yZWdyb3VuZFF1ZXVlKF9fLmRhdGEpO1xuICB9O1xuXG4gIHBjLnJlbmRlckJydXNoZWQuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwYy5jbGVhcignYnJ1c2hlZCcpO1xuXG4gICAgaWYgKGlzQnJ1c2hlZCgpKSB7XG4gICAgICBfXy5icnVzaGVkLmZvckVhY2gocGF0aF9icnVzaGVkKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGJydXNoZWRRdWV1ZSA9IGQzLnJlbmRlclF1ZXVlKHBhdGhfYnJ1c2hlZCkucmF0ZSg1MCkuY2xlYXIoZnVuY3Rpb24gKCkge1xuICAgIHBjLmNsZWFyKCdicnVzaGVkJyk7XG4gIH0pO1xuXG4gIHBjLnJlbmRlckJydXNoZWQucXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlzQnJ1c2hlZCgpKSB7XG4gICAgICBicnVzaGVkUXVldWUoX18uYnJ1c2hlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJydXNoZWRRdWV1ZShbXSk7IC8vIFRoaXMgaXMgbmVlZGVkIHRvIGNsZWFyIHRoZSBjdXJyZW50bHkgYnJ1c2hlZCBpdGVtc1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjb21wdXRlX2NsdXN0ZXJfY2VudHJvaWRzKGQpIHtcbiAgICB2YXIgY2x1c3RlckNlbnRyb2lkcyA9IGQzLm1hcCgpO1xuICAgIHZhciBjbHVzdGVyQ291bnRzID0gZDMubWFwKCk7IC8vIGRldGVybWluZSBjbHVzdGVyQ291bnRzXG5cbiAgICBfXy5kYXRhLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgdmFyIHNjYWxlZCA9IHlzY2FsZVtkXShyb3dbZF0pO1xuXG4gICAgICBpZiAoIWNsdXN0ZXJDb3VudHMuaGFzKHNjYWxlZCkpIHtcbiAgICAgICAgY2x1c3RlckNvdW50cy5zZXQoc2NhbGVkLCAwKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvdW50ID0gY2x1c3RlckNvdW50cy5nZXQoc2NhbGVkKTtcbiAgICAgIGNsdXN0ZXJDb3VudHMuc2V0KHNjYWxlZCwgY291bnQgKyAxKTtcbiAgICB9KTtcblxuICAgIF9fLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICBfXy5kaW1lbnNpb25zLm1hcChmdW5jdGlvbiAocCwgaSkge1xuICAgICAgICB2YXIgc2NhbGVkID0geXNjYWxlW2RdKHJvd1tkXSk7XG5cbiAgICAgICAgaWYgKCFjbHVzdGVyQ2VudHJvaWRzLmhhcyhzY2FsZWQpKSB7XG4gICAgICAgICAgdmFyIG1hcCA9IGQzLm1hcCgpO1xuICAgICAgICAgIGNsdXN0ZXJDZW50cm9pZHMuc2V0KHNjYWxlZCwgbWFwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2x1c3RlckNlbnRyb2lkcy5nZXQoc2NhbGVkKS5oYXMocCkpIHtcbiAgICAgICAgICBjbHVzdGVyQ2VudHJvaWRzLmdldChzY2FsZWQpLnNldChwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSA9IGNsdXN0ZXJDZW50cm9pZHMuZ2V0KHNjYWxlZCkuZ2V0KHApO1xuICAgICAgICB2YWx1ZSArPSB5c2NhbGVbcF0ocm93W3BdKSAvIGNsdXN0ZXJDb3VudHMuZ2V0KHNjYWxlZCk7XG4gICAgICAgIGNsdXN0ZXJDZW50cm9pZHMuZ2V0KHNjYWxlZCkuc2V0KHAsIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNsdXN0ZXJDZW50cm9pZHM7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlX2NlbnRyb2lkcyhyb3cpIHtcbiAgICB2YXIgY2VudHJvaWRzID0gW107XG4gICAgdmFyIHAgPSBfXy5kaW1lbnNpb25zO1xuICAgIHZhciBjb2xzID0gcC5sZW5ndGg7XG4gICAgdmFyIGEgPSAwLjU7IC8vIGNlbnRlciBiZXR3ZWVuIGF4ZXNcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sczsgKytpKSB7XG4gICAgICAvLyBjZW50cm9pZHMgb24gJ3JlYWwnIGF4ZXNcbiAgICAgIHZhciB4ID0gcG9zaXRpb24ocFtpXSk7XG4gICAgICB2YXIgeSA9IHlzY2FsZVtwW2ldXShyb3dbcFtpXV0pO1xuICAgICAgY2VudHJvaWRzLnB1c2goJFYoW3gsIHldKSk7IC8vIGNlbnRyb2lkcyBvbiAndmlydHVhbCcgYXhlc1xuXG4gICAgICBpZiAoaSA8IGNvbHMgLSAxKSB7XG4gICAgICAgIHZhciBjeCA9IHggKyBhICogKHBvc2l0aW9uKHBbaSArIDFdKSAtIHgpO1xuICAgICAgICB2YXIgY3kgPSB5ICsgYSAqICh5c2NhbGVbcFtpICsgMV1dKHJvd1twW2kgKyAxXV0pIC0geSk7XG5cbiAgICAgICAgaWYgKF9fLmJ1bmRsZURpbWVuc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBsZWZ0Q2VudHJvaWQgPSBfXy5jbHVzdGVyQ2VudHJvaWRzLmdldCh5c2NhbGVbX18uYnVuZGxlRGltZW5zaW9uXShyb3dbX18uYnVuZGxlRGltZW5zaW9uXSkpLmdldChwW2ldKTtcblxuICAgICAgICAgIHZhciByaWdodENlbnRyb2lkID0gX18uY2x1c3RlckNlbnRyb2lkcy5nZXQoeXNjYWxlW19fLmJ1bmRsZURpbWVuc2lvbl0ocm93W19fLmJ1bmRsZURpbWVuc2lvbl0pKS5nZXQocFtpICsgMV0pO1xuXG4gICAgICAgICAgdmFyIGNlbnRyb2lkID0gMC41ICogKGxlZnRDZW50cm9pZCArIHJpZ2h0Q2VudHJvaWQpO1xuICAgICAgICAgIGN5ID0gY2VudHJvaWQgKyAoMSAtIF9fLmJ1bmRsaW5nU3RyZW5ndGgpICogKGN5IC0gY2VudHJvaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2VudHJvaWRzLnB1c2goJFYoW2N4LCBjeV0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2VudHJvaWRzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZV9jb250cm9sX3BvaW50cyhjZW50cm9pZHMpIHtcbiAgICB2YXIgY29scyA9IGNlbnRyb2lkcy5sZW5ndGg7XG4gICAgdmFyIGEgPSBfXy5zbW9vdGhuZXNzO1xuICAgIHZhciBjcHMgPSBbXTtcbiAgICBjcHMucHVzaChjZW50cm9pZHNbMF0pO1xuICAgIGNwcy5wdXNoKCRWKFtjZW50cm9pZHNbMF0uZSgxKSArIGEgKiAyICogKGNlbnRyb2lkc1sxXS5lKDEpIC0gY2VudHJvaWRzWzBdLmUoMSkpLCBjZW50cm9pZHNbMF0uZSgyKV0pKTtcblxuICAgIGZvciAodmFyIGNvbCA9IDE7IGNvbCA8IGNvbHMgLSAxOyArK2NvbCkge1xuICAgICAgdmFyIG1pZCA9IGNlbnRyb2lkc1tjb2xdO1xuICAgICAgdmFyIGxlZnQgPSBjZW50cm9pZHNbY29sIC0gMV07XG4gICAgICB2YXIgcmlnaHQgPSBjZW50cm9pZHNbY29sICsgMV07XG4gICAgICB2YXIgZGlmZiA9IGxlZnQuc3VidHJhY3QocmlnaHQpO1xuICAgICAgY3BzLnB1c2gobWlkLmFkZChkaWZmLngoYSkpKTtcbiAgICAgIGNwcy5wdXNoKG1pZCk7XG4gICAgICBjcHMucHVzaChtaWQuc3VidHJhY3QoZGlmZi54KGEpKSk7XG4gICAgfVxuXG4gICAgY3BzLnB1c2goJFYoW2NlbnRyb2lkc1tjb2xzIC0gMV0uZSgxKSArIGEgKiAyICogKGNlbnRyb2lkc1tjb2xzIC0gMl0uZSgxKSAtIGNlbnRyb2lkc1tjb2xzIC0gMV0uZSgxKSksIGNlbnRyb2lkc1tjb2xzIC0gMV0uZSgyKV0pKTtcbiAgICBjcHMucHVzaChjZW50cm9pZHNbY29scyAtIDFdKTtcbiAgICByZXR1cm4gY3BzO1xuICB9XG5cbiAgcGMuc2hhZG93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmbGFncy5zaGFkb3dzID0gdHJ1ZTtcbiAgICBwYy5hbHBoYU9uQnJ1c2hlZCgwLjEpO1xuICAgIHBjLnJlbmRlcigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9OyAvLyBkcmF3IGRvdHMgd2l0aCByYWRpdXMgciBvbiB0aGUgYXhpcyBsaW5lIHdoZXJlIGRhdGEgaW50ZXJzZWN0c1xuXG5cbiAgcGMuYXhpc0RvdHMgPSBmdW5jdGlvbiAocikge1xuICAgIHZhciByID0gciB8fCAwLjE7XG4gICAgdmFyIGN0eCA9IHBjLmN0eC5tYXJrcztcbiAgICB2YXIgc3RhcnRBbmdsZSA9IDA7XG4gICAgdmFyIGVuZEFuZ2xlID0gMiAqIE1hdGguUEk7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gZDMubWluKFsxIC8gTWF0aC5wb3coX18uZGF0YS5sZW5ndGgsIDEgLyAyKSwgMV0pO1xuXG4gICAgX18uZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICBfXy5kaW1lbnNpb25zLm1hcChmdW5jdGlvbiAocCwgaSkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5hcmMocG9zaXRpb24ocCksIHlzY2FsZVtwXShkW3BdKSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9OyAvLyBkcmF3IHNpbmdsZSBjdWJpYyBiZXppZXIgY3VydmVcblxuXG4gIGZ1bmN0aW9uIHNpbmdsZV9jdXJ2ZShkLCBjdHgpIHtcbiAgICB2YXIgY2VudHJvaWRzID0gY29tcHV0ZV9jZW50cm9pZHMoZCk7XG4gICAgdmFyIGNwcyA9IGNvbXB1dGVfY29udHJvbF9wb2ludHMoY2VudHJvaWRzKTtcbiAgICBjdHgubW92ZVRvKGNwc1swXS5lKDEpLCBjcHNbMF0uZSgyKSk7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNwcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgaWYgKF9fLnNob3dDb250cm9sUG9pbnRzKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaiArPSAxKSB7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KGNwc1tpICsgal0uZSgxKSwgY3BzW2kgKyBqXS5lKDIpLCAyLCAyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdHguYmV6aWVyQ3VydmVUbyhjcHNbaV0uZSgxKSwgY3BzW2ldLmUoMiksIGNwc1tpICsgMV0uZSgxKSwgY3BzW2kgKyAxXS5lKDIpLCBjcHNbaSArIDJdLmUoMSksIGNwc1tpICsgMl0uZSgyKSk7XG4gICAgfVxuICB9IC8vIGRyYXcgc2luZ2xlIHBvbHlsaW5lXG5cblxuICBmdW5jdGlvbiBjb2xvcl9wYXRoKGQsIGN0eCkge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgIGlmIChfXy5idW5kbGVEaW1lbnNpb24gIT09IG51bGwgJiYgX18uYnVuZGxpbmdTdHJlbmd0aCA+IDAgfHwgX18uc21vb3RobmVzcyA+IDApIHtcbiAgICAgIHNpbmdsZV9jdXJ2ZShkLCBjdHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaW5nbGVfcGF0aChkLCBjdHgpO1xuICAgIH1cblxuICAgIGN0eC5zdHJva2UoKTtcbiAgfSAvLyBkcmF3IG1hbnkgcG9seWxpbmVzIG9mIHRoZSBzYW1lIGNvbG9yXG5cblxuICBmdW5jdGlvbiBwYXRocyhkYXRhLCBjdHgpIHtcbiAgICBjdHguY2xlYXJSZWN0KC0xLCAtMSwgdygpICsgMiwgaCgpICsgMik7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgaWYgKF9fLmJ1bmRsZURpbWVuc2lvbiAhPT0gbnVsbCAmJiBfXy5idW5kbGluZ1N0cmVuZ3RoID4gMCB8fCBfXy5zbW9vdGhuZXNzID4gMCkge1xuICAgICAgICBzaW5nbGVfY3VydmUoZCwgY3R4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpbmdsZV9wYXRoKGQsIGN0eCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9IC8vIHJldHVybnMgdGhlIHktcG9zaXRpb24ganVzdCBiZXlvbmQgdGhlIHNlcGFyYXRpbmcgbnVsbCB2YWx1ZSBsaW5lXG5cblxuICBmdW5jdGlvbiBnZXROdWxsUG9zaXRpb24oKSB7XG4gICAgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAnYm90dG9tJykge1xuICAgICAgcmV0dXJuIGgoKSArIDE7XG4gICAgfSBlbHNlIGlmIChfXy5udWxsVmFsdWVTZXBhcmF0b3IgPT0gJ3RvcCcpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkEgdmFsdWUgaXMgTlVMTCwgYnV0IG51bGxWYWx1ZVNlcGFyYXRvciBpcyBub3Qgc2V0OyBzZXQgaXQgdG8gJ2JvdHRvbScgb3IgJ3RvcCcuXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBoKCkgKyAxO1xuICB9XG5cbiAgZnVuY3Rpb24gc2luZ2xlX3BhdGgoZCwgY3R4KSB7XG4gICAgX18uZGltZW5zaW9ucy5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgY3R4Lm1vdmVUbyhwb3NpdGlvbihwKSwgdHlwZW9mIGRbcF0gPT0gJ3VuZGVmaW5lZCcgPyBnZXROdWxsUG9zaXRpb24oKSA6IHlzY2FsZVtwXShkW3BdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHgubGluZVRvKHBvc2l0aW9uKHApLCB0eXBlb2YgZFtwXSA9PSAndW5kZWZpbmVkJyA/IGdldE51bGxQb3NpdGlvbigpIDogeXNjYWxlW3BdKGRbcF0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGhfYnJ1c2hlZChkLCBpKSB7XG4gICAgaWYgKF9fLmJydXNoZWRDb2xvciAhPT0gbnVsbCkge1xuICAgICAgY3R4LmJydXNoZWQuc3Ryb2tlU3R5bGUgPSBkMy5mdW5jdG9yKF9fLmJydXNoZWRDb2xvcikoZCwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5icnVzaGVkLnN0cm9rZVN0eWxlID0gZDMuZnVuY3RvcihfXy5jb2xvcikoZCwgaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbG9yX3BhdGgoZCwgY3R4LmJydXNoZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGF0aF9mb3JlZ3JvdW5kKGQsIGkpIHtcbiAgICBjdHguZm9yZWdyb3VuZC5zdHJva2VTdHlsZSA9IGQzLmZ1bmN0b3IoX18uY29sb3IpKGQsIGkpO1xuICAgIHJldHVybiBjb2xvcl9wYXRoKGQsIGN0eC5mb3JlZ3JvdW5kKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGhfaGlnaGxpZ2h0KGQsIGkpIHtcbiAgICBjdHguaGlnaGxpZ2h0LnN0cm9rZVN0eWxlID0gZDMuZnVuY3RvcihfXy5jb2xvcikoZCwgaSk7XG4gICAgcmV0dXJuIGNvbG9yX3BhdGgoZCwgY3R4LmhpZ2hsaWdodCk7XG4gIH1cblxuICBwYy5jbGVhciA9IGZ1bmN0aW9uIChsYXllcikge1xuICAgIGN0eFtsYXllcl0uY2xlYXJSZWN0KDAsIDAsIHcoKSArIDIsIGgoKSArIDIpOyAvLyBUaGlzIHdpbGwgbWFrZSBzdXJlIHRoYXQgdGhlIGZvcmVncm91bmQgaXRlbXMgYXJlIHRyYW5zcGFyZW50XG4gICAgLy8gd2l0aG91dCB0aGUgbmVlZCBmb3IgY2hhbmdpbmcgdGhlIG9wYWNpdHkgc3R5bGUgb2YgdGhlIGZvcmVncm91bmQgY2FudmFzXG4gICAgLy8gYXMgdGhpcyB3b3VsZCBzdG9wIHRoZSBjc3Mgc3R5bGluZyBmcm9tIHdvcmtpbmdcblxuICAgIGlmIChsYXllciA9PT0gJ2JydXNoZWQnICYmIGlzQnJ1c2hlZCgpKSB7XG4gICAgICBjdHguYnJ1c2hlZC5maWxsU3R5bGUgPSBwYy5zZWxlY3Rpb24uc3R5bGUoJ2JhY2tncm91bmQtY29sb3InKTtcbiAgICAgIGN0eC5icnVzaGVkLmdsb2JhbEFscGhhID0gMSAtIF9fLmFscGhhT25CcnVzaGVkO1xuICAgICAgY3R4LmJydXNoZWQuZmlsbFJlY3QoMCwgMCwgdygpICsgMiwgaCgpICsgMik7XG4gICAgICBjdHguYnJ1c2hlZC5nbG9iYWxBbHBoYSA9IF9fLmFscGhhO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGQzLnJlYmluZChwYywgYXhpcywgJ3RpY2tzJywgJ29yaWVudCcsICd0aWNrVmFsdWVzJywgJ3RpY2tTdWJkaXZpZGUnLCAndGlja1NpemUnLCAndGlja1BhZGRpbmcnLCAndGlja0Zvcm1hdCcpO1xuXG4gIGZ1bmN0aW9uIGZsaXBBeGlzQW5kVXBkYXRlUENQKGRpbWVuc2lvbikge1xuICAgIHZhciBnID0gcGMuc3ZnLnNlbGVjdEFsbCgnLmRpbWVuc2lvbicpO1xuICAgIHBjLmZsaXAoZGltZW5zaW9uKTtcbiAgICBkMy5zZWxlY3QodGhpcy5wYXJlbnRFbGVtZW50KS50cmFuc2l0aW9uKCkuZHVyYXRpb24oMTEwMCkuY2FsbChheGlzLnNjYWxlKHlzY2FsZVtkaW1lbnNpb25dKSk7XG4gICAgcGMucmVuZGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiByb3RhdGVMYWJlbHMoKSB7XG4gICAgdmFyIGRlbHRhID0gZDMuZXZlbnQuZGVsdGFZO1xuICAgIGRlbHRhID0gZGVsdGEgPCAwID8gLTUgOiBkZWx0YTtcbiAgICBkZWx0YSA9IGRlbHRhID4gMCA/IDUgOiBkZWx0YTtcbiAgICBfXy5kaW1lbnNpb25UaXRsZVJvdGF0aW9uICs9IGRlbHRhO1xuICAgIHBjLnN2Zy5zZWxlY3RBbGwoJ3RleHQubGFiZWwnKS5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsLTUpIHJvdGF0ZSgnICsgX18uZGltZW5zaW9uVGl0bGVSb3RhdGlvbiArICcpJyk7XG4gICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpbWVuc2lvbkxhYmVscyhkKSB7XG4gICAgcmV0dXJuIGQgaW4gX18uZGltZW5zaW9uVGl0bGVzID8gX18uZGltZW5zaW9uVGl0bGVzW2RdIDogZDsgLy8gZGltZW5zaW9uIGRpc3BsYXkgbmFtZXNcbiAgfVxuXG4gIHBjLmNyZWF0ZUF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGcpIHBjLnJlbW92ZUF4ZXMoKTsgLy8gQWRkIGEgZ3JvdXAgZWxlbWVudCBmb3IgZWFjaCBkaW1lbnNpb24uXG5cbiAgICBnID0gcGMuc3ZnLnNlbGVjdEFsbCgnLmRpbWVuc2lvbicpLmRhdGEoX18uZGltZW5zaW9ucywgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkO1xuICAgIH0pLmVudGVyKCkuYXBwZW5kKCdzdmc6ZycpLmF0dHIoJ2NsYXNzJywgJ2RpbWVuc2lvbicpLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeHNjYWxlKGQpICsgJyknO1xuICAgIH0pOyAvLyBBZGQgYW4gYXhpcyBhbmQgdGl0bGUuXG5cbiAgICBnLmFwcGVuZCgnc3ZnOmcnKS5hdHRyKCdjbGFzcycsICdheGlzJykuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLDApJykuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYXhpcy5zY2FsZSh5c2NhbGVbZF0pKTtcbiAgICB9KS5hcHBlbmQoJ3N2Zzp0ZXh0JykuYXR0cih7XG4gICAgICAndGV4dC1hbmNob3InOiAnbWlkZGxlJyxcbiAgICAgIHk6IDAsXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMCwtNSkgcm90YXRlKCcgKyBfXy5kaW1lbnNpb25UaXRsZVJvdGF0aW9uICsgJyknLFxuICAgICAgeDogMCxcbiAgICAgIGNsYXNzOiAnbGFiZWwnXG4gICAgfSkudGV4dChkaW1lbnNpb25MYWJlbHMpLm9uKCdkYmxjbGljaycsIGZsaXBBeGlzQW5kVXBkYXRlUENQKS5vbignd2hlZWwnLCByb3RhdGVMYWJlbHMpO1xuXG4gICAgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAndG9wJykge1xuICAgICAgcGMuc3ZnLmFwcGVuZCgnbGluZScpLmF0dHIoJ3gxJywgMCkuYXR0cigneTEnLCAxICsgX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy50b3ApLmF0dHIoJ3gyJywgdygpKS5hdHRyKCd5MicsIDEgKyBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLnRvcCkuYXR0cignc3Ryb2tlLXdpZHRoJywgMSkuYXR0cignc3Ryb2tlJywgJyM3NzcnKS5hdHRyKCdmaWxsJywgJ25vbmUnKS5hdHRyKCdzaGFwZS1yZW5kZXJpbmcnLCAnY3Jpc3BFZGdlcycpO1xuICAgIH0gZWxzZSBpZiAoX18ubnVsbFZhbHVlU2VwYXJhdG9yID09ICdib3R0b20nKSB7XG4gICAgICBwYy5zdmcuYXBwZW5kKCdsaW5lJykuYXR0cigneDEnLCAwKS5hdHRyKCd5MScsIGgoKSArIDEgLSBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLmJvdHRvbSkuYXR0cigneDInLCB3KCkpLmF0dHIoJ3kyJywgaCgpICsgMSAtIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcuYm90dG9tKS5hdHRyKCdzdHJva2Utd2lkdGgnLCAxKS5hdHRyKCdzdHJva2UnLCAnIzc3NycpLmF0dHIoJ2ZpbGwnLCAnbm9uZScpLmF0dHIoJ3NoYXBlLXJlbmRlcmluZycsICdjcmlzcEVkZ2VzJyk7XG4gICAgfVxuXG4gICAgZmxhZ3MuYXhlcyA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcGMucmVtb3ZlQXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBnLnJlbW92ZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHBjLnVwZGF0ZUF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdfZGF0YSA9IHBjLnN2Zy5zZWxlY3RBbGwoJy5kaW1lbnNpb24nKS5kYXRhKF9fLmRpbWVuc2lvbnMpOyAvLyBFbnRlclxuXG4gICAgZ19kYXRhLmVudGVyKCkuYXBwZW5kKCdzdmc6ZycpLmF0dHIoJ2NsYXNzJywgJ2RpbWVuc2lvbicpLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgcG9zaXRpb24ocCkgKyAnKSc7XG4gICAgfSkuc3R5bGUoJ29wYWNpdHknLCAwKS5hcHBlbmQoJ3N2ZzpnJykuYXR0cignY2xhc3MnLCAnYXhpcycpLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwwKScpLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGF4aXMuc2NhbGUoeXNjYWxlW2RdKSk7XG4gICAgfSkuYXBwZW5kKCdzdmc6dGV4dCcpLmF0dHIoe1xuICAgICAgJ3RleHQtYW5jaG9yJzogJ21pZGRsZScsXG4gICAgICB5OiAwLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDAsLTUpIHJvdGF0ZSgnICsgX18uZGltZW5zaW9uVGl0bGVSb3RhdGlvbiArICcpJyxcbiAgICAgIHg6IDAsXG4gICAgICBjbGFzczogJ2xhYmVsJ1xuICAgIH0pLnRleHQoZGltZW5zaW9uTGFiZWxzKS5vbignZGJsY2xpY2snLCBmbGlwQXhpc0FuZFVwZGF0ZVBDUCkub24oJ3doZWVsJywgcm90YXRlTGFiZWxzKTsgLy8gVXBkYXRlXG5cbiAgICBnX2RhdGEuYXR0cignb3BhY2l0eScsIDApO1xuICAgIGdfZGF0YS5zZWxlY3QoJy5heGlzJykudHJhbnNpdGlvbigpLmR1cmF0aW9uKDExMDApLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGF4aXMuc2NhbGUoeXNjYWxlW2RdKSk7XG4gICAgfSk7XG4gICAgZ19kYXRhLnNlbGVjdCgnLmxhYmVsJykudHJhbnNpdGlvbigpLmR1cmF0aW9uKDExMDApLnRleHQoZGltZW5zaW9uTGFiZWxzKS5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsLTUpIHJvdGF0ZSgnICsgX18uZGltZW5zaW9uVGl0bGVSb3RhdGlvbiArICcpJyk7IC8vIEV4aXRcblxuICAgIGdfZGF0YS5leGl0KCkucmVtb3ZlKCk7XG4gICAgZyA9IHBjLnN2Zy5zZWxlY3RBbGwoJy5kaW1lbnNpb24nKTtcbiAgICBnLnRyYW5zaXRpb24oKS5kdXJhdGlvbigxMTAwKS5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHBvc2l0aW9uKHApICsgJyknO1xuICAgIH0pLnN0eWxlKCdvcGFjaXR5JywgMSk7XG4gICAgcGMuc3ZnLnNlbGVjdEFsbCgnLmF4aXMnKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oMTEwMCkuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYXhpcy5zY2FsZSh5c2NhbGVbZF0pKTtcbiAgICB9KTtcbiAgICBpZiAoZmxhZ3MuYnJ1c2hhYmxlKSBwYy5icnVzaGFibGUoKTtcbiAgICBpZiAoZmxhZ3MucmVvcmRlcmFibGUpIHBjLnJlb3JkZXJhYmxlKCk7XG5cbiAgICBpZiAocGMuYnJ1c2hNb2RlKCkgIT09ICdOb25lJykge1xuICAgICAgdmFyIG1vZGUgPSBwYy5icnVzaE1vZGUoKTtcbiAgICAgIHBjLmJydXNoTW9kZSgnTm9uZScpO1xuICAgICAgcGMuYnJ1c2hNb2RlKG1vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9OyAvLyBKYXNvbiBEYXZpZXMsIGh0dHA6Ly9ibC5vY2tzLm9yZy8xMzQxMjgxXG5cblxuICBwYy5yZW9yZGVyYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWcpIHBjLmNyZWF0ZUF4ZXMoKTtcbiAgICBnLnN0eWxlKCdjdXJzb3InLCAnbW92ZScpLmNhbGwoZDMuYmVoYXZpb3IuZHJhZygpLm9uKCdkcmFnc3RhcnQnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgZHJhZ2dpbmdbZF0gPSB0aGlzLl9fb3JpZ2luX18gPSB4c2NhbGUoZCk7XG4gICAgfSkub24oJ2RyYWcnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgZHJhZ2dpbmdbZF0gPSBNYXRoLm1pbih3KCksIE1hdGgubWF4KDAsIHRoaXMuX19vcmlnaW5fXyArPSBkMy5ldmVudC5keCkpO1xuXG4gICAgICBfXy5kaW1lbnNpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uKGEpIC0gcG9zaXRpb24oYik7XG4gICAgICB9KTtcblxuICAgICAgeHNjYWxlLmRvbWFpbihfXy5kaW1lbnNpb25zKTtcbiAgICAgIHBjLnJlbmRlcigpO1xuICAgICAgZy5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgcG9zaXRpb24oZCkgKyAnKSc7XG4gICAgICB9KTtcbiAgICB9KS5vbignZHJhZ2VuZCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAvLyBMZXQncyBzZWUgaWYgdGhlIG9yZGVyIGhhcyBjaGFuZ2VkIGFuZCBzZW5kIG91dCBhbiBldmVudCBpZiBzby5cbiAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICBqID0gX18uZGltZW5zaW9ucy5pbmRleE9mKGQpLFxuICAgICAgICAgIGVsZW0gPSB0aGlzLFxuICAgICAgICAgIHBhcmVudCA9IHRoaXMucGFyZW50RWxlbWVudDtcblxuICAgICAgd2hpbGUgKChlbGVtID0gZWxlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSAhPSBudWxsKSArK2k7XG5cbiAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgIGV2ZW50cy5heGVzcmVvcmRlci5jYWxsKHBjLCBfXy5kaW1lbnNpb25zKTsgLy8gV2Ugbm93IGFsc28gd2FudCB0byByZW9yZGVyIHRoZSBhY3R1YWwgZG9tIGVsZW1lbnRzIHRoYXQgcmVwcmVzZW50XG4gICAgICAgIC8vIHRoZSBheGVzLiBUaGF0IGlzLCB0aGUgZy5kaW1lbnNpb24gZWxlbWVudHMuIElmIHdlIGRvbid0IGRvIHRoaXMsXG4gICAgICAgIC8vIHdlIGdldCBhIHdlaXJkIGFuZCBjb25mdXNpbmcgdHJhbnNpdGlvbiB3aGVuIHVwZGF0ZUF4ZXMgaXMgY2FsbGVkLlxuICAgICAgICAvLyBUaGlzIGlzIGR1ZSB0byB0aGUgZmFjdCB0aGF0LCBpbml0aWFsbHkgdGhlIG50aCBnLmRpbWVuc2lvbiBlbGVtZW50XG4gICAgICAgIC8vIHJlcHJlc2VudHMgdGhlIG50aCBheGlzLiBIb3dldmVyLCBhZnRlciBhIG1hbnVhbCByZW9yZGVyaW5nLFxuICAgICAgICAvLyB3aXRob3V0IHJlb3JkZXJpbmcgdGhlIGRvbSBlbGVtZW50cywgdGhlIG50aCBkb20gZWxlbWVudHMgbm8gbG9uZ2VyXG4gICAgICAgIC8vIG5lY2Vzc2FyaWx5IHJlcHJlc2VudHMgdGhlIG50aCBheGlzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBpIGlzIHRoZSBvcmlnaW5hbCBpbmRleCBvZiB0aGUgZG9tIGVsZW1lbnRcbiAgICAgICAgLy8gaiBpcyB0aGUgbmV3IGluZGV4IG9mIHRoZSBkb20gZWxlbWVudFxuXG4gICAgICAgIGlmIChpID4gaikge1xuICAgICAgICAgIC8vIEVsZW1lbnQgbW92ZWQgbGVmdFxuICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgcGFyZW50LmNoaWxkcmVuW2ogLSAxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRWxlbWVudCBtb3ZlZCByaWdodFxuICAgICAgICAgIGlmIChqICsgMSA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgcGFyZW50LmNoaWxkcmVuW2ogKyAxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGVsZXRlIHRoaXMuX19vcmlnaW5fXztcbiAgICAgIGRlbGV0ZSBkcmFnZ2luZ1tkXTtcbiAgICAgIGQzLnNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeHNjYWxlKGQpICsgJyknKTtcbiAgICAgIHBjLnJlbmRlcigpO1xuICAgIH0pKTtcbiAgICBmbGFncy5yZW9yZGVyYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07IC8vIFJlb3JkZXIgZGltZW5zaW9ucywgc3VjaCB0aGF0IHRoZSBoaWdoZXN0IHZhbHVlICh2aXN1YWxseSkgaXMgb24gdGhlIGxlZnQgYW5kXG4gIC8vIHRoZSBsb3dlc3Qgb24gdGhlIHJpZ2h0LiBWaXN1YWwgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBkYXRhIHZhbHVlcyBpblxuICAvLyB0aGUgZ2l2ZW4gcm93LlxuXG5cbiAgcGMucmVvcmRlciA9IGZ1bmN0aW9uIChyb3dkYXRhKSB7XG4gICAgdmFyIGRpbXMgPSBfXy5kaW1lbnNpb25zLnNsaWNlKDApO1xuXG4gICAgX18uZGltZW5zaW9ucy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgcGl4ZWxEaWZmZXJlbmNlID0geXNjYWxlW2FdKHJvd2RhdGFbYV0pIC0geXNjYWxlW2JdKHJvd2RhdGFbYl0pOyAvLyBBcnJheS5zb3J0IGlzIG5vdCBuZWNlc3NhcmlseSBzdGFibGUsIHRoaXMgbWVhbnMgdGhhdCBpZiBwaXhlbERpZmZlcmVuY2UgaXMgemVyb1xuICAgICAgLy8gdGhlIG9yZGVyaW5nIG9mIGRpbWVuc2lvbnMgbWlnaHQgY2hhbmdlIHVuZXhwZWN0ZWRseS4gVGhpcyBpcyBzb2x2ZWQgYnkgc29ydGluZyBvblxuICAgICAgLy8gdmFyaWFibGUgbmFtZSBpbiB0aGF0IGNhc2UuXG5cbiAgICAgIGlmIChwaXhlbERpZmZlcmVuY2UgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGEubG9jYWxlQ29tcGFyZShiKTtcbiAgICAgIH0gLy8gZWxzZVxuXG5cbiAgICAgIHJldHVybiBwaXhlbERpZmZlcmVuY2U7XG4gICAgfSk7IC8vIE5PVEU6IHRoaXMgaXMgcmVsYXRpdmVseSBjaGVhcCBnaXZlbiB0aGF0OlxuICAgIC8vIG51bWJlciBvZiBkaW1lbnNpb25zIDwgbnVtYmVyIG9mIGRhdGEgaXRlbXNcbiAgICAvLyBUaHVzIHdlIGNoZWNrIGVxdWFsaXR5IG9mIG9yZGVyIHRvIHByZXZlbnQgcmVyZW5kZXJpbmcgd2hlbiB0aGlzIGlzIHRoZSBjYXNlLlxuXG5cbiAgICB2YXIgcmVvcmRlcmVkID0gZmFsc2U7XG4gICAgZGltcy5zb21lKGZ1bmN0aW9uICh2YWwsIGluZGV4KSB7XG4gICAgICByZW9yZGVyZWQgPSB2YWwgIT09IF9fLmRpbWVuc2lvbnNbaW5kZXhdO1xuICAgICAgcmV0dXJuIHJlb3JkZXJlZDtcbiAgICB9KTtcblxuICAgIGlmIChyZW9yZGVyZWQpIHtcbiAgICAgIHhzY2FsZS5kb21haW4oX18uZGltZW5zaW9ucyk7XG5cbiAgICAgIHZhciBoaWdobGlnaHRlZCA9IF9fLmhpZ2hsaWdodGVkLnNsaWNlKDApO1xuXG4gICAgICBwYy51bmhpZ2hsaWdodCgpO1xuICAgICAgZy50cmFuc2l0aW9uKCkuZHVyYXRpb24oMTUwMCkuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHhzY2FsZShkKSArICcpJztcbiAgICAgIH0pO1xuICAgICAgcGMucmVuZGVyKCk7IC8vIHBjLmhpZ2hsaWdodCgpIGRvZXMgbm90IGNoZWNrIHdoZXRoZXIgaGlnaGxpZ2h0ZWQgaXMgbGVuZ3RoIHplcm8sIHNvIHdlIGRvIHRoYXQgaGVyZS5cblxuICAgICAgaWYgKGhpZ2hsaWdodGVkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBwYy5oaWdobGlnaHQoaGlnaGxpZ2h0ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gcGFpcnMgb2YgYWRqYWNlbnQgZGltZW5zaW9uc1xuXG5cbiAgcGMuYWRqYWNlbnRfcGFpcnMgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgICByZXQucHVzaChbYXJyW2ldLCBhcnJbaSArIDFdXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICB2YXIgYnJ1c2ggPSB7XG4gICAgbW9kZXM6IHtcbiAgICAgIE5vbmU6IHtcbiAgICAgICAgaW5zdGFsbDogZnVuY3Rpb24gKHBjKSB7fSxcbiAgICAgICAgLy8gTm90aGluZyB0byBiZSBkb25lLlxuICAgICAgICB1bmluc3RhbGw6IGZ1bmN0aW9uIChwYykge30sXG4gICAgICAgIC8vIE5vdGhpbmcgdG8gYmUgZG9uZS5cbiAgICAgICAgc2VsZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE5vdGhpbmcgdG8gcmV0dXJuXG4gICAgICAgIGJydXNoU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG1vZGU6ICdOb25lJyxcbiAgICBwcmVkaWNhdGU6ICdBTkQnLFxuICAgIGN1cnJlbnRNb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2Rlc1t0aGlzLm1vZGVdO1xuICAgIH1cbiAgfTsgLy8gVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCBmb3IgJ2xpdmUnIHVwZGF0ZXMgb2YgYnJ1c2hlcy4gVGhhdCBpcywgZHVyaW5nIHRoZVxuICAvLyBzcGVjaWZpY2F0aW9uIG9mIGEgYnJ1c2gsIHRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgdG8gdXBkYXRlIHRoZSB2aWV3LlxuICAvL1xuICAvLyBAcGFyYW0gbmV3U2VsZWN0aW9uIC0gVGhlIG5ldyBzZXQgb2YgZGF0YSBpdGVtcyB0aGF0IGlzIGN1cnJlbnRseSBjb250YWluZWRcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIGJ5IHRoZSBicnVzaGVzXG5cbiAgZnVuY3Rpb24gYnJ1c2hVcGRhdGVkKG5ld1NlbGVjdGlvbikge1xuICAgIF9fLmJydXNoZWQgPSBuZXdTZWxlY3Rpb247XG4gICAgZXZlbnRzLmJydXNoLmNhbGwocGMsIF9fLmJydXNoZWQpO1xuICAgIHBjLnJlbmRlckJydXNoZWQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJydXNoUHJlZGljYXRlKHByZWRpY2F0ZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJydXNoLnByZWRpY2F0ZTtcbiAgICB9XG5cbiAgICBwcmVkaWNhdGUgPSBTdHJpbmcocHJlZGljYXRlKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgaWYgKHByZWRpY2F0ZSAhPT0gJ0FORCcgJiYgcHJlZGljYXRlICE9PSAnT1InKSB7XG4gICAgICB0aHJvdyAnSW52YWxpZCBwcmVkaWNhdGUgJyArIHByZWRpY2F0ZTtcbiAgICB9XG5cbiAgICBicnVzaC5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgX18uYnJ1c2hlZCA9IGJydXNoLmN1cnJlbnRNb2RlKCkuc2VsZWN0ZWQoKTtcbiAgICBwYy5yZW5kZXJCcnVzaGVkKCk7XG4gICAgcmV0dXJuIHBjO1xuICB9XG5cbiAgcGMuYnJ1c2hNb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYnJ1c2gubW9kZXMpO1xuICB9O1xuXG4gIHBjLmJydXNoTW9kZSA9IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBicnVzaC5tb2RlO1xuICAgIH1cblxuICAgIGlmIChwYy5icnVzaE1vZGVzKCkuaW5kZXhPZihtb2RlKSA9PT0gLTEpIHtcbiAgICAgIHRocm93ICdwYy5icnVzaG1vZGU6IFVuc3VwcG9ydGVkIGJydXNoIG1vZGU6ICcgKyBtb2RlO1xuICAgIH0gLy8gTWFrZSBzdXJlIHRoYXQgd2UgZG9uJ3QgdHJpZ2dlciB1bm5lY2Vzc2FyeSBldmVudHMgYnkgY2hlY2tpbmcgaWYgdGhlIG1vZGVcbiAgICAvLyBhY3R1YWxseSBjaGFuZ2VzLlxuXG5cbiAgICBpZiAobW9kZSAhPT0gYnJ1c2gubW9kZSkge1xuICAgICAgLy8gV2hlbiBjaGFuZ2luZyBicnVzaCBtb2RlcywgdGhlIGZpcnN0IHRoaW5nIHdlIG5lZWQgdG8gZG8gaXMgY2xlYXJpbmcgYW55XG4gICAgICAvLyBicnVzaGVzIGZyb20gdGhlIGN1cnJlbnQgbW9kZSwgaWYgYW55LlxuICAgICAgaWYgKGJydXNoLm1vZGUgIT09ICdOb25lJykge1xuICAgICAgICBwYy5icnVzaFJlc2V0KCk7XG4gICAgICB9IC8vIE5leHQsIHdlIG5lZWQgdG8gJ3VuaW5zdGFsbCcgdGhlIGN1cnJlbnQgYnJ1c2hNb2RlLlxuXG5cbiAgICAgIGJydXNoLm1vZGVzW2JydXNoLm1vZGVdLnVuaW5zdGFsbChwYyk7IC8vIEZpbmFsbHksIHdlIGNhbiBpbnN0YWxsIHRoZSByZXF1ZXN0ZWQgb25lLlxuXG4gICAgICBicnVzaC5tb2RlID0gbW9kZTtcbiAgICAgIGJydXNoLm1vZGVzW2JydXNoLm1vZGVdLmluc3RhbGwoKTtcblxuICAgICAgaWYgKG1vZGUgPT09ICdOb25lJykge1xuICAgICAgICBkZWxldGUgcGMuYnJ1c2hQcmVkaWNhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYy5icnVzaFByZWRpY2F0ZSA9IGJydXNoUHJlZGljYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYztcbiAgfTsgLy8gYnJ1c2ggbW9kZTogMUQtQXhlc1xuXG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYnJ1c2hlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gaXNfYnJ1c2hlZChwKSB7XG4gICAgICByZXR1cm4gIWJydXNoZXNbcF0uZW1wdHkoKTtcbiAgICB9IC8vIGRhdGEgd2l0aGluIGV4dGVudHNcblxuXG4gICAgZnVuY3Rpb24gc2VsZWN0ZWQoKSB7XG4gICAgICB2YXIgYWN0aXZlcyA9IF9fLmRpbWVuc2lvbnMuZmlsdGVyKGlzX2JydXNoZWQpLFxuICAgICAgICAgIGV4dGVudHMgPSBhY3RpdmVzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gYnJ1c2hlc1twXS5leHRlbnQoKTtcbiAgICAgIH0pOyAvLyBXZSBkb24ndCB3YW50IHRvIHJldHVybiB0aGUgZnVsbCBkYXRhIHNldCB3aGVuIHRoZXJlIGFyZSBubyBheGVzIGJydXNoZWQuXG4gICAgICAvLyBBY3R1YWxseSwgd2hlbiB0aGVyZSBhcmUgbm8gYXhlcyBicnVzaGVkLCBieSBkZWZpbml0aW9uLCBubyBpdGVtcyBhcmVcbiAgICAgIC8vIHNlbGVjdGVkLiBTbywgbGV0J3MgYXZvaWQgdGhlIGZpbHRlcmluZyBhbmQganVzdCByZXR1cm4gZmFsc2UuXG4gICAgICAvL2lmIChhY3RpdmVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gUmVzb2x2ZXMgYnJva2VuIGV4YW1wbGVzIGZvciBub3cuIFRoZXkgZXhwZWN0IHRvIGdldCB0aGUgZnVsbCBkYXRhc2V0IGJhY2sgZnJvbSBlbXB0eSBicnVzaGVzXG5cblxuICAgICAgaWYgKGFjdGl2ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gX18uZGF0YTsgLy8gdGVzdCBpZiB3aXRoaW4gcmFuZ2VcblxuICAgICAgdmFyIHdpdGhpbiA9IHtcbiAgICAgICAgZGF0ZTogZnVuY3Rpb24gKGQsIHAsIGRpbWVuc2lvbikge1xuICAgICAgICAgIGlmICh0eXBlb2YgeXNjYWxlW3BdLnJhbmdlUG9pbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBvcmRpbmFsXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW50c1tkaW1lbnNpb25dWzBdIDw9IHlzY2FsZVtwXShkW3BdKSAmJiB5c2NhbGVbcF0oZFtwXSkgPD0gZXh0ZW50c1tkaW1lbnNpb25dWzFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0ZW50c1tkaW1lbnNpb25dWzBdIDw9IGRbcF0gJiYgZFtwXSA8PSBleHRlbnRzW2RpbWVuc2lvbl1bMV07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBudW1iZXI6IGZ1bmN0aW9uIChkLCBwLCBkaW1lbnNpb24pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHlzY2FsZVtwXS5yYW5nZVBvaW50cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gaWYgaXQgaXMgb3JkaW5hbFxuICAgICAgICAgICAgcmV0dXJuIGV4dGVudHNbZGltZW5zaW9uXVswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiYgeXNjYWxlW3BdKGRbcF0pIDw9IGV4dGVudHNbZGltZW5zaW9uXVsxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGV4dGVudHNbZGltZW5zaW9uXVswXSA8PSBkW3BdICYmIGRbcF0gPD0gZXh0ZW50c1tkaW1lbnNpb25dWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RyaW5nOiBmdW5jdGlvbiAoZCwgcCwgZGltZW5zaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGV4dGVudHNbZGltZW5zaW9uXVswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiYgeXNjYWxlW3BdKGRbcF0pIDw9IGV4dGVudHNbZGltZW5zaW9uXVsxXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBfXy5kYXRhLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICBzd2l0Y2ggKGJydXNoLnByZWRpY2F0ZSkge1xuICAgICAgICAgIGNhc2UgJ0FORCc6XG4gICAgICAgICAgICByZXR1cm4gYWN0aXZlcy5ldmVyeShmdW5jdGlvbiAocCwgZGltZW5zaW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiB3aXRoaW5bX18udHlwZXNbcF1dKGQsIHAsIGRpbWVuc2lvbik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgJ09SJzpcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVzLnNvbWUoZnVuY3Rpb24gKHAsIGRpbWVuc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4gd2l0aGluW19fLnR5cGVzW3BdXShkLCBwLCBkaW1lbnNpb24pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgJ1Vua25vd24gYnJ1c2ggcHJlZGljYXRlICcgKyBfXy5icnVzaFByZWRpY2F0ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnJ1c2hFeHRlbnRzKGV4dGVudHMpIHtcbiAgICAgIGlmICh0eXBlb2YgZXh0ZW50cyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGV4dGVudHMgPSB7fTtcblxuICAgICAgICBfXy5kaW1lbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICB2YXIgYnJ1c2ggPSBicnVzaGVzW2RdO1xuXG4gICAgICAgICAgaWYgKGJydXNoICE9PSB1bmRlZmluZWQgJiYgIWJydXNoLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSBicnVzaC5leHRlbnQoKTtcbiAgICAgICAgICAgIGV4dGVudC5zb3J0KGQzLmFzY2VuZGluZyk7XG4gICAgICAgICAgICBleHRlbnRzW2RdID0gZXh0ZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVudHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2ZpcnN0IGdldCBhbGwgdGhlIGJydXNoIHNlbGVjdGlvbnNcbiAgICAgICAgdmFyIGJydXNoU2VsZWN0aW9ucyA9IHt9O1xuICAgICAgICBnLnNlbGVjdEFsbCgnLmJydXNoJykuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGJydXNoU2VsZWN0aW9uc1tkXSA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgfSk7IC8vIGxvb3Agb3ZlciBlYWNoIGRpbWVuc2lvbiBhbmQgdXBkYXRlIGFwcHJvcHJpYXRlbHkgKGlmIGl0IHdhcyBwYXNzZWQgaW4gdGhyb3VnaCBleHRlbnRzKVxuXG4gICAgICAgIF9fLmRpbWVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGlmIChleHRlbnRzW2RdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYnJ1c2ggPSBicnVzaGVzW2RdO1xuXG4gICAgICAgICAgaWYgKGJydXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vdXBkYXRlIHRoZSBleHRlbnRcbiAgICAgICAgICAgIGJydXNoLmV4dGVudChleHRlbnRzW2RdKTsgLy9yZWRyYXcgdGhlIGJydXNoXG5cbiAgICAgICAgICAgIGJydXNoKGJydXNoU2VsZWN0aW9uc1tkXSk7IC8vZmlyZSBzb21lIGV2ZW50c1xuXG4gICAgICAgICAgICBicnVzaC5ldmVudChicnVzaFNlbGVjdGlvbnNbZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vcmVkcmF3IHRoZSBjaGFydFxuXG5cbiAgICAgICAgcGMucmVuZGVyQnJ1c2hlZCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJydXNoRm9yKGF4aXMpIHtcbiAgICAgIHZhciBicnVzaCA9IGQzLnN2Zy5icnVzaCgpO1xuICAgICAgYnJ1c2gueSh5c2NhbGVbYXhpc10pLm9uKCdicnVzaHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBkMy5ldmVudC5zb3VyY2VFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSkub24oJ2JydXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBicnVzaFVwZGF0ZWQoc2VsZWN0ZWQoKSk7XG4gICAgICB9KS5vbignYnJ1c2hlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV2ZW50cy5icnVzaGVuZC5jYWxsKHBjLCBfXy5icnVzaGVkKTtcbiAgICAgIH0pO1xuICAgICAgYnJ1c2hlc1theGlzXSA9IGJydXNoO1xuICAgICAgcmV0dXJuIGJydXNoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJydXNoUmVzZXQoZGltZW5zaW9uKSB7XG4gICAgICBfXy5icnVzaGVkID0gZmFsc2U7XG5cbiAgICAgIGlmIChnKSB7XG4gICAgICAgIGcuc2VsZWN0QWxsKCcuYnJ1c2gnKS5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYnJ1c2hlc1tkXS5jbGVhcigpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBjLnJlbmRlckJydXNoZWQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgIGlmICghZykgcGMuY3JlYXRlQXhlcygpOyAvLyBBZGQgYW5kIHN0b3JlIGEgYnJ1c2ggZm9yIGVhY2ggYXhpcy5cblxuICAgICAgZy5hcHBlbmQoJ3N2ZzpnJykuYXR0cignY2xhc3MnLCAnYnJ1c2gnKS5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGJydXNoRm9yKGQpKTtcbiAgICAgIH0pLnNlbGVjdEFsbCgncmVjdCcpLnN0eWxlKCd2aXNpYmlsaXR5JywgbnVsbCkuYXR0cigneCcsIC0xNSkuYXR0cignd2lkdGgnLCAzMCk7XG4gICAgICBwYy5icnVzaEV4dGVudHMgPSBicnVzaEV4dGVudHM7XG4gICAgICBwYy5icnVzaFJlc2V0ID0gYnJ1c2hSZXNldDtcbiAgICAgIHJldHVybiBwYztcbiAgICB9XG5cbiAgICBicnVzaC5tb2Rlc1snMUQtYXhlcyddID0ge1xuICAgICAgaW5zdGFsbDogaW5zdGFsbCxcbiAgICAgIHVuaW5zdGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICBnLnNlbGVjdEFsbCgnLmJydXNoJykucmVtb3ZlKCk7XG4gICAgICAgIGJydXNoZXMgPSB7fTtcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoRXh0ZW50cztcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoUmVzZXQ7XG4gICAgICB9LFxuICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxuICAgICAgYnJ1c2hTdGF0ZTogYnJ1c2hFeHRlbnRzXG4gICAgfTtcbiAgfSkoKTsgLy8gYnJ1c2ggbW9kZTogMkQtc3RydW1zXG4gIC8vIGJsLm9ja3Mub3JnL3N5bnRhZ21hdGljLzU0NDEwMjJcblxuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0cnVtcyA9IHt9LFxuICAgICAgICBzdHJ1bVJlY3Q7XG5cbiAgICBmdW5jdGlvbiBkcmF3U3RydW0oc3RydW0sIGFjdGl2ZVBvaW50KSB7XG4gICAgICB2YXIgc3ZnID0gcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdnI3N0cnVtcycpLFxuICAgICAgICAgIGlkID0gc3RydW0uZGltcy5pLFxuICAgICAgICAgIHBvaW50cyA9IFtzdHJ1bS5wMSwgc3RydW0ucDJdLFxuICAgICAgICAgIGxpbmUgPSBzdmcuc2VsZWN0QWxsKCdsaW5lI3N0cnVtLScgKyBpZCkuZGF0YShbc3RydW1dKSxcbiAgICAgICAgICBjaXJjbGVzID0gc3ZnLnNlbGVjdEFsbCgnY2lyY2xlI3N0cnVtLScgKyBpZCkuZGF0YShwb2ludHMpLFxuICAgICAgICAgIGRyYWcgPSBkMy5iZWhhdmlvci5kcmFnKCk7XG4gICAgICBsaW5lLmVudGVyKCkuYXBwZW5kKCdsaW5lJykuYXR0cignaWQnLCAnc3RydW0tJyArIGlkKS5hdHRyKCdjbGFzcycsICdzdHJ1bScpO1xuICAgICAgbGluZS5hdHRyKCd4MScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLnAxWzBdO1xuICAgICAgfSkuYXR0cigneTEnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5wMVsxXTtcbiAgICAgIH0pLmF0dHIoJ3gyJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQucDJbMF07XG4gICAgICB9KS5hdHRyKCd5MicsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLnAyWzFdO1xuICAgICAgfSkuYXR0cignc3Ryb2tlJywgJ2JsYWNrJykuYXR0cignc3Ryb2tlLXdpZHRoJywgMik7XG4gICAgICBkcmFnLm9uKCdkcmFnJywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgdmFyIGV2ID0gZDMuZXZlbnQ7XG4gICAgICAgIGkgPSBpICsgMTtcbiAgICAgICAgc3RydW1bJ3AnICsgaV1bMF0gPSBNYXRoLm1pbihNYXRoLm1heChzdHJ1bS5taW5YICsgMSwgZXYueCksIHN0cnVtLm1heFgpO1xuICAgICAgICBzdHJ1bVsncCcgKyBpXVsxXSA9IE1hdGgubWluKE1hdGgubWF4KHN0cnVtLm1pblksIGV2LnkpLCBzdHJ1bS5tYXhZKTtcbiAgICAgICAgZHJhd1N0cnVtKHN0cnVtLCBpIC0gMSk7XG4gICAgICB9KS5vbignZHJhZ2VuZCcsIG9uRHJhZ0VuZCgpKTtcbiAgICAgIGNpcmNsZXMuZW50ZXIoKS5hcHBlbmQoJ2NpcmNsZScpLmF0dHIoJ2lkJywgJ3N0cnVtLScgKyBpZCkuYXR0cignY2xhc3MnLCAnc3RydW0nKTtcbiAgICAgIGNpcmNsZXMuYXR0cignY3gnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZFswXTtcbiAgICAgIH0pLmF0dHIoJ2N5JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGRbMV07XG4gICAgICB9KS5hdHRyKCdyJywgNSkuc3R5bGUoJ29wYWNpdHknLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICByZXR1cm4gYWN0aXZlUG9pbnQgIT09IHVuZGVmaW5lZCAmJiBpID09PSBhY3RpdmVQb2ludCA/IDAuOCA6IDA7XG4gICAgICB9KS5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ29wYWNpdHknLCAwLjgpO1xuICAgICAgfSkub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ29wYWNpdHknLCAwKTtcbiAgICAgIH0pLmNhbGwoZHJhZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGltZW5zaW9uc0ZvclBvaW50KHApIHtcbiAgICAgIHZhciBkaW1zID0ge1xuICAgICAgICBpOiAtMSxcbiAgICAgICAgbGVmdDogdW5kZWZpbmVkLFxuICAgICAgICByaWdodDogdW5kZWZpbmVkXG4gICAgICB9O1xuXG4gICAgICBfXy5kaW1lbnNpb25zLnNvbWUoZnVuY3Rpb24gKGRpbSwgaSkge1xuICAgICAgICBpZiAoeHNjYWxlKGRpbSkgPCBwWzBdKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBfXy5kaW1lbnNpb25zW2kgKyAxXTtcbiAgICAgICAgICBkaW1zLmkgPSBpO1xuICAgICAgICAgIGRpbXMubGVmdCA9IGRpbTtcbiAgICAgICAgICBkaW1zLnJpZ2h0ID0gbmV4dDtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZGltcy5sZWZ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gRXZlbnQgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgZmlyc3QgYXhpcy5cbiAgICAgICAgZGltcy5pID0gMDtcbiAgICAgICAgZGltcy5sZWZ0ID0gX18uZGltZW5zaW9uc1swXTtcbiAgICAgICAgZGltcy5yaWdodCA9IF9fLmRpbWVuc2lvbnNbMV07XG4gICAgICB9IGVsc2UgaWYgKGRpbXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBFdmVudCBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgbGFzdCBheGlzXG4gICAgICAgIGRpbXMuaSA9IF9fLmRpbWVuc2lvbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgZGltcy5yaWdodCA9IGRpbXMubGVmdDtcbiAgICAgICAgZGltcy5sZWZ0ID0gX18uZGltZW5zaW9uc1tfXy5kaW1lbnNpb25zLmxlbmd0aCAtIDJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGltcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRyYWdTdGFydCgpIHtcbiAgICAgIC8vIEZpcnN0IHdlIG5lZWQgdG8gZGV0ZXJtaW5lIGJldHdlZW4gd2hpY2ggdHdvIGF4ZXMgdGhlIHN0dXJtIHdhcyBzdGFydGVkLlxuICAgICAgLy8gVGhpcyB3aWxsIGRldGVybWluZSB0aGUgZnJlZWRvbSBvZiBtb3ZlbWVudCwgYmVjYXVzZSBhIHN0cnVtIGNhblxuICAgICAgLy8gbG9naWNhbGx5IG9ubHkgaGFwcGVuIGJldHdlZW4gdHdvIGF4ZXMsIHNvIG5vIG1vdmVtZW50IG91dHNpZGUgdGhlc2UgYXhlc1xuICAgICAgLy8gc2hvdWxkIGJlIGFsbG93ZWQuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcCA9IGQzLm1vdXNlKHN0cnVtUmVjdFswXVswXSksXG4gICAgICAgICAgICBkaW1zLFxuICAgICAgICAgICAgc3RydW07XG4gICAgICAgIHBbMF0gPSBwWzBdIC0gX18ubWFyZ2luLmxlZnQ7XG4gICAgICAgIHBbMV0gPSBwWzFdIC0gX18ubWFyZ2luLnRvcDtcbiAgICAgICAgZGltcyA9IGRpbWVuc2lvbnNGb3JQb2ludChwKSwgc3RydW0gPSB7XG4gICAgICAgICAgcDE6IHAsXG4gICAgICAgICAgZGltczogZGltcyxcbiAgICAgICAgICBtaW5YOiB4c2NhbGUoZGltcy5sZWZ0KSxcbiAgICAgICAgICBtYXhYOiB4c2NhbGUoZGltcy5yaWdodCksXG4gICAgICAgICAgbWluWTogMCxcbiAgICAgICAgICBtYXhZOiBoKClcbiAgICAgICAgfTtcbiAgICAgICAgc3RydW1zW2RpbXMuaV0gPSBzdHJ1bTtcbiAgICAgICAgc3RydW1zLmFjdGl2ZSA9IGRpbXMuaTsgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHBvaW50IGlzIHdpdGhpbiB0aGUgYm91bmRzXG5cbiAgICAgICAgc3RydW0ucDFbMF0gPSBNYXRoLm1pbihNYXRoLm1heChzdHJ1bS5taW5YLCBwWzBdKSwgc3RydW0ubWF4WCk7XG4gICAgICAgIHN0cnVtLnAyID0gc3RydW0ucDEuc2xpY2UoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25EcmFnKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV2ID0gZDMuZXZlbnQsXG4gICAgICAgICAgICBzdHJ1bSA9IHN0cnVtc1tzdHJ1bXMuYWN0aXZlXTsgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHBvaW50IGlzIHdpdGhpbiB0aGUgYm91bmRzXG5cbiAgICAgICAgc3RydW0ucDJbMF0gPSBNYXRoLm1pbihNYXRoLm1heChzdHJ1bS5taW5YICsgMSwgZXYueCAtIF9fLm1hcmdpbi5sZWZ0KSwgc3RydW0ubWF4WCk7XG4gICAgICAgIHN0cnVtLnAyWzFdID0gTWF0aC5taW4oTWF0aC5tYXgoc3RydW0ubWluWSwgZXYueSAtIF9fLm1hcmdpbi50b3ApLCBzdHJ1bS5tYXhZKTtcbiAgICAgICAgZHJhd1N0cnVtKHN0cnVtLCAxKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udGFpbm1lbnRUZXN0KHN0cnVtLCB3aWR0aCkge1xuICAgICAgdmFyIHAxID0gW3N0cnVtLnAxWzBdIC0gc3RydW0ubWluWCwgc3RydW0ucDFbMV0gLSBzdHJ1bS5taW5YXSxcbiAgICAgICAgICBwMiA9IFtzdHJ1bS5wMlswXSAtIHN0cnVtLm1pblgsIHN0cnVtLnAyWzFdIC0gc3RydW0ubWluWF0sXG4gICAgICAgICAgbTEgPSAxIC0gd2lkdGggLyBwMVswXSxcbiAgICAgICAgICBiMSA9IHAxWzFdICogKDEgLSBtMSksXG4gICAgICAgICAgbTIgPSAxIC0gd2lkdGggLyBwMlswXSxcbiAgICAgICAgICBiMiA9IHAyWzFdICogKDEgLSBtMik7IC8vIHRlc3QgaWYgcG9pbnQgZmFsbHMgYmV0d2VlbiBsaW5lc1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIHggPSBwWzBdLFxuICAgICAgICAgICAgeSA9IHBbMV0sXG4gICAgICAgICAgICB5MSA9IG0xICogeCArIGIxLFxuICAgICAgICAgICAgeTIgPSBtMiAqIHggKyBiMjtcblxuICAgICAgICBpZiAoeSA+IE1hdGgubWluKHkxLCB5MikgJiYgeSA8IE1hdGgubWF4KHkxLCB5MikpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VsZWN0ZWQoKSB7XG4gICAgICB2YXIgaWRzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3RydW1zKSxcbiAgICAgICAgICBicnVzaGVkID0gX18uZGF0YTsgLy8gR2V0IHRoZSBpZHMgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgc3RydW1zLlxuXG4gICAgICBpZHMgPSBpZHMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4oZCk7XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gY3Jvc3Nlc1N0cnVtKGQsIGlkKSB7XG4gICAgICAgIHZhciBzdHJ1bSA9IHN0cnVtc1tpZF0sXG4gICAgICAgICAgICB0ZXN0ID0gY29udGFpbm1lbnRUZXN0KHN0cnVtLCBzdHJ1bXMud2lkdGgoaWQpKSxcbiAgICAgICAgICAgIGQxID0gc3RydW0uZGltcy5sZWZ0LFxuICAgICAgICAgICAgZDIgPSBzdHJ1bS5kaW1zLnJpZ2h0LFxuICAgICAgICAgICAgeTEgPSB5c2NhbGVbZDFdLFxuICAgICAgICAgICAgeTIgPSB5c2NhbGVbZDJdLFxuICAgICAgICAgICAgcG9pbnQgPSBbeTEoZFtkMV0pIC0gc3RydW0ubWluWCwgeTIoZFtkMl0pIC0gc3RydW0ubWluWF07XG4gICAgICAgIHJldHVybiB0ZXN0KHBvaW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGJydXNoZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBicnVzaGVkLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICBzd2l0Y2ggKGJydXNoLnByZWRpY2F0ZSkge1xuICAgICAgICAgIGNhc2UgJ0FORCc6XG4gICAgICAgICAgICByZXR1cm4gaWRzLmV2ZXJ5KGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3Jvc3Nlc1N0cnVtKGQsIGlkKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAnT1InOlxuICAgICAgICAgICAgcmV0dXJuIGlkcy5zb21lKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3Jvc3Nlc1N0cnVtKGQsIGlkKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93ICdVbmtub3duIGJydXNoIHByZWRpY2F0ZSAnICsgX18uYnJ1c2hQcmVkaWNhdGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZVN0cnVtKCkge1xuICAgICAgdmFyIHN0cnVtID0gc3RydW1zW3N0cnVtcy5hY3RpdmVdLFxuICAgICAgICAgIHN2ZyA9IHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNzdHJ1bXMnKTtcbiAgICAgIGRlbGV0ZSBzdHJ1bXNbc3RydW1zLmFjdGl2ZV07XG4gICAgICBzdHJ1bXMuYWN0aXZlID0gdW5kZWZpbmVkO1xuICAgICAgc3ZnLnNlbGVjdEFsbCgnbGluZSNzdHJ1bS0nICsgc3RydW0uZGltcy5pKS5yZW1vdmUoKTtcbiAgICAgIHN2Zy5zZWxlY3RBbGwoJ2NpcmNsZSNzdHJ1bS0nICsgc3RydW0uZGltcy5pKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRyYWdFbmQoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnJ1c2hlZCA9IF9fLmRhdGEsXG4gICAgICAgICAgICBzdHJ1bSA9IHN0cnVtc1tzdHJ1bXMuYWN0aXZlXTsgLy8gT2theSwgc29tZXdoYXQgdW5leHBlY3RlZCwgYnV0IG5vdCB0b3RhbGx5IHVuc3VycHJpc2luZywgYSBtb3VzY2xpY2sgaXNcbiAgICAgICAgLy8gY29uc2lkZXJlZCBhIGRyYWcgd2l0aG91dCBtb3ZlLiBTbyB3ZSBoYXZlIHRvIGRlYWwgd2l0aCB0aGF0IGNhc2VcblxuICAgICAgICBpZiAoc3RydW0gJiYgc3RydW0ucDFbMF0gPT09IHN0cnVtLnAyWzBdICYmIHN0cnVtLnAxWzFdID09PSBzdHJ1bS5wMlsxXSkge1xuICAgICAgICAgIHJlbW92ZVN0cnVtKHN0cnVtcyk7XG4gICAgICAgIH1cblxuICAgICAgICBicnVzaGVkID0gc2VsZWN0ZWQoc3RydW1zKTtcbiAgICAgICAgc3RydW1zLmFjdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgX18uYnJ1c2hlZCA9IGJydXNoZWQ7XG4gICAgICAgIHBjLnJlbmRlckJydXNoZWQoKTtcbiAgICAgICAgZXZlbnRzLmJydXNoZW5kLmNhbGwocGMsIF9fLmJydXNoZWQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBicnVzaFJlc2V0KHN0cnVtcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN0cnVtcykuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuICFpc05hTihkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgc3RydW1zLmFjdGl2ZSA9IGQ7XG4gICAgICAgICAgcmVtb3ZlU3RydW0oc3RydW1zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uRHJhZ0VuZChzdHJ1bXMpKCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGwoKSB7XG4gICAgICB2YXIgZHJhZyA9IGQzLmJlaGF2aW9yLmRyYWcoKTsgLy8gTWFwIG9mIGN1cnJlbnQgc3RydW1zLiBTdHJ1bXMgYXJlIHN0b3JlZCBwZXIgc2VnbWVudCBvZiB0aGUgUEMuIEEgc2VnbWVudCxcbiAgICAgIC8vIGJlaW5nIHRoZSBhcmVhIGJldHdlZW4gdHdvIGF4ZXMuIFRoZSBsZWZ0IG1vc3QgYXJlYSBpcyBpbmRleGVkIGF0IDAuXG5cbiAgICAgIHN0cnVtcy5hY3RpdmUgPSB1bmRlZmluZWQ7IC8vIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBQQyBzZWdtZW50IHdoZXJlIGN1cnJlbnRseSBhIHN0cnVtIGlzIGJlaW5nXG4gICAgICAvLyBwbGFjZWQuIE5PVEU6IGV2ZW4gdGhvdWdoIHRoZXkgYXJlIGV2ZW5seSBzcGFjZWQgaW4gb3VyIGN1cnJlbnRcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uLCB3ZSBrZWVwIGZvciB3aGVuIG5vbi1ldmVuIHNwYWNlZCBzZWdtZW50cyBhcmUgc3VwcG9ydGVkIGFzXG4gICAgICAvLyB3ZWxsLlxuXG4gICAgICBzdHJ1bXMud2lkdGggPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHN0cnVtID0gc3RydW1zW2lkXTtcblxuICAgICAgICBpZiAoc3RydW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RydW0ubWF4WCAtIHN0cnVtLm1pblg7XG4gICAgICB9O1xuXG4gICAgICBwYy5vbignYXhlc3Jlb3JkZXIuc3RydW1zJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWRzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3RydW1zKS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gIWlzTmFOKGQpO1xuICAgICAgICB9KTsgLy8gQ2hlY2tzIGlmIHRoZSBmaXJzdCBkaW1lbnNpb24gaXMgZGlyZWN0bHkgbGVmdCBvZiB0aGUgc2Vjb25kIGRpbWVuc2lvbi5cblxuICAgICAgICBmdW5jdGlvbiBjb25zZWN1dGl2ZShmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IF9fLmRpbWVuc2lvbnMubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBfXy5kaW1lbnNpb25zLnNvbWUoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBkID09PSBmaXJzdCA/IGkgKyBpIDwgbGVuZ3RoICYmIF9fLmRpbWVuc2lvbnNbaSArIDFdID09PSBzZWNvbmQgOiBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIFdlIGhhdmUgc29tZSBzdHJ1bXMsIHdoaWNoIG1pZ2h0IG5lZWQgdG8gYmUgcmVtb3ZlZC5cbiAgICAgICAgICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgdmFyIGRpbXMgPSBzdHJ1bXNbZF0uZGltcztcbiAgICAgICAgICAgIHN0cnVtcy5hY3RpdmUgPSBkOyAvLyBJZiB0aGUgdHdvIGRpbWVuc2lvbnMgb2YgdGhlIGN1cnJlbnQgc3RydW0gYXJlIG5vdCBuZXh0IHRvIGVhY2ggb3RoZXJcbiAgICAgICAgICAgIC8vIGFueSBtb3JlLCB0aGFuIHdlJ2xsIG5lZWQgdG8gcmVtb3ZlIHRoZSBzdHJ1bS4gT3RoZXJ3aXNlIHdlIGtlZXAgaXQuXG5cbiAgICAgICAgICAgIGlmICghY29uc2VjdXRpdmUoZGltcy5sZWZ0LCBkaW1zLnJpZ2h0KSkge1xuICAgICAgICAgICAgICByZW1vdmVTdHJ1bShzdHJ1bXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG9uRHJhZ0VuZChzdHJ1bXMpKCk7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBBZGQgYSBuZXcgc3ZnIGdyb3VwIGluIHdoaWNoIHdlIGRyYXcgdGhlIHN0cnVtcy5cblxuICAgICAgcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuYXBwZW5kKCdnJykuYXR0cignaWQnLCAnc3RydW1zJykuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgX18ubWFyZ2luLmxlZnQgKyAnLCcgKyBfXy5tYXJnaW4udG9wICsgJyknKTsgLy8gSW5zdGFsbCB0aGUgcmVxdWlyZWQgYnJ1c2hSZXNldCBmdW5jdGlvblxuXG4gICAgICBwYy5icnVzaFJlc2V0ID0gYnJ1c2hSZXNldChzdHJ1bXMpO1xuICAgICAgZHJhZy5vbignZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQoc3RydW1zKSkub24oJ2RyYWcnLCBvbkRyYWcoc3RydW1zKSkub24oJ2RyYWdlbmQnLCBvbkRyYWdFbmQoc3RydW1zKSk7IC8vIE5PVEU6IFRoZSBzdHlsaW5nIG5lZWRzIHRvIGJlIGRvbmUgaGVyZSBhbmQgbm90IGluIHRoZSBjc3MuIFRoaXMgaXMgYmVjYXVzZVxuICAgICAgLy8gICAgICAgZm9yIDFEIGJydXNoaW5nLCB0aGUgY2FudmFzIGxheWVycyBzaG91bGQgbm90IGxpc3RlbiB0b1xuICAgICAgLy8gICAgICAgcG9pbnRlci1ldmVudHMuXG5cbiAgICAgIHN0cnVtUmVjdCA9IHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLmluc2VydCgncmVjdCcsICdnI3N0cnVtcycpLmF0dHIoJ2lkJywgJ3N0cnVtLWV2ZW50cycpLmF0dHIoJ3gnLCBfXy5tYXJnaW4ubGVmdCkuYXR0cigneScsIF9fLm1hcmdpbi50b3ApLmF0dHIoJ3dpZHRoJywgdygpKS5hdHRyKCdoZWlnaHQnLCBoKCkgKyAyKS5zdHlsZSgnb3BhY2l0eScsIDApLmNhbGwoZHJhZyk7XG4gICAgfVxuXG4gICAgYnJ1c2gubW9kZXNbJzJELXN0cnVtcyddID0ge1xuICAgICAgaW5zdGFsbDogaW5zdGFsbCxcbiAgICAgIHVuaW5zdGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5zZWxlY3QoJ2cjc3RydW1zJykucmVtb3ZlKCk7XG4gICAgICAgIHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgncmVjdCNzdHJ1bS1ldmVudHMnKS5yZW1vdmUoKTtcbiAgICAgICAgcGMub24oJ2F4ZXNyZW9yZGVyLnN0cnVtcycsIHVuZGVmaW5lZCk7XG4gICAgICAgIGRlbGV0ZSBwYy5icnVzaFJlc2V0O1xuICAgICAgICBzdHJ1bVJlY3QgPSB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxuICAgICAgYnJ1c2hTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3RydW1zO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCk7IC8vIGJydXNoIG1vZGU6IDFELUF4ZXMgd2l0aCBtdWx0aXBsZSBleHRlbnRzXG4gIC8vIHJlcXVpcmVzIGQzLnN2Zy5tdWx0aWJydXNoXG5cblxuICAoZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgZDMuc3ZnLm11bHRpYnJ1c2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYnJ1c2hlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gaXNfYnJ1c2hlZChwKSB7XG4gICAgICByZXR1cm4gIWJydXNoZXNbcF0uZW1wdHkoKTtcbiAgICB9IC8vIGRhdGEgd2l0aGluIGV4dGVudHNcblxuXG4gICAgZnVuY3Rpb24gc2VsZWN0ZWQoKSB7XG4gICAgICB2YXIgYWN0aXZlcyA9IF9fLmRpbWVuc2lvbnMuZmlsdGVyKGlzX2JydXNoZWQpLFxuICAgICAgICAgIGV4dGVudHMgPSBhY3RpdmVzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gYnJ1c2hlc1twXS5leHRlbnQoKTtcbiAgICAgIH0pOyAvLyBXZSBkb24ndCB3YW50IHRvIHJldHVybiB0aGUgZnVsbCBkYXRhIHNldCB3aGVuIHRoZXJlIGFyZSBubyBheGVzIGJydXNoZWQuXG4gICAgICAvLyBBY3R1YWxseSwgd2hlbiB0aGVyZSBhcmUgbm8gYXhlcyBicnVzaGVkLCBieSBkZWZpbml0aW9uLCBubyBpdGVtcyBhcmVcbiAgICAgIC8vIHNlbGVjdGVkLiBTbywgbGV0J3MgYXZvaWQgdGhlIGZpbHRlcmluZyBhbmQganVzdCByZXR1cm4gZmFsc2UuXG4gICAgICAvL2lmIChhY3RpdmVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gUmVzb2x2ZXMgYnJva2VuIGV4YW1wbGVzIGZvciBub3cuIFRoZXkgZXhwZWN0IHRvIGdldCB0aGUgZnVsbCBkYXRhc2V0IGJhY2sgZnJvbSBlbXB0eSBicnVzaGVzXG5cblxuICAgICAgaWYgKGFjdGl2ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gX18uZGF0YTsgLy8gdGVzdCBpZiB3aXRoaW4gcmFuZ2VcblxuICAgICAgdmFyIHdpdGhpbiA9IHtcbiAgICAgICAgZGF0ZTogZnVuY3Rpb24gKGQsIHAsIGRpbWVuc2lvbiwgYikge1xuICAgICAgICAgIGlmICh0eXBlb2YgeXNjYWxlW3BdLnJhbmdlUG9pbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBvcmRpbmFsXG4gICAgICAgICAgICByZXR1cm4gYlswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiYgeXNjYWxlW3BdKGRbcF0pIDw9IGJbMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBiWzBdIDw9IGRbcF0gJiYgZFtwXSA8PSBiWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbnVtYmVyOiBmdW5jdGlvbiAoZCwgcCwgZGltZW5zaW9uLCBiKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB5c2NhbGVbcF0ucmFuZ2VQb2ludHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIG9yZGluYWxcbiAgICAgICAgICAgIHJldHVybiBiWzBdIDw9IHlzY2FsZVtwXShkW3BdKSAmJiB5c2NhbGVbcF0oZFtwXSkgPD0gYlsxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGJbMF0gPD0gZFtwXSAmJiBkW3BdIDw9IGJbMV07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdHJpbmc6IGZ1bmN0aW9uIChkLCBwLCBkaW1lbnNpb24sIGIpIHtcbiAgICAgICAgICByZXR1cm4gYlswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiYgeXNjYWxlW3BdKGRbcF0pIDw9IGJbMV07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gX18uZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgc3dpdGNoIChicnVzaC5wcmVkaWNhdGUpIHtcbiAgICAgICAgICBjYXNlICdBTkQnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZXMuZXZlcnkoZnVuY3Rpb24gKHAsIGRpbWVuc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4gZXh0ZW50c1tkaW1lbnNpb25dLnNvbWUoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aGluW19fLnR5cGVzW3BdXShkLCBwLCBkaW1lbnNpb24sIGIpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAnT1InOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZXMuc29tZShmdW5jdGlvbiAocCwgZGltZW5zaW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiBleHRlbnRzW2RpbWVuc2lvbl0uc29tZShmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aXRoaW5bX18udHlwZXNbcF1dKGQsIHAsIGRpbWVuc2lvbiwgYik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgJ1Vua25vd24gYnJ1c2ggcHJlZGljYXRlICcgKyBfXy5icnVzaFByZWRpY2F0ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnJ1c2hFeHRlbnRzKCkge1xuICAgICAgdmFyIGV4dGVudHMgPSB7fTtcblxuICAgICAgX18uZGltZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBicnVzaCA9IGJydXNoZXNbZF07XG5cbiAgICAgICAgaWYgKGJydXNoICE9PSB1bmRlZmluZWQgJiYgIWJydXNoLmVtcHR5KCkpIHtcbiAgICAgICAgICB2YXIgZXh0ZW50ID0gYnJ1c2guZXh0ZW50KCk7XG4gICAgICAgICAgZXh0ZW50c1tkXSA9IGV4dGVudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBleHRlbnRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJydXNoRm9yKGF4aXMpIHtcbiAgICAgIHZhciBicnVzaCA9IGQzLnN2Zy5tdWx0aWJydXNoKCk7XG4gICAgICBicnVzaC55KHlzY2FsZVtheGlzXSkub24oJ2JydXNoc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChkMy5ldmVudC5zb3VyY2VFdmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIGQzLmV2ZW50LnNvdXJjZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9KS5vbignYnJ1c2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGJydXNoVXBkYXRlZChzZWxlY3RlZCgpKTtcbiAgICAgIH0pLm9uKCdicnVzaGVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZDMuc3ZnLm11bHRpYnJ1c2ggY2xlYXJzIGV4dGVudHMganVzdCBiZWZvcmUgY2FsbGluZyAnYnJ1c2hlbmQnXG4gICAgICAgIC8vIHNvIHdlIGhhdmUgdG8gdXBkYXRlIGhlcmUgYWdhaW4uXG4gICAgICAgIC8vIFRoaXMgZml4ZXMgaXNzdWUgIzEwMyBmb3Igbm93LCBidXQgc2hvdWxkIGJlIGNoYW5nZWQgaW4gZDMuc3ZnLm11bHRpYnJ1c2hcbiAgICAgICAgLy8gdG8gYXZvaWQgdW5uZWNlc3NhcnkgY29tcHV0YXRpb24uXG4gICAgICAgIGJydXNoVXBkYXRlZChzZWxlY3RlZCgpKTtcbiAgICAgICAgZXZlbnRzLmJydXNoZW5kLmNhbGwocGMsIF9fLmJydXNoZWQpO1xuICAgICAgfSkuZXh0ZW50QWRhcHRpb24oZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICBzZWxlY3Rpb24uc3R5bGUoJ3Zpc2liaWxpdHknLCBudWxsKS5hdHRyKCd4JywgLTE1KS5hdHRyKCd3aWR0aCcsIDMwKTtcbiAgICAgIH0pLnJlc2l6ZUFkYXB0aW9uKGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdEFsbCgncmVjdCcpLmF0dHIoJ3gnLCAtMTUpLmF0dHIoJ3dpZHRoJywgMzApO1xuICAgICAgfSk7XG4gICAgICBicnVzaGVzW2F4aXNdID0gYnJ1c2g7XG4gICAgICByZXR1cm4gYnJ1c2g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnJ1c2hSZXNldChkaW1lbnNpb24pIHtcbiAgICAgIF9fLmJydXNoZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKGcpIHtcbiAgICAgICAgZy5zZWxlY3RBbGwoJy5icnVzaCcpLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChicnVzaGVzW2RdLmNsZWFyKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGMucmVuZGVyQnJ1c2hlZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsKCkge1xuICAgICAgaWYgKCFnKSBwYy5jcmVhdGVBeGVzKCk7IC8vIEFkZCBhbmQgc3RvcmUgYSBicnVzaCBmb3IgZWFjaCBheGlzLlxuXG4gICAgICBnLmFwcGVuZCgnc3ZnOmcnKS5hdHRyKCdjbGFzcycsICdicnVzaCcpLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYnJ1c2hGb3IoZCkpO1xuICAgICAgfSkuc2VsZWN0QWxsKCdyZWN0Jykuc3R5bGUoJ3Zpc2liaWxpdHknLCBudWxsKS5hdHRyKCd4JywgLTE1KS5hdHRyKCd3aWR0aCcsIDMwKTtcbiAgICAgIHBjLmJydXNoRXh0ZW50cyA9IGJydXNoRXh0ZW50cztcbiAgICAgIHBjLmJydXNoUmVzZXQgPSBicnVzaFJlc2V0O1xuICAgICAgcmV0dXJuIHBjO1xuICAgIH1cblxuICAgIGJydXNoLm1vZGVzWycxRC1heGVzLW11bHRpJ10gPSB7XG4gICAgICBpbnN0YWxsOiBpbnN0YWxsLFxuICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGcuc2VsZWN0QWxsKCcuYnJ1c2gnKS5yZW1vdmUoKTtcbiAgICAgICAgYnJ1c2hlcyA9IHt9O1xuICAgICAgICBkZWxldGUgcGMuYnJ1c2hFeHRlbnRzO1xuICAgICAgICBkZWxldGUgcGMuYnJ1c2hSZXNldDtcbiAgICAgIH0sXG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICBicnVzaFN0YXRlOiBicnVzaEV4dGVudHNcbiAgICB9O1xuICB9KSgpOyAvLyBicnVzaCBtb2RlOiBhbmd1bGFyXG4gIC8vIGNvZGUgYmFzZWQgb24gMkQuc3RydW1zLmpzXG5cblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmNzID0ge30sXG4gICAgICAgIHN0cnVtUmVjdDtcblxuICAgIGZ1bmN0aW9uIGRyYXdTdHJ1bShhcmMsIGFjdGl2ZVBvaW50KSB7XG4gICAgICB2YXIgc3ZnID0gcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdnI2FyY3MnKSxcbiAgICAgICAgICBpZCA9IGFyYy5kaW1zLmksXG4gICAgICAgICAgcG9pbnRzID0gW2FyYy5wMiwgYXJjLnAzXSxcbiAgICAgICAgICBsaW5lID0gc3ZnLnNlbGVjdEFsbCgnbGluZSNhcmMtJyArIGlkKS5kYXRhKFt7XG4gICAgICAgIHAxOiBhcmMucDEsXG4gICAgICAgIHAyOiBhcmMucDJcbiAgICAgIH0sIHtcbiAgICAgICAgcDE6IGFyYy5wMSxcbiAgICAgICAgcDI6IGFyYy5wM1xuICAgICAgfV0pLFxuICAgICAgICAgIGNpcmNsZXMgPSBzdmcuc2VsZWN0QWxsKCdjaXJjbGUjYXJjLScgKyBpZCkuZGF0YShwb2ludHMpLFxuICAgICAgICAgIGRyYWcgPSBkMy5iZWhhdmlvci5kcmFnKCksXG4gICAgICAgICAgcGF0aCA9IHN2Zy5zZWxlY3RBbGwoJ3BhdGgjYXJjLScgKyBpZCkuZGF0YShbYXJjXSk7XG4gICAgICBwYXRoLmVudGVyKCkuYXBwZW5kKCdwYXRoJykuYXR0cignaWQnLCAnYXJjLScgKyBpZCkuYXR0cignY2xhc3MnLCAnYXJjJykuc3R5bGUoJ2ZpbGwnLCAnb3JhbmdlJykuc3R5bGUoJ29wYWNpdHknLCAwLjUpO1xuICAgICAgcGF0aC5hdHRyKCdkJywgYXJjLmFyYykuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgYXJjLnAxWzBdICsgJywnICsgYXJjLnAxWzFdICsgJyknKTtcbiAgICAgIGxpbmUuZW50ZXIoKS5hcHBlbmQoJ2xpbmUnKS5hdHRyKCdpZCcsICdhcmMtJyArIGlkKS5hdHRyKCdjbGFzcycsICdhcmMnKTtcbiAgICAgIGxpbmUuYXR0cigneDEnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5wMVswXTtcbiAgICAgIH0pLmF0dHIoJ3kxJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQucDFbMV07XG4gICAgICB9KS5hdHRyKCd4MicsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLnAyWzBdO1xuICAgICAgfSkuYXR0cigneTInLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5wMlsxXTtcbiAgICAgIH0pLmF0dHIoJ3N0cm9rZScsICdibGFjaycpLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDIpO1xuICAgICAgZHJhZy5vbignZHJhZycsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHZhciBldiA9IGQzLmV2ZW50LFxuICAgICAgICAgICAgYW5nbGUgPSAwO1xuICAgICAgICBpID0gaSArIDI7XG4gICAgICAgIGFyY1sncCcgKyBpXVswXSA9IE1hdGgubWluKE1hdGgubWF4KGFyYy5taW5YICsgMSwgZXYueCksIGFyYy5tYXhYKTtcbiAgICAgICAgYXJjWydwJyArIGldWzFdID0gTWF0aC5taW4oTWF0aC5tYXgoYXJjLm1pblksIGV2LnkpLCBhcmMubWF4WSk7XG4gICAgICAgIGFuZ2xlID0gaSA9PT0gMyA/IGFyY3Muc3RhcnRBbmdsZShpZCkgOiBhcmNzLmVuZEFuZ2xlKGlkKTtcblxuICAgICAgICBpZiAoYXJjLnN0YXJ0QW5nbGUgPCBNYXRoLlBJICYmIGFyYy5lbmRBbmdsZSA8IE1hdGguUEkgJiYgYW5nbGUgPCBNYXRoLlBJIHx8IGFyYy5zdGFydEFuZ2xlID49IE1hdGguUEkgJiYgYXJjLmVuZEFuZ2xlID49IE1hdGguUEkgJiYgYW5nbGUgPj0gTWF0aC5QSSkge1xuICAgICAgICAgIGlmIChpID09PSAyKSB7XG4gICAgICAgICAgICBhcmMuZW5kQW5nbGUgPSBhbmdsZTtcbiAgICAgICAgICAgIGFyYy5hcmMuZW5kQW5nbGUoYW5nbGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMykge1xuICAgICAgICAgICAgYXJjLnN0YXJ0QW5nbGUgPSBhbmdsZTtcbiAgICAgICAgICAgIGFyYy5hcmMuc3RhcnRBbmdsZShhbmdsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZHJhd1N0cnVtKGFyYywgaSAtIDIpO1xuICAgICAgfSkub24oJ2RyYWdlbmQnLCBvbkRyYWdFbmQoKSk7XG4gICAgICBjaXJjbGVzLmVudGVyKCkuYXBwZW5kKCdjaXJjbGUnKS5hdHRyKCdpZCcsICdhcmMtJyArIGlkKS5hdHRyKCdjbGFzcycsICdhcmMnKTtcbiAgICAgIGNpcmNsZXMuYXR0cignY3gnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZFswXTtcbiAgICAgIH0pLmF0dHIoJ2N5JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGRbMV07XG4gICAgICB9KS5hdHRyKCdyJywgNSkuc3R5bGUoJ29wYWNpdHknLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICByZXR1cm4gYWN0aXZlUG9pbnQgIT09IHVuZGVmaW5lZCAmJiBpID09PSBhY3RpdmVQb2ludCA/IDAuOCA6IDA7XG4gICAgICB9KS5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ29wYWNpdHknLCAwLjgpO1xuICAgICAgfSkub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ29wYWNpdHknLCAwKTtcbiAgICAgIH0pLmNhbGwoZHJhZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGltZW5zaW9uc0ZvclBvaW50KHApIHtcbiAgICAgIHZhciBkaW1zID0ge1xuICAgICAgICBpOiAtMSxcbiAgICAgICAgbGVmdDogdW5kZWZpbmVkLFxuICAgICAgICByaWdodDogdW5kZWZpbmVkXG4gICAgICB9O1xuXG4gICAgICBfXy5kaW1lbnNpb25zLnNvbWUoZnVuY3Rpb24gKGRpbSwgaSkge1xuICAgICAgICBpZiAoeHNjYWxlKGRpbSkgPCBwWzBdKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBfXy5kaW1lbnNpb25zW2kgKyAxXTtcbiAgICAgICAgICBkaW1zLmkgPSBpO1xuICAgICAgICAgIGRpbXMubGVmdCA9IGRpbTtcbiAgICAgICAgICBkaW1zLnJpZ2h0ID0gbmV4dDtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZGltcy5sZWZ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gRXZlbnQgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgZmlyc3QgYXhpcy5cbiAgICAgICAgZGltcy5pID0gMDtcbiAgICAgICAgZGltcy5sZWZ0ID0gX18uZGltZW5zaW9uc1swXTtcbiAgICAgICAgZGltcy5yaWdodCA9IF9fLmRpbWVuc2lvbnNbMV07XG4gICAgICB9IGVsc2UgaWYgKGRpbXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBFdmVudCBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgbGFzdCBheGlzXG4gICAgICAgIGRpbXMuaSA9IF9fLmRpbWVuc2lvbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgZGltcy5yaWdodCA9IGRpbXMubGVmdDtcbiAgICAgICAgZGltcy5sZWZ0ID0gX18uZGltZW5zaW9uc1tfXy5kaW1lbnNpb25zLmxlbmd0aCAtIDJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGltcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRyYWdTdGFydCgpIHtcbiAgICAgIC8vIEZpcnN0IHdlIG5lZWQgdG8gZGV0ZXJtaW5lIGJldHdlZW4gd2hpY2ggdHdvIGF4ZXMgdGhlIGFyYyB3YXMgc3RhcnRlZC5cbiAgICAgIC8vIFRoaXMgd2lsbCBkZXRlcm1pbmUgdGhlIGZyZWVkb20gb2YgbW92ZW1lbnQsIGJlY2F1c2UgYSBhcmMgY2FuXG4gICAgICAvLyBsb2dpY2FsbHkgb25seSBoYXBwZW4gYmV0d2VlbiB0d28gYXhlcywgc28gbm8gbW92ZW1lbnQgb3V0c2lkZSB0aGVzZSBheGVzXG4gICAgICAvLyBzaG91bGQgYmUgYWxsb3dlZC5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwID0gZDMubW91c2Uoc3RydW1SZWN0WzBdWzBdKSxcbiAgICAgICAgICAgIGRpbXMsXG4gICAgICAgICAgICBhcmM7XG4gICAgICAgIHBbMF0gPSBwWzBdIC0gX18ubWFyZ2luLmxlZnQ7XG4gICAgICAgIHBbMV0gPSBwWzFdIC0gX18ubWFyZ2luLnRvcDtcbiAgICAgICAgZGltcyA9IGRpbWVuc2lvbnNGb3JQb2ludChwKSwgYXJjID0ge1xuICAgICAgICAgIHAxOiBwLFxuICAgICAgICAgIGRpbXM6IGRpbXMsXG4gICAgICAgICAgbWluWDogeHNjYWxlKGRpbXMubGVmdCksXG4gICAgICAgICAgbWF4WDogeHNjYWxlKGRpbXMucmlnaHQpLFxuICAgICAgICAgIG1pblk6IDAsXG4gICAgICAgICAgbWF4WTogaCgpLFxuICAgICAgICAgIHN0YXJ0QW5nbGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBlbmRBbmdsZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGFyYzogZDMuc3ZnLmFyYygpLmlubmVyUmFkaXVzKDApXG4gICAgICAgIH07XG4gICAgICAgIGFyY3NbZGltcy5pXSA9IGFyYztcbiAgICAgICAgYXJjcy5hY3RpdmUgPSBkaW1zLmk7IC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGJvdW5kc1xuXG4gICAgICAgIGFyYy5wMVswXSA9IE1hdGgubWluKE1hdGgubWF4KGFyYy5taW5YLCBwWzBdKSwgYXJjLm1heFgpO1xuICAgICAgICBhcmMucDIgPSBhcmMucDEuc2xpY2UoKTtcbiAgICAgICAgYXJjLnAzID0gYXJjLnAxLnNsaWNlKCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRHJhZygpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBldiA9IGQzLmV2ZW50LFxuICAgICAgICAgICAgYXJjID0gYXJjc1thcmNzLmFjdGl2ZV07IC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGJvdW5kc1xuXG4gICAgICAgIGFyYy5wMlswXSA9IE1hdGgubWluKE1hdGgubWF4KGFyYy5taW5YICsgMSwgZXYueCAtIF9fLm1hcmdpbi5sZWZ0KSwgYXJjLm1heFgpO1xuICAgICAgICBhcmMucDJbMV0gPSBNYXRoLm1pbihNYXRoLm1heChhcmMubWluWSwgZXYueSAtIF9fLm1hcmdpbi50b3ApLCBhcmMubWF4WSk7XG4gICAgICAgIGFyYy5wMyA9IGFyYy5wMi5zbGljZSgpO1xuICAgICAgICBkcmF3U3RydW0oYXJjLCAxKTtcbiAgICAgIH07XG4gICAgfSAvLyBzb21lIGhlbHBlciBmdW5jdGlvbnNcblxuXG4gICAgZnVuY3Rpb24gaHlwb3RoZW51c2UoYSwgYikge1xuICAgICAgcmV0dXJuIE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgICB9XG5cbiAgICB2YXIgcmFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGMgPSBNYXRoLlBJIC8gMTgwO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgICByZXR1cm4gYW5nbGUgKiBjO1xuICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICB2YXIgZGVnID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGMgPSAxODAgLyBNYXRoLlBJO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgICByZXR1cm4gYW5nbGUgKiBjO1xuICAgICAgfTtcbiAgICB9KCk7IC8vIFswLCAyKlBJXSAtPiBbLVBJLzIsIFBJLzJdXG5cblxuICAgIHZhciBzaWduZWRBbmdsZSA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgdmFyIHJldCA9IGFuZ2xlO1xuXG4gICAgICBpZiAoYW5nbGUgPiBNYXRoLlBJKSB7XG4gICAgICAgIHJldCA9IGFuZ2xlIC0gMS41ICogTWF0aC5QSTtcbiAgICAgICAgcmV0ID0gYW5nbGUgLSAxLjUgKiBNYXRoLlBJO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYW5nbGUgLSAwLjUgKiBNYXRoLlBJO1xuICAgICAgICByZXQgPSBhbmdsZSAtIDAuNSAqIE1hdGguUEk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAtcmV0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogYW5nbGVzIGFyZSBzdG9yZWQgaW4gcmFkaWFucyBmcm9tIGluIFswLCAyKlBJXSwgd2hlcmUgMCBpbiAxMiBvJ2Nsb2NrLlxuICAgICAqIEhvd2V2ZXIsIG9uZSBjYW4gb25seSBzZWxlY3QgbGluZXMgZnJvbSAwIHRvIFBJLCBzbyB3ZSBjb21wdXRlIHRoZVxuICAgICAqICdzaWduZWQnIGFuZ2xlLCB3aGVyZSAwIGlzIHRoZSBob3Jpem9udGFsIGxpbmUgKDMgbydjbG9jayksIGFuZCArLy0gUEkvMlxuICAgICAqIGFyZSAxMiBhbmQgNiBvJ2Nsb2NrIHJlc3BlY3RpdmVseS5cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gY29udGFpbm1lbnRUZXN0KGFyYykge1xuICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBzaWduZWRBbmdsZShhcmMuc3RhcnRBbmdsZSk7XG4gICAgICB2YXIgZW5kQW5nbGUgPSBzaWduZWRBbmdsZShhcmMuZW5kQW5nbGUpO1xuXG4gICAgICBpZiAoc3RhcnRBbmdsZSA+IGVuZEFuZ2xlKSB7XG4gICAgICAgIHZhciB0bXAgPSBzdGFydEFuZ2xlO1xuICAgICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGU7XG4gICAgICAgIGVuZEFuZ2xlID0gdG1wO1xuICAgICAgfSAvLyB0ZXN0IGlmIHNlZ21lbnQgYW5nbGUgaXMgY29udGFpbmVkIGluIGFuZ2xlIGludGVydmFsXG5cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGlmIChhID49IHN0YXJ0QW5nbGUgJiYgYSA8PSBlbmRBbmdsZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZWxlY3RlZCgpIHtcbiAgICAgIHZhciBpZHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmNzKSxcbiAgICAgICAgICBicnVzaGVkID0gX18uZGF0YTsgLy8gR2V0IHRoZSBpZHMgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgYXJjcy5cblxuICAgICAgaWRzID0gaWRzLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gIWlzTmFOKGQpO1xuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNyb3NzZXNTdHJ1bShkLCBpZCkge1xuICAgICAgICB2YXIgYXJjID0gYXJjc1tpZF0sXG4gICAgICAgICAgICB0ZXN0ID0gY29udGFpbm1lbnRUZXN0KGFyYyksXG4gICAgICAgICAgICBkMSA9IGFyYy5kaW1zLmxlZnQsXG4gICAgICAgICAgICBkMiA9IGFyYy5kaW1zLnJpZ2h0LFxuICAgICAgICAgICAgeTEgPSB5c2NhbGVbZDFdLFxuICAgICAgICAgICAgeTIgPSB5c2NhbGVbZDJdLFxuICAgICAgICAgICAgYSA9IGFyY3Mud2lkdGgoaWQpLFxuICAgICAgICAgICAgYiA9IHkxKGRbZDFdKSAtIHkyKGRbZDJdKSxcbiAgICAgICAgICAgIGMgPSBoeXBvdGhlbnVzZShhLCBiKSxcbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hc2luKGIgLyBjKTsgLy8gcmFkIGluIFstUEkvMiwgUEkvMl1cblxuICAgICAgICByZXR1cm4gdGVzdChhbmdsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBicnVzaGVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJ1c2hlZC5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgc3dpdGNoIChicnVzaC5wcmVkaWNhdGUpIHtcbiAgICAgICAgICBjYXNlICdBTkQnOlxuICAgICAgICAgICAgcmV0dXJuIGlkcy5ldmVyeShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzZXNTdHJ1bShkLCBpZCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgJ09SJzpcbiAgICAgICAgICAgIHJldHVybiBpZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzZXNTdHJ1bShkLCBpZCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyAnVW5rbm93biBicnVzaCBwcmVkaWNhdGUgJyArIF9fLmJydXNoUHJlZGljYXRlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVTdHJ1bSgpIHtcbiAgICAgIHZhciBhcmMgPSBhcmNzW2FyY3MuYWN0aXZlXSxcbiAgICAgICAgICBzdmcgPSBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5zZWxlY3QoJ2cjYXJjcycpO1xuICAgICAgZGVsZXRlIGFyY3NbYXJjcy5hY3RpdmVdO1xuICAgICAgYXJjcy5hY3RpdmUgPSB1bmRlZmluZWQ7XG4gICAgICBzdmcuc2VsZWN0QWxsKCdsaW5lI2FyYy0nICsgYXJjLmRpbXMuaSkucmVtb3ZlKCk7XG4gICAgICBzdmcuc2VsZWN0QWxsKCdjaXJjbGUjYXJjLScgKyBhcmMuZGltcy5pKS5yZW1vdmUoKTtcbiAgICAgIHN2Zy5zZWxlY3RBbGwoJ3BhdGgjYXJjLScgKyBhcmMuZGltcy5pKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRyYWdFbmQoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnJ1c2hlZCA9IF9fLmRhdGEsXG4gICAgICAgICAgICBhcmMgPSBhcmNzW2FyY3MuYWN0aXZlXTsgLy8gT2theSwgc29tZXdoYXQgdW5leHBlY3RlZCwgYnV0IG5vdCB0b3RhbGx5IHVuc3VycHJpc2luZywgYSBtb3VzY2xpY2sgaXNcbiAgICAgICAgLy8gY29uc2lkZXJlZCBhIGRyYWcgd2l0aG91dCBtb3ZlLiBTbyB3ZSBoYXZlIHRvIGRlYWwgd2l0aCB0aGF0IGNhc2VcblxuICAgICAgICBpZiAoYXJjICYmIGFyYy5wMVswXSA9PT0gYXJjLnAyWzBdICYmIGFyYy5wMVsxXSA9PT0gYXJjLnAyWzFdKSB7XG4gICAgICAgICAgcmVtb3ZlU3RydW0oYXJjcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJjKSB7XG4gICAgICAgICAgdmFyIGFuZ2xlID0gYXJjcy5zdGFydEFuZ2xlKGFyY3MuYWN0aXZlKTtcbiAgICAgICAgICBhcmMuc3RhcnRBbmdsZSA9IGFuZ2xlO1xuICAgICAgICAgIGFyYy5lbmRBbmdsZSA9IGFuZ2xlO1xuICAgICAgICAgIGFyYy5hcmMub3V0ZXJSYWRpdXMoYXJjcy5sZW5ndGgoYXJjcy5hY3RpdmUpKS5zdGFydEFuZ2xlKGFuZ2xlKS5lbmRBbmdsZShhbmdsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBicnVzaGVkID0gc2VsZWN0ZWQoYXJjcyk7XG4gICAgICAgIGFyY3MuYWN0aXZlID0gdW5kZWZpbmVkO1xuICAgICAgICBfXy5icnVzaGVkID0gYnJ1c2hlZDtcbiAgICAgICAgcGMucmVuZGVyQnJ1c2hlZCgpO1xuICAgICAgICBldmVudHMuYnJ1c2hlbmQuY2FsbChwYywgX18uYnJ1c2hlZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJydXNoUmVzZXQoYXJjcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFyY3MpLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiAhaXNOYU4oZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGFyY3MuYWN0aXZlID0gZDtcbiAgICAgICAgICByZW1vdmVTdHJ1bShhcmNzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uRHJhZ0VuZChhcmNzKSgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsKCkge1xuICAgICAgdmFyIGRyYWcgPSBkMy5iZWhhdmlvci5kcmFnKCk7IC8vIE1hcCBvZiBjdXJyZW50IGFyY3MuIGFyY3MgYXJlIHN0b3JlZCBwZXIgc2VnbWVudCBvZiB0aGUgUEMuIEEgc2VnbWVudCxcbiAgICAgIC8vIGJlaW5nIHRoZSBhcmVhIGJldHdlZW4gdHdvIGF4ZXMuIFRoZSBsZWZ0IG1vc3QgYXJlYSBpcyBpbmRleGVkIGF0IDAuXG5cbiAgICAgIGFyY3MuYWN0aXZlID0gdW5kZWZpbmVkOyAvLyBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgUEMgc2VnbWVudCB3aGVyZSBjdXJyZW50bHkgYSBhcmMgaXMgYmVpbmdcbiAgICAgIC8vIHBsYWNlZC4gTk9URTogZXZlbiB0aG91Z2ggdGhleSBhcmUgZXZlbmx5IHNwYWNlZCBpbiBvdXIgY3VycmVudFxuICAgICAgLy8gaW1wbGVtZW50YXRpb24sIHdlIGtlZXAgZm9yIHdoZW4gbm9uLWV2ZW4gc3BhY2VkIHNlZ21lbnRzIGFyZSBzdXBwb3J0ZWQgYXNcbiAgICAgIC8vIHdlbGwuXG5cbiAgICAgIGFyY3Mud2lkdGggPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGFyYyA9IGFyY3NbaWRdO1xuXG4gICAgICAgIGlmIChhcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJjLm1heFggLSBhcmMubWluWDtcbiAgICAgIH07IC8vIHJldHVybnMgYW5nbGVzIGluIFstUEkvMiwgUEkvMl1cblxuXG4gICAgICBhbmdsZSA9IGZ1bmN0aW9uIChwMSwgcDIpIHtcbiAgICAgICAgdmFyIGEgPSBwMVswXSAtIHAyWzBdLFxuICAgICAgICAgICAgYiA9IHAxWzFdIC0gcDJbMV0sXG4gICAgICAgICAgICBjID0gaHlwb3RoZW51c2UoYSwgYik7XG4gICAgICAgIHJldHVybiBNYXRoLmFzaW4oYiAvIGMpO1xuICAgICAgfTsgLy8gcmV0dXJucyBhbmdsZXMgaW4gWzAsIDIgKiBQSV1cblxuXG4gICAgICBhcmNzLmVuZEFuZ2xlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBhcmMgPSBhcmNzW2lkXTtcblxuICAgICAgICBpZiAoYXJjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNBbmdsZSA9IGFuZ2xlKGFyYy5wMSwgYXJjLnAyKSxcbiAgICAgICAgICAgIHVBbmdsZSA9IC1zQW5nbGUgKyBNYXRoLlBJIC8gMjtcblxuICAgICAgICBpZiAoYXJjLnAxWzBdID4gYXJjLnAyWzBdKSB7XG4gICAgICAgICAgdUFuZ2xlID0gMiAqIE1hdGguUEkgLSB1QW5nbGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdUFuZ2xlO1xuICAgICAgfTtcblxuICAgICAgYXJjcy5zdGFydEFuZ2xlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBhcmMgPSBhcmNzW2lkXTtcblxuICAgICAgICBpZiAoYXJjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNBbmdsZSA9IGFuZ2xlKGFyYy5wMSwgYXJjLnAzKSxcbiAgICAgICAgICAgIHVBbmdsZSA9IC1zQW5nbGUgKyBNYXRoLlBJIC8gMjtcblxuICAgICAgICBpZiAoYXJjLnAxWzBdID4gYXJjLnAzWzBdKSB7XG4gICAgICAgICAgdUFuZ2xlID0gMiAqIE1hdGguUEkgLSB1QW5nbGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdUFuZ2xlO1xuICAgICAgfTtcblxuICAgICAgYXJjcy5sZW5ndGggPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGFyYyA9IGFyY3NbaWRdO1xuXG4gICAgICAgIGlmIChhcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYSA9IGFyYy5wMVswXSAtIGFyYy5wMlswXSxcbiAgICAgICAgICAgIGIgPSBhcmMucDFbMV0gLSBhcmMucDJbMV0sXG4gICAgICAgICAgICBjID0gaHlwb3RoZW51c2UoYSwgYik7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfTtcblxuICAgICAgcGMub24oJ2F4ZXNyZW9yZGVyLmFyY3MnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmNzKS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gIWlzTmFOKGQpO1xuICAgICAgICB9KTsgLy8gQ2hlY2tzIGlmIHRoZSBmaXJzdCBkaW1lbnNpb24gaXMgZGlyZWN0bHkgbGVmdCBvZiB0aGUgc2Vjb25kIGRpbWVuc2lvbi5cblxuICAgICAgICBmdW5jdGlvbiBjb25zZWN1dGl2ZShmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IF9fLmRpbWVuc2lvbnMubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBfXy5kaW1lbnNpb25zLnNvbWUoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBkID09PSBmaXJzdCA/IGkgKyBpIDwgbGVuZ3RoICYmIF9fLmRpbWVuc2lvbnNbaSArIDFdID09PSBzZWNvbmQgOiBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIFdlIGhhdmUgc29tZSBhcmNzLCB3aGljaCBtaWdodCBuZWVkIHRvIGJlIHJlbW92ZWQuXG4gICAgICAgICAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciBkaW1zID0gYXJjc1tkXS5kaW1zO1xuICAgICAgICAgICAgYXJjcy5hY3RpdmUgPSBkOyAvLyBJZiB0aGUgdHdvIGRpbWVuc2lvbnMgb2YgdGhlIGN1cnJlbnQgYXJjIGFyZSBub3QgbmV4dCB0byBlYWNoIG90aGVyXG4gICAgICAgICAgICAvLyBhbnkgbW9yZSwgdGhhbiB3ZSdsbCBuZWVkIHRvIHJlbW92ZSB0aGUgYXJjLiBPdGhlcndpc2Ugd2Uga2VlcCBpdC5cblxuICAgICAgICAgICAgaWYgKCFjb25zZWN1dGl2ZShkaW1zLmxlZnQsIGRpbXMucmlnaHQpKSB7XG4gICAgICAgICAgICAgIHJlbW92ZVN0cnVtKGFyY3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG9uRHJhZ0VuZChhcmNzKSgpO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gQWRkIGEgbmV3IHN2ZyBncm91cCBpbiB3aGljaCB3ZSBkcmF3IHRoZSBhcmNzLlxuXG4gICAgICBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5hcHBlbmQoJ2cnKS5hdHRyKCdpZCcsICdhcmNzJykuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgX18ubWFyZ2luLmxlZnQgKyAnLCcgKyBfXy5tYXJnaW4udG9wICsgJyknKTsgLy8gSW5zdGFsbCB0aGUgcmVxdWlyZWQgYnJ1c2hSZXNldCBmdW5jdGlvblxuXG4gICAgICBwYy5icnVzaFJlc2V0ID0gYnJ1c2hSZXNldChhcmNzKTtcbiAgICAgIGRyYWcub24oJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0KGFyY3MpKS5vbignZHJhZycsIG9uRHJhZyhhcmNzKSkub24oJ2RyYWdlbmQnLCBvbkRyYWdFbmQoYXJjcykpOyAvLyBOT1RFOiBUaGUgc3R5bGluZyBuZWVkcyB0byBiZSBkb25lIGhlcmUgYW5kIG5vdCBpbiB0aGUgY3NzLiBUaGlzIGlzIGJlY2F1c2VcbiAgICAgIC8vICAgICAgIGZvciAxRCBicnVzaGluZywgdGhlIGNhbnZhcyBsYXllcnMgc2hvdWxkIG5vdCBsaXN0ZW4gdG9cbiAgICAgIC8vICAgICAgIHBvaW50ZXItZXZlbnRzLlxuXG4gICAgICBzdHJ1bVJlY3QgPSBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5pbnNlcnQoJ3JlY3QnLCAnZyNhcmNzJykuYXR0cignaWQnLCAnYXJjLWV2ZW50cycpLmF0dHIoJ3gnLCBfXy5tYXJnaW4ubGVmdCkuYXR0cigneScsIF9fLm1hcmdpbi50b3ApLmF0dHIoJ3dpZHRoJywgdygpKS5hdHRyKCdoZWlnaHQnLCBoKCkgKyAyKS5zdHlsZSgnb3BhY2l0eScsIDApLmNhbGwoZHJhZyk7XG4gICAgfVxuXG4gICAgYnJ1c2gubW9kZXNbJ2FuZ3VsYXInXSA9IHtcbiAgICAgIGluc3RhbGw6IGluc3RhbGwsXG4gICAgICB1bmluc3RhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdnI2FyY3MnKS5yZW1vdmUoKTtcbiAgICAgICAgcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdyZWN0I2FyYy1ldmVudHMnKS5yZW1vdmUoKTtcbiAgICAgICAgcGMub24oJ2F4ZXNyZW9yZGVyLmFyY3MnLCB1bmRlZmluZWQpO1xuICAgICAgICBkZWxldGUgcGMuYnJ1c2hSZXNldDtcbiAgICAgICAgc3RydW1SZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgfSxcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgIGJydXNoU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyY3M7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcblxuICBwYy5pbnRlcmFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmbGFncy5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07IC8vIGV4cG9zZSBhIGZldyBvYmplY3RzXG5cblxuICBwYy54c2NhbGUgPSB4c2NhbGU7XG4gIHBjLnlzY2FsZSA9IHlzY2FsZTtcbiAgcGMuY3R4ID0gY3R4O1xuICBwYy5jYW52YXMgPSBjYW52YXM7XG5cbiAgcGMuZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZztcbiAgfTsgLy8gcmVzY2FsZSBmb3IgaGVpZ2h0LCB3aWR0aCBhbmQgbWFyZ2luc1xuICAvLyBUT0RPIGN1cnJlbnRseSBhc3N1bWVzIGNoYXJ0IGlzIGJydXNoYWJsZSwgYW5kIGRlc3Ryb3lzIG9sZCBicnVzaGVzXG5cblxuICBwYy5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gc2VsZWN0aW9uIHNpemVcbiAgICBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5hdHRyKCd3aWR0aCcsIF9fLndpZHRoKS5hdHRyKCdoZWlnaHQnLCBfXy5oZWlnaHQpO1xuICAgIHBjLnN2Zy5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBfXy5tYXJnaW4ubGVmdCArICcsJyArIF9fLm1hcmdpbi50b3AgKyAnKScpOyAvLyBGSVhNRTogdGhlIGN1cnJlbnQgYnJ1c2ggc3RhdGUgc2hvdWxkIHBhc3MgdGhyb3VnaFxuXG4gICAgaWYgKGZsYWdzLmJydXNoYWJsZSkgcGMuYnJ1c2hSZXNldCgpOyAvLyBzY2FsZXNcblxuICAgIHBjLmF1dG9zY2FsZSgpOyAvLyBheGVzLCBkZXN0cm95cyBvbGQgYnJ1c2hlcy5cblxuICAgIGlmIChnKSBwYy5jcmVhdGVBeGVzKCk7XG4gICAgaWYgKGZsYWdzLmJydXNoYWJsZSkgcGMuYnJ1c2hhYmxlKCk7XG4gICAgaWYgKGZsYWdzLnJlb3JkZXJhYmxlKSBwYy5yZW9yZGVyYWJsZSgpO1xuICAgIGV2ZW50cy5yZXNpemUuY2FsbCh0aGlzLCB7XG4gICAgICB3aWR0aDogX18ud2lkdGgsXG4gICAgICBoZWlnaHQ6IF9fLmhlaWdodCxcbiAgICAgIG1hcmdpbjogX18ubWFyZ2luXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07IC8vIGhpZ2hsaWdodCBhbiBhcnJheSBvZiBkYXRhXG5cblxuICBwYy5oaWdobGlnaHQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gX18uaGlnaGxpZ2h0ZWQ7XG4gICAgfVxuXG4gICAgX18uaGlnaGxpZ2h0ZWQgPSBkYXRhO1xuICAgIHBjLmNsZWFyKCdoaWdobGlnaHQnKTtcbiAgICBkMy5zZWxlY3RBbGwoW2NhbnZhcy5mb3JlZ3JvdW5kLCBjYW52YXMuYnJ1c2hlZF0pLmNsYXNzZWQoJ2ZhZGVkJywgdHJ1ZSk7XG4gICAgZGF0YS5mb3JFYWNoKHBhdGhfaGlnaGxpZ2h0KTtcbiAgICBldmVudHMuaGlnaGxpZ2h0LmNhbGwodGhpcywgZGF0YSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07IC8vIGNsZWFyIGhpZ2hsaWdodGluZ1xuXG5cbiAgcGMudW5oaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgX18uaGlnaGxpZ2h0ZWQgPSBbXTtcbiAgICBwYy5jbGVhcignaGlnaGxpZ2h0Jyk7XG4gICAgZDMuc2VsZWN0QWxsKFtjYW52YXMuZm9yZWdyb3VuZCwgY2FudmFzLmJydXNoZWRdKS5jbGFzc2VkKCdmYWRlZCcsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTsgLy8gY2FsY3VsYXRlIDJkIGludGVyc2VjdGlvbiBvZiBsaW5lIGEtPmIgd2l0aCBsaW5lIGMtPmRcbiAgLy8gcG9pbnRzIGFyZSBvYmplY3RzIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzXG5cblxuICBwYy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAoKGEueCAqIGIueSAtIGEueSAqIGIueCkgKiAoYy54IC0gZC54KSAtIChhLnggLSBiLngpICogKGMueCAqIGQueSAtIGMueSAqIGQueCkpIC8gKChhLnggLSBiLngpICogKGMueSAtIGQueSkgLSAoYS55IC0gYi55KSAqIChjLnggLSBkLngpKSxcbiAgICAgIHk6ICgoYS54ICogYi55IC0gYS55ICogYi54KSAqIChjLnkgLSBkLnkpIC0gKGEueSAtIGIueSkgKiAoYy54ICogZC55IC0gYy55ICogZC54KSkgLyAoKGEueCAtIGIueCkgKiAoYy55IC0gZC55KSAtIChhLnkgLSBiLnkpICogKGMueCAtIGQueCkpXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBwb3NpdGlvbihkKSB7XG4gICAgdmFyIHYgPSBkcmFnZ2luZ1tkXTtcbiAgICByZXR1cm4gdiA9PSBudWxsID8geHNjYWxlKGQpIDogdjtcbiAgfVxuXG4gIHBjLnZlcnNpb24gPSAnMC43LjAnOyAvLyB0aGlzIGRlc2NyaXB0aXZlIHRleHQgc2hvdWxkIGxpdmUgd2l0aCBvdGhlciBpbnRyb3NwZWN0aXZlIG1ldGhvZHNcblxuICBwYy50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ1BhcmFsbGVsIENvb3JkaW5hdGVzOiAnICsgX18uZGltZW5zaW9ucy5sZW5ndGggKyAnIGRpbWVuc2lvbnMgKCcgKyBkMy5rZXlzKF9fLmRhdGFbMF0pLmxlbmd0aCArICcgdG90YWwpICwgJyArIF9fLmRhdGEubGVuZ3RoICsgJyByb3dzJztcbiAgfTtcblxuICByZXR1cm4gcGM7XG59XG5cbmQzLnJlbmRlclF1ZXVlID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgdmFyIF9xdWV1ZSA9IFtdLFxuICAgICAgLy8gZGF0YSB0byBiZSByZW5kZXJlZFxuICBfcmF0ZSA9IDEwLFxuICAgICAgLy8gbnVtYmVyIG9mIGNhbGxzIHBlciBmcmFtZVxuICBfY2xlYXIgPSBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIC8vIGNsZWFyaW5nIGZ1bmN0aW9uXG4gIF9pID0gMDsgLy8gY3VycmVudCBpdGVyYXRpb25cblxuXG4gIHZhciBycSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKGRhdGEpIHJxLmRhdGEoZGF0YSk7XG4gICAgcnEuaW52YWxpZGF0ZSgpO1xuXG4gICAgX2NsZWFyKCk7XG5cbiAgICBycS5yZW5kZXIoKTtcbiAgfTtcblxuICBycS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgX2kgPSAwO1xuICAgIHZhciB2YWxpZCA9IHRydWU7XG5cbiAgICBycS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZG9GcmFtZSgpIHtcbiAgICAgIGlmICghdmFsaWQpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKF9pID4gX3F1ZXVlLmxlbmd0aCkgcmV0dXJuIHRydWU7IC8vIFR5cGljYWwgZDMgYmVoYXZpb3IgaXMgdG8gcGFzcyBhIGRhdGEgaXRlbSAqYW5kKiBpdHMgaW5kZXguIEFzIHRoZVxuICAgICAgLy8gcmVuZGVyIHF1ZXVlIHNwbGl0cyB0aGUgb3JpZ2luYWwgZGF0YSBzZXQsIHdlJ2xsIGhhdmUgdG8gYmUgc2xpZ2h0bHlcbiAgICAgIC8vIG1vcmUgY2FyZWZ1bGwgYWJvdXQgcGFzc2luZyB0aGUgY29ycmVjdCBpbmRleCB3aXRoIHRoZSBkYXRhIGl0ZW0uXG5cbiAgICAgIHZhciBlbmQgPSBNYXRoLm1pbihfaSArIF9yYXRlLCBfcXVldWUubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IF9pOyBpIDwgZW5kOyBpICs9IDEpIHtcbiAgICAgICAgZnVuYyhfcXVldWVbaV0sIGkpO1xuICAgICAgfVxuXG4gICAgICBfaSArPSBfcmF0ZTtcbiAgICB9XG5cbiAgICBkMy50aW1lcihkb0ZyYW1lKTtcbiAgfTtcblxuICBycS5kYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBycS5pbnZhbGlkYXRlKCk7XG4gICAgX3F1ZXVlID0gZGF0YS5zbGljZSgwKTtcbiAgICByZXR1cm4gcnE7XG4gIH07XG5cbiAgcnEucmF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIF9yYXRlO1xuICAgIF9yYXRlID0gdmFsdWU7XG4gICAgcmV0dXJuIHJxO1xuICB9O1xuXG4gIHJxLnJlbWFpbmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3F1ZXVlLmxlbmd0aCAtIF9pO1xuICB9OyAvLyBjbGVhciB0aGUgY2FudmFzXG5cblxuICBycS5jbGVhciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBfY2xlYXIoKTtcblxuICAgICAgcmV0dXJuIHJxO1xuICAgIH1cblxuICAgIF9jbGVhciA9IGZ1bmM7XG4gICAgcmV0dXJuIHJxO1xuICB9O1xuXG4gIHJxLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICByZXR1cm4gcnE7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.js\n");

/***/ }),

/***/ "./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/divgrid.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/divgrid.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* [LICENSE TBD] */\n\n/* eslint-disable */\n// from http://bl.ocks.org/3687826\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(config) {\n  var columns = [];\n\n  var dg = function (selection) {\n    if (columns.length == 0) columns = d3.keys(selection.data()[0][0]); // header\n\n    selection.selectAll('.header').data([true]).enter().append('div').attr('class', 'header');\n    var header = selection.select('.header').selectAll('.cell').data(columns);\n    header.enter().append('div').attr('class', function (d, i) {\n      return 'col-' + i;\n    }).classed('cell', true);\n    selection.selectAll('.header .cell').text(function (d) {\n      return d;\n    });\n    header.exit().remove(); // rows\n\n    var rows = selection.selectAll('.row').data(function (d) {\n      return d;\n    });\n    rows.enter().append('div').attr('class', 'row');\n    rows.exit().remove();\n    var cells = selection.selectAll('.row').selectAll('.cell').data(function (d) {\n      return columns.map(function (col) {\n        return d[col];\n      });\n    }); // cells\n\n    cells.enter().append('div').attr('class', function (d, i) {\n      return 'col-' + i;\n    }).classed('cell', true);\n    cells.exit().remove();\n    selection.selectAll('.cell').text(function (d) {\n      return d;\n    });\n    return dg;\n  };\n\n  dg.columns = function (_) {\n    if (!arguments.length) return columns;\n    columns = _;\n    return this;\n  };\n\n  return dg;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL3ZlbmRvci9wYXJjb29yZHMvZGl2Z3JpZC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vbm9kZV9tb2R1bGVzL0BzdXBlcnNldC11aS9sZWdhY3ktcGx1Z2luLWNoYXJ0LXBhcmFsbGVsLWNvb3JkaW5hdGVzL2VzbS92ZW5kb3IvcGFyY29vcmRzL2RpdmdyaWQuanM/MDlhMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBbTElDRU5TRSBUQkRdICovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBmcm9tIGh0dHA6Ly9ibC5vY2tzLm9yZy8zNjg3ODI2XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBjb2x1bW5zID0gW107XG5cbiAgdmFyIGRnID0gZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgIGlmIChjb2x1bW5zLmxlbmd0aCA9PSAwKSBjb2x1bW5zID0gZDMua2V5cyhzZWxlY3Rpb24uZGF0YSgpWzBdWzBdKTsgLy8gaGVhZGVyXG5cbiAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKCcuaGVhZGVyJykuZGF0YShbdHJ1ZV0pLmVudGVyKCkuYXBwZW5kKCdkaXYnKS5hdHRyKCdjbGFzcycsICdoZWFkZXInKTtcbiAgICB2YXIgaGVhZGVyID0gc2VsZWN0aW9uLnNlbGVjdCgnLmhlYWRlcicpLnNlbGVjdEFsbCgnLmNlbGwnKS5kYXRhKGNvbHVtbnMpO1xuICAgIGhlYWRlci5lbnRlcigpLmFwcGVuZCgnZGl2JykuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgcmV0dXJuICdjb2wtJyArIGk7XG4gICAgfSkuY2xhc3NlZCgnY2VsbCcsIHRydWUpO1xuICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoJy5oZWFkZXIgLmNlbGwnKS50ZXh0KGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZDtcbiAgICB9KTtcbiAgICBoZWFkZXIuZXhpdCgpLnJlbW92ZSgpOyAvLyByb3dzXG5cbiAgICB2YXIgcm93cyA9IHNlbGVjdGlvbi5zZWxlY3RBbGwoJy5yb3cnKS5kYXRhKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZDtcbiAgICB9KTtcbiAgICByb3dzLmVudGVyKCkuYXBwZW5kKCdkaXYnKS5hdHRyKCdjbGFzcycsICdyb3cnKTtcbiAgICByb3dzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICB2YXIgY2VsbHMgPSBzZWxlY3Rpb24uc2VsZWN0QWxsKCcucm93Jykuc2VsZWN0QWxsKCcuY2VsbCcpLmRhdGEoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgIHJldHVybiBkW2NvbF07XG4gICAgICB9KTtcbiAgICB9KTsgLy8gY2VsbHNcblxuICAgIGNlbGxzLmVudGVyKCkuYXBwZW5kKCdkaXYnKS5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICByZXR1cm4gJ2NvbC0nICsgaTtcbiAgICB9KS5jbGFzc2VkKCdjZWxsJywgdHJ1ZSk7XG4gICAgY2VsbHMuZXhpdCgpLnJlbW92ZSgpO1xuICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoJy5jZWxsJykudGV4dChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRnO1xuICB9O1xuXG4gIGRnLmNvbHVtbnMgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbHVtbnM7XG4gICAgY29sdW1ucyA9IF87XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIGRnO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/divgrid.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css":
/*!************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css ***!
  \************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../css-loader/dist/runtime/cssWithMappingToString.js */ \"./node_modules/css-loader/dist/runtime/cssWithMappingToString.js\");\n/* harmony import */ var _css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/* [LICENSE TBD] */\\n.parcoords svg,\\n.parcoords canvas {\\n  font-size: 12px;\\n  position: absolute;\\n}\\n.parcoords > canvas {\\n  pointer-events: none;\\n}\\n\\n.parcoords text.label {\\n  font: 100%;\\n  font-size: 12px;\\n  cursor: drag;\\n}\\n\\n.parcoords rect.background {\\n  fill: transparent;\\n}\\n.parcoords rect.background:hover {\\n  fill: rgba(120, 120, 120, 0.2);\\n}\\n.parcoords .resize rect {\\n  fill: rgba(0, 0, 0, 0.1);\\n}\\n.parcoords rect.extent {\\n  fill: rgba(255, 255, 255, 0.25);\\n  stroke: rgba(0, 0, 0, 0.6);\\n}\\n.parcoords .axis line,\\n.parcoords .axis path {\\n  fill: none;\\n  stroke: #222;\\n  shape-rendering: crispEdges;\\n}\\n.parcoords canvas {\\n  opacity: 1;\\n  -moz-transition: opacity 0.3s;\\n  -webkit-transition: opacity 0.3s;\\n  -o-transition: opacity 0.3s;\\n}\\n.parcoords canvas.faded {\\n  opacity: 0.25;\\n}\\n.parcoords {\\n  -webkit-touch-callout: none;\\n  -webkit-user-select: none;\\n  -khtml-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n  background-color: white;\\n}\\n\\n/* data table styles */\\n.parcoords .row,\\n.parcoords .header {\\n  clear: left;\\n  font-size: 12px;\\n  line-height: 18px;\\n  height: 18px;\\n  margin: 0px;\\n}\\n.parcoords .row:nth-child(odd) {\\n  background: rgba(0, 0, 0, 0.05);\\n}\\n.parcoords .header {\\n  font-weight: bold;\\n}\\n.parcoords .cell {\\n  float: left;\\n  overflow: hidden;\\n  white-space: nowrap;\\n  width: 100px;\\n  height: 18px;\\n}\\n.parcoords .col-0 {\\n  width: 180px;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css\"],\"names\":[],\"mappings\":\"AAAA,kBAAkB;AAClB;;EAEE,eAAe;EACf,kBAAkB;AACpB;AACA;EACE,oBAAoB;AACtB;;AAEA;EACE,UAAU;EACV,eAAe;EACf,YAAY;AACd;;AAEA;EACE,iBAAiB;AACnB;AACA;EACE,8BAA8B;AAChC;AACA;EACE,wBAAwB;AAC1B;AACA;EACE,+BAA+B;EAC/B,0BAA0B;AAC5B;AACA;;EAEE,UAAU;EACV,YAAY;EACZ,2BAA2B;AAC7B;AACA;EACE,UAAU;EACV,6BAA6B;EAC7B,gCAAgC;EAChC,2BAA2B;AAC7B;AACA;EACE,aAAa;AACf;AACA;EACE,2BAA2B;EAC3B,yBAAyB;EACzB,wBAAwB;EACxB,sBAAsB;EACtB,qBAAqB;EACrB,iBAAiB;EACjB,uBAAuB;AACzB;;AAEA,sBAAsB;AACtB;;EAEE,WAAW;EACX,eAAe;EACf,iBAAiB;EACjB,YAAY;EACZ,WAAW;AACb;AACA;EACE,+BAA+B;AACjC;AACA;EACE,iBAAiB;AACnB;AACA;EACE,WAAW;EACX,gBAAgB;EAChB,mBAAmB;EACnB,YAAY;EACZ,YAAY;AACd;AACA;EACE,YAAY;AACd\",\"sourcesContent\":[\"/* [LICENSE TBD] */\\n.parcoords svg,\\n.parcoords canvas {\\n  font-size: 12px;\\n  position: absolute;\\n}\\n.parcoords > canvas {\\n  pointer-events: none;\\n}\\n\\n.parcoords text.label {\\n  font: 100%;\\n  font-size: 12px;\\n  cursor: drag;\\n}\\n\\n.parcoords rect.background {\\n  fill: transparent;\\n}\\n.parcoords rect.background:hover {\\n  fill: rgba(120, 120, 120, 0.2);\\n}\\n.parcoords .resize rect {\\n  fill: rgba(0, 0, 0, 0.1);\\n}\\n.parcoords rect.extent {\\n  fill: rgba(255, 255, 255, 0.25);\\n  stroke: rgba(0, 0, 0, 0.6);\\n}\\n.parcoords .axis line,\\n.parcoords .axis path {\\n  fill: none;\\n  stroke: #222;\\n  shape-rendering: crispEdges;\\n}\\n.parcoords canvas {\\n  opacity: 1;\\n  -moz-transition: opacity 0.3s;\\n  -webkit-transition: opacity 0.3s;\\n  -o-transition: opacity 0.3s;\\n}\\n.parcoords canvas.faded {\\n  opacity: 0.25;\\n}\\n.parcoords {\\n  -webkit-touch-callout: none;\\n  -webkit-user-select: none;\\n  -khtml-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n  background-color: white;\\n}\\n\\n/* data table styles */\\n.parcoords .row,\\n.parcoords .header {\\n  clear: left;\\n  font-size: 12px;\\n  line-height: 18px;\\n  height: 18px;\\n  margin: 0px;\\n}\\n.parcoords .row:nth-child(odd) {\\n  background: rgba(0, 0, 0, 0.05);\\n}\\n.parcoords .header {\\n  font-weight: bold;\\n}\\n.parcoords .cell {\\n  float: left;\\n  overflow: hidden;\\n  white-space: nowrap;\\n  width: 100px;\\n  height: 18px;\\n}\\n.parcoords .col-0 {\\n  width: 180px;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS51c2VbMV0hLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmNzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vbm9kZV9tb2R1bGVzL0BzdXBlcnNldC11aS9sZWdhY3ktcGx1Z2luLWNoYXJ0LXBhcmFsbGVsLWNvb3JkaW5hdGVzL2VzbS92ZW5kb3IvcGFyY29vcmRzL2QzLnBhcmNvb3Jkcy5jc3M/YWVkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIvKiBbTElDRU5TRSBUQkRdICovXFxuLnBhcmNvb3JkcyBzdmcsXFxuLnBhcmNvb3JkcyBjYW52YXMge1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG4ucGFyY29vcmRzID4gY2FudmFzIHtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cXG4ucGFyY29vcmRzIHRleHQubGFiZWwge1xcbiAgZm9udDogMTAwJTtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGN1cnNvcjogZHJhZztcXG59XFxuXFxuLnBhcmNvb3JkcyByZWN0LmJhY2tncm91bmQge1xcbiAgZmlsbDogdHJhbnNwYXJlbnQ7XFxufVxcbi5wYXJjb29yZHMgcmVjdC5iYWNrZ3JvdW5kOmhvdmVyIHtcXG4gIGZpbGw6IHJnYmEoMTIwLCAxMjAsIDEyMCwgMC4yKTtcXG59XFxuLnBhcmNvb3JkcyAucmVzaXplIHJlY3Qge1xcbiAgZmlsbDogcmdiYSgwLCAwLCAwLCAwLjEpO1xcbn1cXG4ucGFyY29vcmRzIHJlY3QuZXh0ZW50IHtcXG4gIGZpbGw6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yNSk7XFxuICBzdHJva2U6IHJnYmEoMCwgMCwgMCwgMC42KTtcXG59XFxuLnBhcmNvb3JkcyAuYXhpcyBsaW5lLFxcbi5wYXJjb29yZHMgLmF4aXMgcGF0aCB7XFxuICBmaWxsOiBub25lO1xcbiAgc3Ryb2tlOiAjMjIyO1xcbiAgc2hhcGUtcmVuZGVyaW5nOiBjcmlzcEVkZ2VzO1xcbn1cXG4ucGFyY29vcmRzIGNhbnZhcyB7XFxuICBvcGFjaXR5OiAxO1xcbiAgLW1vei10cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3M7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgMC4zcztcXG4gIC1vLXRyYW5zaXRpb246IG9wYWNpdHkgMC4zcztcXG59XFxuLnBhcmNvb3JkcyBjYW52YXMuZmFkZWQge1xcbiAgb3BhY2l0eTogMC4yNTtcXG59XFxuLnBhcmNvb3JkcyB7XFxuICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLWtodG1sLXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxufVxcblxcbi8qIGRhdGEgdGFibGUgc3R5bGVzICovXFxuLnBhcmNvb3JkcyAucm93LFxcbi5wYXJjb29yZHMgLmhlYWRlciB7XFxuICBjbGVhcjogbGVmdDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGxpbmUtaGVpZ2h0OiAxOHB4O1xcbiAgaGVpZ2h0OiAxOHB4O1xcbiAgbWFyZ2luOiAwcHg7XFxufVxcbi5wYXJjb29yZHMgLnJvdzpudGgtY2hpbGQob2RkKSB7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuMDUpO1xcbn1cXG4ucGFyY29vcmRzIC5oZWFkZXIge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcbi5wYXJjb29yZHMgLmNlbGwge1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIHdpZHRoOiAxMDBweDtcXG4gIGhlaWdodDogMThweDtcXG59XFxuLnBhcmNvb3JkcyAuY29sLTAge1xcbiAgd2lkdGg6IDE4MHB4O1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSxrQkFBa0I7QUFDbEI7O0VBRUUsZUFBZTtFQUNmLGtCQUFrQjtBQUNwQjtBQUNBO0VBQ0Usb0JBQW9CO0FBQ3RCOztBQUVBO0VBQ0UsVUFBVTtFQUNWLGVBQWU7RUFDZixZQUFZO0FBQ2Q7O0FBRUE7RUFDRSxpQkFBaUI7QUFDbkI7QUFDQTtFQUNFLDhCQUE4QjtBQUNoQztBQUNBO0VBQ0Usd0JBQXdCO0FBQzFCO0FBQ0E7RUFDRSwrQkFBK0I7RUFDL0IsMEJBQTBCO0FBQzVCO0FBQ0E7O0VBRUUsVUFBVTtFQUNWLFlBQVk7RUFDWiwyQkFBMkI7QUFDN0I7QUFDQTtFQUNFLFVBQVU7RUFDViw2QkFBNkI7RUFDN0IsZ0NBQWdDO0VBQ2hDLDJCQUEyQjtBQUM3QjtBQUNBO0VBQ0UsYUFBYTtBQUNmO0FBQ0E7RUFDRSwyQkFBMkI7RUFDM0IseUJBQXlCO0VBQ3pCLHdCQUF3QjtFQUN4QixzQkFBc0I7RUFDdEIscUJBQXFCO0VBQ3JCLGlCQUFpQjtFQUNqQix1QkFBdUI7QUFDekI7O0FBRUEsc0JBQXNCO0FBQ3RCOztFQUVFLFdBQVc7RUFDWCxlQUFlO0VBQ2YsaUJBQWlCO0VBQ2pCLFlBQVk7RUFDWixXQUFXO0FBQ2I7QUFDQTtFQUNFLCtCQUErQjtBQUNqQztBQUNBO0VBQ0UsaUJBQWlCO0FBQ25CO0FBQ0E7RUFDRSxXQUFXO0VBQ1gsZ0JBQWdCO0VBQ2hCLG1CQUFtQjtFQUNuQixZQUFZO0VBQ1osWUFBWTtBQUNkO0FBQ0E7RUFDRSxZQUFZO0FBQ2RcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLyogW0xJQ0VOU0UgVEJEXSAqL1xcbi5wYXJjb29yZHMgc3ZnLFxcbi5wYXJjb29yZHMgY2FudmFzIHtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuLnBhcmNvb3JkcyA+IGNhbnZhcyB7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXFxuLnBhcmNvb3JkcyB0ZXh0LmxhYmVsIHtcXG4gIGZvbnQ6IDEwMCU7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBjdXJzb3I6IGRyYWc7XFxufVxcblxcbi5wYXJjb29yZHMgcmVjdC5iYWNrZ3JvdW5kIHtcXG4gIGZpbGw6IHRyYW5zcGFyZW50O1xcbn1cXG4ucGFyY29vcmRzIHJlY3QuYmFja2dyb3VuZDpob3ZlciB7XFxuICBmaWxsOiByZ2JhKDEyMCwgMTIwLCAxMjAsIDAuMik7XFxufVxcbi5wYXJjb29yZHMgLnJlc2l6ZSByZWN0IHtcXG4gIGZpbGw6IHJnYmEoMCwgMCwgMCwgMC4xKTtcXG59XFxuLnBhcmNvb3JkcyByZWN0LmV4dGVudCB7XFxuICBmaWxsOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMjUpO1xcbiAgc3Ryb2tlOiByZ2JhKDAsIDAsIDAsIDAuNik7XFxufVxcbi5wYXJjb29yZHMgLmF4aXMgbGluZSxcXG4ucGFyY29vcmRzIC5heGlzIHBhdGgge1xcbiAgZmlsbDogbm9uZTtcXG4gIHN0cm9rZTogIzIyMjtcXG4gIHNoYXBlLXJlbmRlcmluZzogY3Jpc3BFZGdlcztcXG59XFxuLnBhcmNvb3JkcyBjYW52YXMge1xcbiAgb3BhY2l0eTogMTtcXG4gIC1tb3otdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzO1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3M7XFxuICAtby10cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3M7XFxufVxcbi5wYXJjb29yZHMgY2FudmFzLmZhZGVkIHtcXG4gIG9wYWNpdHk6IDAuMjU7XFxufVxcbi5wYXJjb29yZHMge1xcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lO1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1raHRtbC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbn1cXG5cXG4vKiBkYXRhIHRhYmxlIHN0eWxlcyAqL1xcbi5wYXJjb29yZHMgLnJvdyxcXG4ucGFyY29vcmRzIC5oZWFkZXIge1xcbiAgY2xlYXI6IGxlZnQ7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBsaW5lLWhlaWdodDogMThweDtcXG4gIGhlaWdodDogMThweDtcXG4gIG1hcmdpbjogMHB4O1xcbn1cXG4ucGFyY29vcmRzIC5yb3c6bnRoLWNoaWxkKG9kZCkge1xcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjA1KTtcXG59XFxuLnBhcmNvb3JkcyAuaGVhZGVyIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG4ucGFyY29vcmRzIC5jZWxsIHtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICB3aWR0aDogMTAwcHg7XFxuICBoZWlnaHQ6IDE4cHg7XFxufVxcbi5wYXJjb29yZHMgLmNvbC0wIHtcXG4gIHdpZHRoOiAxODBweDtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \"\"]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcz8yNGZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/cssWithMappingToString.js ***!
  \************************************************************************/
/***/ ((module) => {

eval("\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nmodule.exports = function cssWithMappingToString(item) {\n  var _item = _slicedToArray(item, 4),\n      content = _item[1],\n      cssMapping = _item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzPzc1ZTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTsgaWYgKF9pID09IG51bGwpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfcywgX2U7IHRyeSB7IGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pIHtcbiAgdmFyIF9pdGVtID0gX3NsaWNlZFRvQXJyYXkoaXRlbSwgNCksXG4gICAgICBjb250ZW50ID0gX2l0ZW1bMV0sXG4gICAgICBjc3NNYXBwaW5nID0gX2l0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShjc3NNYXBwaW5nKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCBcIlwiKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/cssWithMappingToString.js\n");

/***/ }),

/***/ "./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

eval("/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../../../style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../../../style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../../../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../../../style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../../../style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _css_loader_dist_cjs_js_ruleSet_1_rules_3_use_1_d3_parcoords_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../../../css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!./d3.parcoords.css */ \"./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_ruleSet_1_rules_3_use_1_d3_parcoords_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_ruleSet_1_rules_3_use_1_d3_parcoords_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _css_loader_dist_cjs_js_ruleSet_1_rules_3_use_1_d3_parcoords_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _css_loader_dist_cjs_js_ruleSet_1_rules_3_use_1_d3_parcoords_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmNzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3VwZXJzZXQvLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmNzcz81YTgwIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICAgaW1wb3J0IEFQSSBmcm9tIFwiIS4uLy4uLy4uLy4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICBpbXBvcnQgZG9tQVBJIGZyb20gXCIhLi4vLi4vLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydEZuIGZyb20gXCIhLi4vLi4vLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzXCI7XG4gICAgICBpbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tIFwiIS4uLy4uLy4uLy4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0U3R5bGVFbGVtZW50IGZyb20gXCIhLi4vLi4vLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcIjtcbiAgICAgIGltcG9ydCBzdHlsZVRhZ1RyYW5zZm9ybUZuIGZyb20gXCIhLi4vLi4vLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1wiO1xuICAgICAgaW1wb3J0IGNvbnRlbnQsICogYXMgbmFtZWRFeHBvcnQgZnJvbSBcIiEhLi4vLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS51c2VbMV0hLi9kMy5wYXJjb29yZHMuY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5cbiAgICAgIG9wdGlvbnMuaW5zZXJ0ID0gaW5zZXJ0Rm4uYmluZChudWxsLCBcImhlYWRcIik7XG4gICAgXG5vcHRpb25zLmRvbUFQSSA9IGRvbUFQSTtcbm9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50ID0gaW5zZXJ0U3R5bGVFbGVtZW50O1xuXG52YXIgdXBkYXRlID0gQVBJKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0ICogZnJvbSBcIiEhLi4vLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS51c2VbMV0hLi9kMy5wYXJjb29yZHMuY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcz8yZGJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3R5bGVzSW5Eb20gPSBbXTtcblxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRvbS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdXG4gICAgfTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXNJbkRvbS5wdXNoKHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogYWRkU3R5bGUob2JqLCBvcHRpb25zKSxcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBhcGkgPSBvcHRpb25zLmRvbUFQSShvcHRpb25zKTtcbiAgYXBpLnVwZGF0ZShvYmopO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFwaS51cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRG9tW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRvbVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qcz9iMjE0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVtbyA9IHt9O1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cbmZ1bmN0aW9uIGdldFRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gIH1cblxuICByZXR1cm4gbWVtb1t0YXJnZXRdO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxuZnVuY3Rpb24gaW5zZXJ0QnlTZWxlY3RvcihpbnNlcnQsIHN0eWxlKSB7XG4gIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoaW5zZXJ0KTtcblxuICBpZiAoIXRhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gIH1cblxuICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEJ5U2VsZWN0b3I7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/insertBySelector.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var style = document.createElement(\"style\");\n  options.setAttributes(style, options.attributes);\n  options.insert(style);\n  return style;\n}\n\nmodule.exports = insertStyleElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzP2RlNmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBvcHRpb25zLnNldEF0dHJpYnV0ZXMoc3R5bGUsIG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydFN0eWxlRWxlbWVudDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/insertStyleElement.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(style) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n\n  if (nonce) {\n    style.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3VwZXJzZXQvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanM/ZGRjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMoc3R5bGUpIHtcbiAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlczsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction apply(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute(\"media\", media);\n  } else {\n    style.removeAttribute(\"media\");\n  }\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, style);\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var style = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(style, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(style);\n    }\n  };\n}\n\nmodule.exports = domAPI;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzP2U0NzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gYXBwbHkoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKFwibWVkaWFcIik7XG4gIH1cblxuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIG9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbmZ1bmN0aW9uIGRvbUFQSShvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IG9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9iaikge1xuICAgICAgYXBwbHkoc3R5bGUsIG9wdGlvbnMsIG9iaik7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRvbUFQSTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/styleDomAPI.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, style) {\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanM/MWRkZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlKSB7XG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWxlVGFnVHJhbnNmb3JtOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/styleTagTransform.js\n");

/***/ })

}]);