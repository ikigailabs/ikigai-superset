"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[1609,3348],{71609:(t,e,o)=>{o.r(e),o.d(e,{default:()=>w});var n=o(18446),a=o.n(n),i=o(67294),r=o(31069),s=o(85716),l=o(34634),c=o(54998),u=o.n(c);function g(t,e,o=!0,n={}){if(!t.datasource)return;const a=new(u())("/"),i=function(t="base"){let e="/explore/";return["json","csv","query","results","samples"].includes(t)&&(e="/superset/explore_json/"),e}(e),r=a.search(!0);Object.keys(n).forEach((t=>{r[t]=n[t]})),r.form_data=function(t){const e=new Set;return JSON.stringify(t,((t,o)=>{if("object"==typeof o&&null!==o){if(e.has(o))try{return JSON.parse(JSON.stringify(o))}catch(t){return}e.add(o)}return o}))}(t),"standalone"===e&&(r.standalone="true");const s=a.directory(i).search(r).toString();return!o&&s.length>8e3?g({datasource:t.datasource,viz_type:t.viz_type},e,!1,{URL_IS_TOO_LONG_TO_SHARE:null}):s}var d=o(72502),p=o(42932),h=o(97874),m=o(58125),v=o(61778),f=o(1262),x=o(9503),_=o(61296),y=o(2429),S=o(73348);const P={deck_grid:d.getLayer,deck_screengrid:p.getLayer,deck_path:h.getLayer,deck_hex:m.getLayer,deck_scatter:v.getLayer,deck_geojson:f.getLayer,deck_arc:x.getLayer,deck_polygon:_.getLayer,deck_heatmap:y.getLayer,deck_contour:S.getLayer};var C=o(11965);const b=t=>{const e=(0,i.useRef)(),[o,n]=(0,i.useState)(),[c,u]=(0,i.useState)({}),d=(0,i.useCallback)((t=>{const{current:o}=e;o&&o.setTooltip(t)}),[]),p=(0,i.useCallback)(((e,o,a)=>{n(a),u({}),o.data.slices.forEach((o=>{const n=[...o.form_data.filters||[],...e.filters||[],...e.extra_filters||[]],a={...o,form_data:{...o.form_data,filters:n}},i=g(a.form_data,"json");i&&r.Z.get({endpoint:i}).then((({json:e})=>{const o=P[a.form_data.viz_type](a.form_data,e,t.onAddFilter,d,t.datasource,[],t.onSelect);u((t=>({...t,[a.slice_id]:o})))})).catch((()=>{}))}))}),[t.datasource,t.onAddFilter,t.onSelect,d]),h=(0,s.D)(t.formData.deck_slices);(0,i.useEffect)((()=>{const{formData:e,payload:o}=t;!a()(h,e.deck_slices)&&p(e,o)}),[p,h,t]);const{payload:m,formData:v,setControlValue:f,height:x,width:_}=t,y=Object.values(c);return(0,C.tZ)(l.F,{ref:e,mapboxApiAccessToken:m.data.mapboxApiKey,viewport:o||t.viewport,layers:y,mapStyle:v.mapbox_style,setControlValue:f,onViewportChange:n,height:x,width:_})},w=(0,i.memo)(b)},9503:(t,e,o)=>{o.r(e),o.d(e,{default:()=>_,getLayer:()=>x});var n=o(4942),a=o(5259),i=o(37832),r=o(13717),s=o(33321),l=o(39769),c=o(53982);const u=[0,0,0,255],g={getSourcePosition:{type:"accessor",value:t=>t.sourcePosition},getTargetPosition:{type:"accessor",value:t=>t.targetPosition},getSourceColor:{type:"accessor",value:u},getTargetColor:{type:"accessor",value:u},getWidth:{type:"accessor",value:1},getHeight:{type:"accessor",value:1},getTilt:{type:"accessor",value:0},greatCircle:!1,widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}};class d extends a.Z{constructor(...t){super(...t),(0,n.Z)(this,"state",void 0)}getBounds(){var t;return null===(t=this.getAttributeManager())||void 0===t?void 0:t.getBounds(["instanceSourcePositions","instanceTargetPositions"])}getShaders(){return super.getShaders({vs:"#define SHADER_NAME arc-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\nattribute float instanceHeights;\nattribute float instanceTilts;\n\nuniform bool greatCircle;\nuniform bool useShortestPath;\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform int widthUnits;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nfloat paraboloid(float distance, float sourceZ, float targetZ, float ratio) {\n\n  float deltaZ = targetZ - sourceZ;\n  float dh = distance * instanceHeights;\n  if (dh == 0.0) {\n    return sourceZ + deltaZ * ratio;\n  }\n  float unitZ = deltaZ / dh;\n  float p2 = unitZ * unitZ + 1.0;\n  float dir = step(deltaZ, 0.0);\n  float z0 = mix(sourceZ, targetZ, dir);\n  float r = mix(ratio, 1.0 - ratio, dir);\n  return sqrt(r * (p2 - r)) * dh + z0;\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {\n  float distance = length(source.xy - target.xy);\n  float z = paraboloid(distance, source.z, target.z, segmentRatio);\n\n  float tiltAngle = radians(instanceTilts);\n  vec2 tiltDirection = normalize(target.xy - source.xy);\n  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\n\n  return vec3(\n    mix(source.xy, target.xy, segmentRatio) + tilt,\n    z * cos(tiltAngle)\n  );\n}\nfloat getAngularDist (vec2 source, vec2 target) {\n  vec2 sourceRadians = radians(source);\n  vec2 targetRadians = radians(target);\n  vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);\n  vec2 shd_sq = sin_half_delta * sin_half_delta;\n\n  float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;\n  return 2.0 * asin(sqrt(a));\n}\n\nvec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {\n  vec2 lngLat;\n  if(abs(angularDist - PI) < 0.001) {\n    lngLat = (1.0 - t) * source.xy + t * target.xy;\n  } else {\n    float a = sin((1.0 - t) * angularDist);\n    float b = sin(t * angularDist);\n    vec3 p = source3D.yxz * a + target3D.yxz * b;\n    lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));\n  }\n\n  float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);\n\n  return vec3(lngLat, z);\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));\n  float nextSegmentRatio = getSegmentRatio(min(numSegments - 1.0, segmentIndex + 1.0));\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  isValid = 1.0;\n\n  uv = vec2(segmentRatio, positions.y);\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n\n  vec4 curr;\n  vec4 next;\n  vec3 source;\n  vec3 target;\n\n  if ((greatCircle || project_uProjectionMode == PROJECTION_MODE_GLOBE) && project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n    source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));\n    target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));\n    float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);\n\n    vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);\n    vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);\n    vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);\n\n    if (abs(currPos.x - prevPos.x) > 180.0) {\n      indexDir = -1.0;\n      isValid = 0.0;\n    } else if (abs(currPos.x - nextPos.x) > 180.0) {\n      indexDir = 1.0;\n      isValid = 0.0;\n    }\n    nextPos = indexDir < 0.0 ? prevPos : nextPos;\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n\n    if (isValid == 0.0) {\n      nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;\n      float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);\n      currPos = mix(currPos, nextPos, t);\n      segmentRatio = mix(segmentRatio, nextSegmentRatio, t);\n    }\n\n    vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);\n    vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);\n  \n    curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);\n    next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\n  \n  } else {\n    vec3 source_world = instanceSourcePositions;\n    vec3 target_world = instanceTargetPositions;\n    if (useShortestPath) {\n      source_world.x = mod(source_world.x + 180., 360.0) - 180.;\n      target_world.x = mod(target_world.x + 180., 360.0) - 180.;\n\n      float deltaLng = target_world.x - source_world.x;\n      if (deltaLng > 180.) target_world.x -= 360.;\n      if (deltaLng < -180.) source_world.x -= 360.;\n    }\n    source = project_position(source_world, instanceSourcePositions64Low);\n    target = project_position(target_world, instanceTargetPositions64Low);\n    float antiMeridianX = 0.0;\n\n    if (useShortestPath) {\n      if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n        antiMeridianX = -(project_uCoordinateOrigin.x + 180.) / 360. * TILE_SIZE;\n      }\n      float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);\n\n      if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {\n        isValid = 0.0;\n        indexDir = sign(segmentRatio - thresholdRatio);\n        segmentRatio = thresholdRatio;\n      }\n    }\n\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n    vec3 currPos = interpolateFlat(source, target, segmentRatio);\n    vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);\n\n    if (useShortestPath) {\n      if (nextPos.x < antiMeridianX) {\n        currPos.x += TILE_SIZE;\n        nextPos.x += TILE_SIZE;\n      }\n    }\n\n    curr = project_common_position_to_clipspace(vec4(currPos, 1.0));\n    next = project_common_position_to_clipspace(vec4(nextPos, 1.0));\n    geometry.position = vec4(currPos, 1.0);\n  }\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels\n  );\n  vec3 offset = vec3(\n    getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  DECKGL_FILTER_GL_POSITION(curr, geometry);\n  gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);\n  vColor = vec4(color.rgb, color.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME arc-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nvoid main(void) {\n  if (isValid == 0.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  geometry.uv = uv;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[i.Z,r.Z]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceSourceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getSourceColor",defaultValue:u},instanceTargetColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getTargetColor",defaultValue:u},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1},instanceHeights:{size:1,transition:!0,accessor:"getHeight",defaultValue:1},instanceTilts:{size:1,transition:!0,accessor:"getTilt",defaultValue:0}})}updateState(t){if(super.updateState(t),t.changeFlags.extensionsChanged){var e;const{gl:t}=this.context;null===(e=this.state.model)||void 0===e||e.delete(),this.state.model=this._getModel(t),this.getAttributeManager().invalidateAll()}}draw({uniforms:t}){const{widthUnits:e,widthScale:o,widthMinPixels:n,widthMaxPixels:a,greatCircle:i,wrapLongitude:r}=this.props;this.state.model.setUniforms(t).setUniforms({greatCircle:i,widthUnits:s.iI[e],widthScale:o,widthMinPixels:n,widthMaxPixels:a,useShortestPath:r}).draw()}_getModel(t){let e=[];for(let t=0;t<50;t++)e=e.concat([t,1,0,t,-1,0]);const o=new l.Z(t,{...this.getShaders(),id:this.props.id,geometry:new c.Z({drawMode:5,attributes:{positions:new Float32Array(e)}}),isInstanced:!0});return o.setUniforms({numSegments:50}),o}}(0,n.Z)(d,"layerName","ArcLayer"),(0,n.Z)(d,"defaultProps",g),o(67294);var p=o(61988),h=o(58371),m=o(89691),v=o(51805),f=o(11965);function x(t,e,o,n){const a=e.data.features,i=t.color_picker,r=t.target_color_picker;return new d({data:a,getSourceColor:t=>t.sourceColor||t.color||[i.r,i.g,i.b,255*i.a],getTargetColor:t=>t.targetColor||t.color||[r.r,r.g,r.b,255*r.a],id:`path-layer-${t.slice_id}`,strokeWidth:t.stroke_width?t.stroke_width:3,...(0,h.N)(t,n,(s=t,t=>{var e,o,n,a,i,r,l,c,u;return(0,f.tZ)("div",{className:"deckgl-tooltip"},(0,f.tZ)(v.Z,{label:(0,p.t)("Start (Longitude, Latitude): "),value:`${null==(e=t.object)||null==(o=e.sourcePosition)?void 0:o[0]}, ${null==(n=t.object)||null==(a=n.sourcePosition)?void 0:a[1]}`}),(0,f.tZ)(v.Z,{label:(0,p.t)("End (Longitude, Latitude): "),value:`${null==(i=t.object)||null==(r=i.targetPosition)?void 0:r[0]}, ${null==(l=t.object)||null==(c=l.targetPosition)?void 0:c[1]}`}),s.dimension&&(0,f.tZ)(v.Z,{label:`${null==s?void 0:s.dimension}: `,value:`${null==(u=t.object)?void 0:u.cat_color}`}))}))});var s}const _=(0,m.B)(x,(function(t){const e=[];return t.forEach((t=>{e.push(t.sourcePosition),e.push(t.targetPosition)})),e}))},73348:(t,e,o)=>{o.r(e),o.d(e,{default:()=>d,getLayer:()=>g});var n=o(92219),a=(o(67294),o(61988)),i=o(58371),r=o(63241),s=o(89691),l=o(51805),c=o(11965);function u(t){var e,o;return(0,c.tZ)("div",{className:"deckgl-tooltip"},(0,c.tZ)(l.Z,{label:(0,a.t)("Centroid (Longitude and Latitude): "),value:`(${null==t?void 0:t.coordinate[0]}, ${null==t?void 0:t.coordinate[1]})`}),(0,c.tZ)(l.Z,{label:(0,a.t)("Threshold: "),value:`${null==t||null==(e=t.object)||null==(o=e.contour)?void 0:o.threshold}`}))}const g=function(t,e,o,a){const s=t,{aggregation:l="SUM",js_data_mutator:c,contours:g,cellSize:d="200"}=s;let p=e.data.features;const h=null==g?void 0:g.map((t=>{const{lowerThreshold:e,upperThreshold:o,color:n,strokeWidth:a}=t;return o?{threshold:[e,o],color:[n.r,n.g,n.b]}:{threshold:e,color:[n.r,n.g,n.b],strokeWidth:a}}));return c&&(p=(0,r.Z)(s.js_data_mutator)(p)),new n.Z({id:`contourLayer-${s.slice_id}`,data:p,contours:h,cellSize:Number(d||"200"),aggregation:l.toUpperCase(),getPosition:t=>t.position,getWeight:t=>t.weight||0,...(0,i.N)(s,a,u)})},d=(0,s.G)(g,(function(t){return t.map((t=>t.position))}))},1262:(t,e,o)=>{o.r(e),o.d(e,{default:()=>C,getLayer:()=>S});var n=o(67294),a=o(69588),i=o(29319),r=o.n(i),s=o(34634),l=o(89503),c=o(63241),u=o(58371),g=o(51805),d=o(40461),p=o(11965);const h={fillColor:"fillColor",color:"fillColor",fill:"fillColor","fill-color":"fillColor",strokeColor:"strokeColor","stroke-color":"strokeColor","stroke-width":"strokeWidth"},m=(t,e)=>{const o={};return Object.keys(t).forEach((e=>{e in h?o[h[e]]=t[e]:o[e]=t[e]})),"string"==typeof t.fillColor&&(o.fillColor=(0,l.hexToRGB)(t.fillColor)),"string"==typeof t.strokeColor&&(o.strokeColor=(0,l.hexToRGB)(t.strokeColor)),{...o,...e}};let v;const f=(t,e,o)=>{if(null!=t&&t.features&&t.features.forEach((n=>{f(n,e,t.extraProps||o)})),null!=t&&t.geometry){const n={...t,properties:m(t.properties,e)};n.extraProps||(n.extraProps=o),v.push(n)}};function x(t){var e;return(null==(e=t.object)?void 0:e.extraProps)&&(0,p.tZ)("div",{className:"deckgl-tooltip"},Object.keys(t.object.extraProps).map(((e,o)=>{var n;return(0,p.tZ)(g.Z,{key:`prop-${o}`,label:`${e}: `,value:`${null==(n=t.object.extraProps)?void 0:n[e]}`})})))}const _=t=>{var e;return null==t||null==(e=t.properties)?void 0:e.fillColor},y=t=>{var e;return null==t||null==(e=t.properties)?void 0:e.strokeColor};function S(t,e,o,n){const i=t,r=i.fill_color_picker,s=i.stroke_color_picker,l=[r.r,r.g,r.b,255*r.a],g=[s.r,s.g,s.b,255*s.a],d={};let p;return l[3]>0&&(d.fillColor=l),g[3]>0&&(d.strokeColor=g),v=[],f(e.data,d),i.js_data_mutator&&(p=(0,c.Z)(i.js_data_mutator),v=p(v)),new a.Z({id:`geojson-layer-${i.slice_id}`,data:v,extruded:i.extruded,filled:i.filled,stroked:i.stroked,getFillColor:_,getLineColor:y,getLineWidth:i.line_width||1,pointRadiusScale:i.point_radius_scale,lineWidthUnits:i.line_width_unit,...(0,u.N)(i,n,x)})}const P=t=>{var e;const o=(0,n.useRef)(),a=(0,n.useCallback)((t=>{const{current:e}=o;e&&e.setTooltip(t)}),[]),{formData:i,payload:l,setControlValue:c,onAddFilter:u,height:g,width:h}=t,m=(0,n.useMemo)((()=>{if(i.autozoom){var e,o;const n=(null==l||null==(e=l.data)||null==(o=e.features)||null==o.reduce?void 0:o.reduce(((t,e)=>{const o=r()(e);return o?[...t,[o[0],o[1]],[o[2],o[3]]]:t}),[]))||[];if(n.length)return(0,d.Z)(t.viewport,{width:h,height:g,points:n})}return t.viewport}),[i.autozoom,g,null==l||null==(e=l.data)?void 0:e.features,t.viewport,h]),v=S(i,l,0,a);return(0,p.tZ)(s.F,{ref:o,mapboxApiAccessToken:l.data.mapboxApiKey,viewport:m,layers:[v],mapStyle:i.mapbox_style,setControlValue:c,height:g,width:h})},C=(0,n.memo)(P)},72502:(t,e,o)=>{o.r(e),o.d(e,{default:()=>h,getLayer:()=>p});var n=o(51047),a=(o(67294),o(61988)),i=o(28062),r=o(58371),s=o(63241),l=o(89503),c=o(89691),u=o(51805),g=o(11965);function d(t){return(0,g.tZ)("div",{className:"deckgl-tooltip"},(0,g.tZ)(u.Z,{label:(0,a.t)("Longitude and Latitude")+": ",value:`${t.coordinate[0]}, ${t.coordinate[1]}`}),(0,g.tZ)(u.Z,{label:(0,a.t)("Height")+": ",value:`${t.object.elevationValue}`}))}function p(t,e,o,a){const c=t,u=i.getScale(c.color_scheme).range().map((t=>(0,l.hexToRGB)(t)));let g=e.data.features;c.js_data_mutator&&(g=(0,s.Z)(c.js_data_mutator)(g));const p=(0,r.Z)(c.js_agg_function,(t=>t.weight));return new n.Z({id:`grid-layer-${c.slice_id}`,data:g,cellSize:c.grid_size,extruded:c.extruded,colorRange:u,outline:!1,getElevationValue:p,getColorValue:p,...(0,r.N)(c,a,d)})}const h=(0,c.G)(p,(function(t){return t.map((t=>t.position))}))},2429:(t,e,o)=>{o.r(e),o.d(e,{default:()=>h,getLayer:()=>p});var n=o(85672),a=(o(67294),o(61988)),i=o(45511),r=o(58371),s=o(63241),l=o(89503),c=o(89691),u=o(51805),g=o(11965);function d(t){return(0,g.tZ)("div",{className:"deckgl-tooltip"},(0,g.tZ)(u.Z,{label:(0,a.t)("Centroid (Longitude and Latitude): "),value:`(${null==t?void 0:t.coordinate[0]}, ${null==t?void 0:t.coordinate[1]})`}))}const p=(t,e,o,a)=>{var c,u,g,p;const h=t,{intensity:m=1,radius_pixels:v=30,aggregation:f="SUM",js_data_mutator:x,linear_color_scheme:_}=h;let y=e.data.features;x&&(y=(0,s.Z)(h.js_data_mutator)(y));const S=null==(c=(0,i.Z)())||null==(u=c.get(_))?void 0:u.createLinearScale([0,6]),P=null==S||null==(g=S.range())||null==(p=g.map((t=>(0,l.hexToRGB)(t))))?void 0:p.reverse();return new n.Z({id:`heatmp-layer-${h.slice_id}`,data:y,intensity:m,radiusPixels:v,colorRange:P,aggregation:f.toUpperCase(),getPosition:t=>t.position,getWeight:t=>t.weight?t.weight:1,...(0,r.N)(h,a,d)})},h=(0,c.G)(p,(function(t){return t.map((t=>t.position))}))},58125:(t,e,o)=>{o.r(e),o.d(e,{default:()=>R,getLayer:()=>Z});var n=o(4942),a=o(41576),i=o(43444),r=o(79543),s=Math.PI/3,l=[0,s,2*s,3*s,4*s,5*s];function c(t){return t[0]}function u(t){return t[1]}var g=o(91575),d=o(11959),p=o(89033);function h(){}const m={colorDomain:null,colorRange:r.K,getColorValue:{type:"accessor",value:null},getColorWeight:{type:"accessor",value:1},colorAggregation:"SUM",lowerPercentile:{type:"number",value:0,min:0,max:100},upperPercentile:{type:"number",value:100,min:0,max:100},colorScaleType:"quantize",onSetColorDomain:h,elevationDomain:null,elevationRange:[0,1e3],getElevationValue:{type:"accessor",value:null},getElevationWeight:{type:"accessor",value:1},elevationAggregation:"SUM",elevationLowerPercentile:{type:"number",value:0,min:0,max:100},elevationUpperPercentile:{type:"number",value:100,min:0,max:100},elevationScale:{type:"number",min:0,value:1},elevationScaleType:"linear",onSetElevationDomain:h,radius:{type:"number",value:1e3,min:1},coverage:{type:"number",min:0,max:1,value:1},extruded:!1,hexagonAggregator:function(t,e){const{data:o,radius:n}=t,{viewport:i,attributes:r}=e,d=o.length?function(t,e){const{attributes:o}=e,n=o.positions.value,{size:a}=o.positions.getAccessor();let i,r=1/0,s=1/0,l=-1/0,c=-1/0;for(i=0;i<a*t.length;i+=a){const t=n[i],e=n[i+1];Number.isFinite(t)&&Number.isFinite(e)&&(r=Math.min(t,r),l=Math.max(t,l),s=Math.min(e,s),c=Math.max(e,c))}return[r,s,l,c].every(Number.isFinite)?[(r+l)/2,(s+c)/2]:null}(o,e):null,p=function(t,e,o){const{unitsPerMeter:n}=e.getDistanceScales(o);return t*n[0]}(n,i,d),h=[],{iterable:m,objectInfo:v}=(0,g.jB)(o),f=r.positions.value,{size:x}=r.positions.getAccessor();for(const t of m){v.index++;const e=v.index*x,o=[f[e],f[e+1]];Number.isFinite(o[0])&&Number.isFinite(o[1])?h.push({screenCoord:i.projectFlat(o),source:t,index:v.index}):a.Z.warn("HexagonLayer: invalid position")()}const _=function(){var t,e,o,n=0,a=0,i=1,r=1,g=c,d=u;function p(t){var n,a={},i=[],r=t.length;for(n=0;n<r;++n)if(!isNaN(l=+g.call(null,s=t[n],n,t))&&!isNaN(c=+d.call(null,s,n,t))){var s,l,c,u=Math.round(c/=o),p=Math.round(l=l/e-(1&u)/2),h=c-u;if(3*Math.abs(h)>1){var m=l-p,v=p+(l<p?-1:1)/2,f=u+(c<u?-1:1),x=l-v,_=c-f;m*m+h*h>x*x+_*_&&(p=v+(1&u?1:-1)/2,u=f)}var y=p+"-"+u,S=a[y];S?S.push(s):(i.push(S=a[y]=[s]),S.x=(p+(1&u)/2)*e,S.y=u*o)}return i}function h(t){var e=0,o=0;return l.map((function(n){var a=Math.sin(n)*t,i=-Math.cos(n)*t,r=a-e,s=i-o;return e=a,o=i,[r,s]}))}return p.hexagon=function(e){return"m"+h(null==e?t:+e).join("l")+"z"},p.centers=function(){for(var s=[],l=Math.round(a/o),c=Math.round(n/e),u=l*o;u<r+t;u+=o,++l)for(var g=c*e+(1&l)*e/2;g<i+e/2;g+=e)s.push([g,u]);return s},p.mesh=function(){var e=h(t).slice(0,4).join("l");return p.centers().map((function(t){return"M"+t+"m"+e})).join("")},p.x=function(t){return arguments.length?(g=t,p):g},p.y=function(t){return arguments.length?(d=t,p):d},p.radius=function(n){return arguments.length?(e=2*(t=+n)*Math.sin(s),o=1.5*t,p):t},p.size=function(t){return arguments.length?(n=a=0,i=+t[0],r=+t[1],p):[i-n,r-a]},p.extent=function(t){return arguments.length?(n=+t[0][0],a=+t[0][1],i=+t[1][0],r=+t[1][1],p):[[n,a],[i,r]]},p.radius(1)}().radius(p).x((t=>t.screenCoord[0])).y((t=>t.screenCoord[1]));return{hexagons:_(h).map(((t,e)=>({position:i.unprojectFlat([t.x,t.y]),points:t,index:e}))),radiusCommon:p}},getPosition:{type:"accessor",value:t=>t.position},material:!0,_filterData:{type:"function",value:null,optional:!0}};class v extends p.Z{constructor(...t){super(...t),(0,n.Z)(this,"state",void 0)}initializeState(){const t=new d.Z({getAggregator:t=>t.hexagonAggregator,getCellSize:t=>t.radius});this.state={cpuAggregator:t,aggregatorState:t.state,vertices:null},this.getAttributeManager().add({positions:{size:3,type:5130,accessor:"getPosition"}})}updateState(t){if(super.updateState(t),t.changeFlags.propsOrDataChanged){const e=this.state.cpuAggregator.updateState(t,{viewport:this.context.viewport,attributes:this.getAttributes()});if(this.state.aggregatorState.layerData!==e.layerData){const{hexagonVertices:t}=e.layerData||{};this.setState({vertices:t&&this.convertLatLngToMeterOffset(t)})}this.setState({aggregatorState:e})}}convertLatLngToMeterOffset(t){const{viewport:e}=this.context;if(Array.isArray(t)&&6===t.length){const o=t[0],n=t[3],a=[(o[0]+n[0])/2,(o[1]+n[1])/2],i=e.projectFlat(a),{metersPerUnit:r}=e.getDistanceScales(a);return t.map((t=>{const o=e.projectFlat(t);return[(o[0]-i[0])*r[0],(o[1]-i[1])*r[1]]}))}return a.Z.error("HexagonLayer: hexagonVertices needs to be an array of 6 points")(),null}getPickingInfo({info:t}){return this.state.cpuAggregator.getPickingInfo({info:t})}_onGetSublayerColor(t){return this.state.cpuAggregator.getAccessor("fillColor")(t)}_onGetSublayerElevation(t){return this.state.cpuAggregator.getAccessor("elevation")(t)}_getSublayerUpdateTriggers(){return this.state.cpuAggregator.getUpdateTriggers(this.props)}renderLayers(){const{elevationScale:t,extruded:e,coverage:o,material:n,transitions:a}=this.props,{aggregatorState:r,vertices:s}=this.state,l=this.getSubLayerClass("hexagon-cell",i.Z),c=this._getSublayerUpdateTriggers();return new l({...s?{vertices:s,radius:1}:{radius:r.layerData.radiusCommon||1,radiusUnits:"common",angle:90},diskResolution:6,elevationScale:t,extruded:e,coverage:o,material:n,getFillColor:this._onGetSublayerColor.bind(this),getElevation:this._onGetSublayerElevation.bind(this),transitions:a&&{getFillColor:a.getColorValue||a.getColorWeight,getElevation:a.getElevationValue||a.getElevationWeight}},this.getSubLayerProps({id:"hexagon-cell",updateTriggers:c}),{data:r.layerData.data})}}(0,n.Z)(v,"layerName","HexagonLayer"),(0,n.Z)(v,"defaultProps",m),o(67294);var f=o(61988),x=o(28062),_=o(58371),y=o(63241),S=o(89503),P=o(89691),C=o(51805),b=o(11965);function w(t){return(0,b.tZ)("div",{className:"deckgl-tooltip"},(0,b.tZ)(C.Z,{label:(0,f.t)("Centroid (Longitude and Latitude): "),value:`(${t.coordinate[0]}, ${t.coordinate[1]})`}),(0,b.tZ)(C.Z,{label:(0,f.t)("Height")+": ",value:`${t.object.elevationValue}`}))}function Z(t,e,o,n){const a=t,i=x.getScale(a.color_scheme).range().map((t=>(0,S.hexToRGB)(t)));let r=e.data.features;a.js_data_mutator&&(r=(0,y.Z)(a.js_data_mutator)(r));const s=(0,_.Z)(a.js_agg_function,(t=>null==t?void 0:t.weight));return new v({id:`hex-layer-${a.slice_id}`,data:r,radius:a.grid_size,extruded:a.extruded,colorRange:i,outline:!1,getElevationValue:s,getColorValue:s,...(0,_.N)(a,n,w)})}const R=(0,P.G)(Z,(function(t){return t.map((t=>t.position))}))},97874:(t,e,o)=>{o.r(e),o.d(e,{default:()=>g,getLayer:()=>u}),o(67294);var n=o(48897),a=o(58371),i=o(63241),r=o(89691),s=o(51805),l=o(11965);function c(t){var e;return(null==(e=t.object)?void 0:e.extraProps)&&(0,l.tZ)("div",{className:"deckgl-tooltip"},Object.keys(t.object.extraProps).map(((e,o)=>(0,l.tZ)(s.Z,{key:`prop-${o}`,label:`${e}: `,value:`${t.object.extraProps[e]}`}))))}function u(t,e,o,r){const s=t,l=s.color_picker,u=[l.r,l.g,l.b,255*l.a];let g=e.data.features.map((t=>({...t,path:t.path,width:s.line_width,color:u})));return s.js_data_mutator&&(g=(0,i.Z)(s.js_data_mutator)(g)),new n.Z({id:`path-layer-${s.slice_id}`,getColor:t=>t.color,getPath:t=>t.path,getWidth:t=>t.width,data:g,rounded:!0,widthScale:1,widthUnits:s.line_width_unit,...(0,a.N)(s,r,c)})}const g=(0,r.G)(u,(function(t){let e=[];return t.forEach((t=>{e=e.concat(t.path)})),e}))},61778:(t,e,o)=>{o.r(e),o.d(e,{default:()=>p,getLayer:()=>d});var n=o(73715),a=(o(67294),o(56652)),i=o(61988),r=o(58371),s=o(89691),l=o(51805);const c=1609.34;var u=o(11965);function g(t,e){return o=>{var n,r,s,c,g,d,p,h,m;const v=(null==e?void 0:e[t.point_radius_fixed.value])||(0,a.Z)(null==(n=t.point_radius_fixed)?void 0:n.value);return(0,u.tZ)("div",{className:"deckgl-tooltip"},(0,u.tZ)(l.Z,{label:(0,i.t)("Longitude and Latitude")+": ",value:`${null==(r=o.object)||null==(s=r.position)?void 0:s[0]}, ${null==(c=o.object)||null==(g=c.position)?void 0:g[1]}`}),(null==(d=o.object)?void 0:d.cat_color)&&(0,u.tZ)(l.Z,{label:(0,i.t)("Category")+": ",value:`${null==(p=o.object)?void 0:p.cat_color}`}),(null==(h=o.object)?void 0:h.metric)&&(0,u.tZ)(l.Z,{label:`${v}: `,value:`${null==(m=o.object)?void 0:m.metric}`}))}}function d(t,e,o,a,i){const s=t,l=e.data.features.map((t=>{let e=(o=s.point_unit,n=t.radius,("square_m"===o?Math.sqrt(n/Math.PI):"radius_m"===o?n:"radius_km"===o?1e3*n:"radius_miles"===o?n*c:"square_km"===o?1e3*Math.sqrt(n/Math.PI):"square_miles"===o?Math.sqrt(n/Math.PI)*c:null)||10);var o,n;if(s.multiplier&&(e*=s.multiplier),t.color)return{...t,radius:e};const a=s.color_picker||{r:0,g:0,b:0,a:1},i=[a.r,a.g,a.b,255*a.a];return{...t,radius:e,color:i}}));return new n.Z({id:`scatter-layer-${s.slice_id}`,data:l,fp64:!0,getFillColor:t=>t.color,getRadius:t=>t.radius,radiusMinPixels:Number(s.min_radius)||void 0,radiusMaxPixels:Number(s.max_radius)||void 0,stroked:!1,...(0,r.N)(s,a,g(s,null==i?void 0:i.verboseMap))})}const p=(0,s.B)(d,(function(t){return t.map((t=>t.position))}))},42932:(t,e,o)=>{o.r(e),o.d(e,{default:()=>I,getLayer:()=>E});var n=o(50308),a=o.n(n),i=o(67294),r=o(4942),s=o(41576),l=o(72958),c=o(44059),u=o(44211),g=o(6948),d=o(39769),p=o(53982),h=o(5259),m=o(13717),v=o(79543);const f=[0,0,0,0],x=[0,255,0,255],_=["minColor","maxColor","colorRange","colorDomain"],y={cellSizePixels:{value:100,min:1},cellMarginPixels:{value:2,min:0,max:5},colorDomain:null,colorRange:v.K};class S extends h.Z{constructor(...t){super(...t),(0,r.Z)(this,"state",void 0)}static isSupported(t){return(0,u.ag)(t,[g.h.TEXTURE_FLOAT])}getShaders(){return{vs:"#define SHADER_NAME screen-grid-layer-vertex-shader\n#define RANGE_COUNT 6\n\nattribute vec3 positions;\nattribute vec3 instancePositions;\nattribute vec4 instanceCounts;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform vec3 cellScale;\nuniform vec4 minColor;\nuniform vec4 maxColor;\nuniform vec4 colorRange[RANGE_COUNT];\nuniform vec2 colorDomain;\nuniform bool shouldUseMinMax;\nuniform sampler2D maxTexture;\n\nvarying vec4 vColor;\nvarying float vSampleCount;\n\nvec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {\n  vec4 outColor = vec4(0., 0., 0., 0.);\n  if (value >= domain.x && value <= domain.y) {\n    float domainRange = domain.y - domain.x;\n    if (domainRange <= 0.) {\n      outColor = colorRange[0];\n    } else {\n      float rangeCount = float(RANGE_COUNT);\n      float rangeStep = domainRange / rangeCount;\n      float idx = floor((value - domain.x) / rangeStep);\n      idx = clamp(idx, 0., rangeCount - 1.);\n      int intIdx = int(idx);\n      outColor = colorRange[intIdx];\n    }\n  }\n  outColor = outColor / 255.;\n  return outColor;\n}\n\nvoid main(void) {\n  vSampleCount = instanceCounts.a;\n\n  float weight = instanceCounts.r;\n  float maxWeight = texture2D(maxTexture, vec2(0.5)).r;\n\n  float step = weight / maxWeight;\n  vec4 minMaxColor = mix(minColor, maxColor, step) / 255.;\n\n  vec2 domain = colorDomain;\n  float domainMaxValid = float(colorDomain.y != 0.);\n  domain.y = mix(maxWeight, colorDomain.y, domainMaxValid);\n  vec4 rangeColor = quantizeScale(domain, colorRange, weight);\n\n  float rangeMinMax = float(shouldUseMinMax);\n  vec4 color = mix(rangeColor, minMaxColor, rangeMinMax);\n  vColor = vec4(color.rgb, color.a * opacity);\n  picking_setPickingColor(instancePickingColors);\n\n  gl_Position = vec4(instancePositions + positions * cellScale, 1.);\n}\n",fs:"#define SHADER_NAME screen-grid-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying float vSampleCount;\n\nvoid main(void) {\n  if (vSampleCount <= 0.0) {\n    discard;\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[m.Z]}}initializeState(){const{gl:t}=this.context;this.getAttributeManager().addInstanced({instancePositions:{size:3,update:this.calculateInstancePositions},instanceCounts:{size:4,noAlloc:!0}}),this.setState({model:this._getModel(t)})}shouldUpdateState({changeFlags:t}){return t.somethingChanged}updateState(t){super.updateState(t);const{oldProps:e,props:o,changeFlags:n}=t,a=this.getAttributeManager();o.numInstances!==e.numInstances?a.invalidateAll():e.cellSizePixels!==o.cellSizePixels&&a.invalidate("instancePositions"),this._updateUniforms(e,o,n)}draw({uniforms:t}){const{parameters:e,maxTexture:o}=this.props,n=this.props.minColor||f,a=this.props.maxColor||x,i=this.props.colorDomain||[1,0],{model:r}=this.state;r.setUniforms(t).setUniforms({minColor:n,maxColor:a,maxTexture:o,colorDomain:i}).draw({parameters:{depthTest:!1,depthMask:!1,...e}})}calculateInstancePositions(t,{numInstances:e}){const{width:o,height:n}=this.context.viewport,{cellSizePixels:a}=this.props,i=Math.ceil(o/a),{value:r,size:s}=t;for(let t=0;t<e;t++){const e=t%i,l=Math.floor(t/i);r[t*s+0]=e*a/o*2-1,r[t*s+1]=1-l*a/n*2,r[t*s+2]=0}}_getModel(t){return new d.Z(t,{...this.getShaders(),id:this.props.id,geometry:new p.Z({drawMode:6,attributes:{positions:new Float32Array([0,0,0,1,0,0,1,1,0,0,1,0])}}),isInstanced:!0})}_shouldUseMinMax(){const{minColor:t,maxColor:e,colorDomain:o,colorRange:n}=this.props;return t||e?(s.Z.deprecated("ScreenGridLayer props: minColor and maxColor","colorRange, colorDomain")(),!0):!o&&!n}_updateUniforms(t,e,o){const{model:n}=this.state;if(_.some((o=>t[o]!==e[o]))&&n.setUniforms({shouldUseMinMax:this._shouldUseMinMax()}),t.colorRange!==e.colorRange&&n.setUniforms({colorRange:(0,v.P)(e.colorRange)}),t.cellMarginPixels!==e.cellMarginPixels||t.cellSizePixels!==e.cellSizePixels||o.viewportChanged){const{width:t,height:e}=this.context.viewport,{cellSizePixels:o,cellMarginPixels:a}=this.props,i=o>a?a:0,r=new Float32Array([(o-i)/t*2,-(o-i)/e*2,1]);n.setUniforms({cellScale:r})}}}(0,r.Z)(S,"layerName","ScreenGridCellLayer"),(0,r.Z)(S,"defaultProps",y);var P=o(92026),C=o(21900);const b={...S.defaultProps,getPosition:{type:"accessor",value:t=>t.position},getWeight:{type:"accessor",value:1},gpuAggregation:!0,aggregation:"SUM"},w="positions",Z={data:{props:["cellSizePixels"]},weights:{props:["aggregation"],accessors:["getWeight"]}};class R extends P.Z{constructor(...t){super(...t),(0,r.Z)(this,"state",void 0)}initializeState(){const{gl:t}=this.context;if(!S.isSupported(t))return this.setState({supported:!1}),void s.Z.error("ScreenGridLayer: ".concat(this.id," is not supported on this browser"))();super.initializeAggregationLayer({dimensions:Z,getCellSize:t=>t.cellSizePixels});const e={count:{size:1,operation:c.KM.SUM,needMax:!0,maxTexture:(0,C.hq)(t,{id:"".concat(this.id,"-max-texture")})}};this.setState({supported:!0,projectPoints:!0,weights:e,subLayerData:{attributes:{}},maxTexture:e.count.maxTexture,positionAttributeName:"positions",posOffset:[0,0],translation:[1,-1]}),this.getAttributeManager().add({[w]:{size:3,accessor:"getPosition",type:5130,fp64:this.use64bitPositions()},count:{size:3,accessor:"getWeight"}})}shouldUpdateState({changeFlags:t}){return this.state.supported&&t.somethingChanged}updateState(t){super.updateState(t)}renderLayers(){if(!this.state.supported)return[];const{maxTexture:t,numRow:e,numCol:o,weights:n}=this.state,{updateTriggers:a}=this.props,{aggregationBuffer:i}=n.count;return new(this.getSubLayerClass("cells",S))(this.props,this.getSubLayerProps({id:"cell-layer",updateTriggers:a}),{data:{attributes:{instanceCounts:i}},maxTexture:t,numInstances:e*o})}finalizeState(t){super.finalizeState(t);const{aggregationBuffer:e,maxBuffer:o,maxTexture:n}=this.state;null==e||e.delete(),null==o||o.delete(),null==n||n.delete()}getPickingInfo({info:t}){const{index:e}=t;if(e>=0){const{gpuGridAggregator:o,gpuAggregation:n,weights:a}=this.state,i=n?o.getData("count"):a.count;t.object=l.Z.getAggregationData({pixelIndex:e,...i})}return t}updateResults({aggregationData:t,maxData:e}){const{count:o}=this.state.weights;o.aggregationData=t,o.aggregationBuffer.setData({data:t}),o.maxData=e,o.maxTexture.setImageData({data:e})}updateAggregationState(t){const e=t.props.cellSizePixels,o=t.oldProps.cellSizePixels!==e,{viewportChanged:n}=t.changeFlags;let a=t.props.gpuAggregation;this.state.gpuAggregation!==t.props.gpuAggregation&&a&&!l.Z.isSupported(this.context.gl)&&(s.Z.warn("GPU Grid Aggregation not supported, falling back to CPU")(),a=!1);const i=a!==this.state.gpuAggregation;this.setState({gpuAggregation:a});const r=this.isAttributeChanged(w),{dimensions:c}=this.state,{data:u,weights:g}=c,d=r||i||n||this.isAggregationDirty(t,{compareAll:a,dimension:u}),p=this.isAggregationDirty(t,{dimension:g});this.setState({aggregationDataDirty:d,aggregationWeightsDirty:p});const{viewport:h}=this.context;if(n||o){const{width:t,height:o}=h,n=Math.ceil(t/e),a=Math.ceil(o/e);this.allocateResources(a,n),this.setState({scaling:[t/2,-o/2,1],gridOffset:{xOffset:e,yOffset:e},width:t,height:o,numCol:n,numRow:a})}p&&this._updateAccessors(t),(d||p)&&this._resetResults()}_updateAccessors(t){const{getWeight:e,aggregation:o,data:n}=t.props,{count:a}=this.state.weights;a&&(a.getWeight=e,a.operation=c.KM[o]),this.setState({getValue:(0,c._D)(o,e,{data:n})})}_resetResults(){const{count:t}=this.state.weights;t&&(t.aggregationData=null)}}(0,r.Z)(R,"layerName","ScreenGridLayer"),(0,r.Z)(R,"defaultProps",b);var L=o(61988),M=o(63241),T=o(58371),A=o(51805),D=o(40461),k=o(34634),j=o(11965);function z(t){var e,o,n;return(0,j.tZ)("div",{className:"deckgl-tooltip"},(0,j.tZ)(A.Z,{label:(0,L.t)("Longitude and Latitude")+": ",value:`${null==t||null==(e=t.coordinate)?void 0:e[0]}, ${null==t||null==(o=t.coordinate)?void 0:o[1]}`}),(0,j.tZ)(A.Z,{label:(0,L.t)("Weight")+": ",value:`${null==(n=t.object)?void 0:n.cellWeight}`}))}function E(t,e,o,n){const a=t,i=a.color_picker;let r=e.data.features.map((t=>({...t,color:[i.r,i.g,i.b,255*i.a]})));return a.js_data_mutator&&(r=(0,M.Z)(a.js_data_mutator)(r)),new R({id:`screengrid-layer-${a.slice_id}`,data:r,cellSizePixels:a.grid_size,minColor:[i.r,i.g,i.b,0],maxColor:[i.r,i.g,i.b,255*i.a],outline:!1,getWeight:t=>t.weight||0,...(0,T.N)(a,n,z)})}const N=t=>{const e=(0,i.useRef)(),o=(0,i.useCallback)((()=>{const e=t.payload.data.features||[],{width:o,height:n,formData:a}=t;return a.autozoom?(0,D.Z)(t.viewport,{width:o,height:n,points:(i=e,i.map((t=>t.position)))}):t.viewport;var i}),[t]),[n,r]=(0,i.useState)(t.payload.form_data),[s,l]=(0,i.useState)(o());(0,i.useEffect)((()=>{t.payload.form_data!==n&&(l(o()),r(t.payload.form_data))}),[o,t.payload.form_data,n]);const c=(0,i.useCallback)((t=>{const{current:o}=e;o&&o.setTooltip(t)}),[]),u=(0,i.useCallback)((()=>[E(t.formData,t.payload,a(),c)]),[t.formData,t.payload,c]),{formData:g,payload:d,setControlValue:p}=t;return(0,j.tZ)("div",null,(0,j.tZ)(k.F,{ref:e,viewport:s,layers:u(),setControlValue:p,mapStyle:g.mapbox_style,mapboxApiAccessToken:d.data.mapboxApiKey,width:t.width,height:t.height}))},I=(0,i.memo)(N)}}]);
//# sourceMappingURL=ad45e10439d288526753.chunk.js.map